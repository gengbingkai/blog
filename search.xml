<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>日记-每日更新</title>
    <url>/blog/2020/08/25/%E6%97%A5%E8%AE%B0-%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>&#8194;&#8194;&#8194;</p>
]]></content>
  </entry>
  <entry>
    <title>django配合mqtt</title>
    <url>/blog/2020/08/25/django%E9%85%8D%E5%90%88mqtt/</url>
    <content><![CDATA[<h4 id="mqtt是一个类似websocket的一种协议"><a href="#mqtt是一个类似websocket的一种协议" class="headerlink" title="mqtt是一个类似websocket的一种协议"></a>mqtt是一个类似websocket的一种协议</h4><p>mqtt<strong>的组成</strong></p>
<p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p>
<p>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</p>
<p>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</p>
<p>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</p>
<p>报文由报文头(Header)和报文体(Payload)组成。</p>
<p><strong>mqtt一般用于与硬件交互或者其他IOT类型的场景</strong></p>
<p>我们在django中使用mqtt，其实也不是在django中使用，就是在django项目里封装了几个方法</p>
<p>在这里说一下mosquitto基本命令，和作用</p>
<p>注意在你安装mosquitto的目录下执行，如果你配了环境变量，就无所谓了。</p>
<pre><code>mosquitto.exe  开启服务
mosquitto_sub -t aaa  监听aaa这个borker， 也可以是Topic
mosquitto_pub -t aaa -m &#39;hello&#39; 向aaa这个Topic发送hello，也可以是其它数据，一旦发送成功在监听aaa的地方就会收到发送的数据，并做一些处理。</code></pre><ol>
<li>在本地下载mosquitto，这个用来模拟我们的硬件设备发来的信息</li>
</ol>
<p><a href="https://mosquitto.org/download/" target="_blank" rel="noopener">https://mosquitto.org/download/</a></p>
<ol start="2">
<li>在我们的Python里下载paho-mqtt这个包，用于使用mqtt协议</li>
</ol>
<blockquote>
<p>pip install paho-mqtt</p>
</blockquote>
<ol start="3">
<li>我在这里写里一个py脚本</li>
</ol>
<pre><code>   # 为了能在外部脚本中调用Django ORM模型，必须配置脚本环境变量，将脚本注册到Django的环境变量中
   import os, sys
   import django
   # 第一个参数固定，第二个参数是工程名称.settings
   # os.environ.setdefault(&#39;DJANGO_SETTING_MODULE&#39;, &#39;Charger.settings&#39;)
   # django.setup()

   # 引入mqtt包
   import paho.mqtt.client as mqtt
   # 使用独立线程运行
   from threading import Thread
   # from app名 import models

   import time
   import json
   # 建立mqtt连接
   def on_connect(client, userdata, flag, rc):
       print(&quot;Connect with the result code &quot; + str(rc))
       client.subscribe(&#39;test/#&#39;, qos=2)

   # 接收、处理mqtt消息
   def on_message(client, userdata, msg):
       out = str(msg.payload.decode(&#39;utf-8&#39;))
       print(msg.topic)
       print(out)
       out = json.loads(out)

       # 收到消息后执行任务
       if msg.topic == &#39;test/newdata&#39;:
           print(out)



   # mqtt客户端启动函数
   def mqttfunction():
       global client
       # 使用loop_start 可以避免阻塞Django进程，使用loop_forever()可能会阻塞系统进程
       # client.loop_start()
       # client.loop_forever() 有掉线重连功能
       client.loop_forever(retry_first_connection=True)


   client = mqtt.Client(client_id=&quot;test&quot;, clean_session=False)

   # 启动函数
   def mqtt_run():
       client.on_connect = on_connect
       client.on_message = on_message
       # 绑定 MQTT 服务器地址
       broker = &#39;127.0.0.1&#39;
       # MQTT服务器的端口号
       client.connect(broker, 1883, 62)
       client.username_pw_set(&#39;user&#39;, &#39;user&#39;)
       client.reconnect_delay_set(min_delay=1, max_delay=2000)
       # 启动
       mqttthread = Thread(target=mqttfunction)
       mqttthread.start()


   # 启动 MQTT
   # mqtt_run()


   if __name__ == &quot;__main__&quot;:
       mqtt_run()</code></pre><p>如果需要封装</p>
<p>online-server.py</p>
<pre><code>import django
import os
import platform

if __name__ == &#39;__main__&#39;:
    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;Charger.settings&quot;)
    django.setup()

    from mqtt.mqtt_sub import start_sub

    if platform.platform().find(&#39;Windows&#39;) == -1:
        pid = os.getpid()
        os.system(&#39;echo %d &gt; /tmp/tcp_server/online.pid&#39; %pid)

    start_sub()

</code></pre><p>mqtt_sub.py</p>
<pre><code>from mqtt.handler import handle_msg
import paho.mqtt.client as paho

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot; + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(&quot;upload/state/bmscollector&quot;)


# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + &quot; &quot; + str(msg.payload))
    handle_msg(msg.payload)


def start_sub():
    client = paho.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    # client.username_pw_set(&#39;seari&#39;, &#39;V3cHeMIiYEQnWXh2&#39;)
    client.connect(&quot;127.0.0.1&quot;)
    client.loop_forever()
</code></pre><p>mqtt_pub.py</p>
<pre><code>import datetime
import json

import paho.mqtt.client as paho
from common.constant.mqtt_msg import MQTT_OK


def pub_msg(topic, msg, msg_type, data=None, err_code=MQTT_OK, err_info=None):
    def on_publish(client, userdata, result):  # create function for callback
        print(&quot;data published ,msg=&quot; + userdata)

    result = dict()
    result[&#39;MsgType&#39;] = msg.get(&#39;MsgType&#39;)
    result[&#39;MsgID&#39;] = msg.get(&#39;MsgID&#39;)
    result[&#39;SendTime&#39;] = datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S.%f&#39;)[:-3]
    result[&#39;ProductKey&#39;] = msg.get(&#39;ProductKey&#39;)
    result[&#39;DeviceKey&#39;] = msg.get(&#39;DeviceKey&#39;)
    result[&#39;Version&#39;] = msg.get(&#39;Version&#39;)
    result[&#39;ErrorCode&#39;] = err_code
    result[&#39;ErrorInfo&#39;] = err_info
    result[&#39;Data&#39;] = data

    client = paho.Client()  # create client object
    client.on_publish = on_publish  # assign function to callback
    client.connect(&#39;127.0.0.1&#39;)  # establish connection
    client.publish(topic, json.dumps(result))  # publish







if __name__ == &#39;__main__&#39;:
    pub_msg(&#39;upload/state/bmscollector&#39;, {&#39;MsgType&#39;:&#39;LoginReq&#39;,&#39;MsgID&#39;:1,&#39;ProductKey&#39;:1,&#39;DeviceKey&#39;:1,&#39;Version&#39;:1}, 1)
</code></pre>]]></content>
  </entry>
  <entry>
    <title>VMware安装Contos</title>
    <url>/blog/2020/08/25/VMware%E5%AE%89%E8%A3%85Contos/</url>
    <content><![CDATA[<h3 id="VMware-安装-Contos7"><a href="#VMware-安装-Contos7" class="headerlink" title="VMware 安装 Contos7"></a>VMware 安装 Contos7</h3><p><a href="https://blog.csdn.net/zhengTornado/article/details/104336454" target="_blank" rel="noopener">https://blog.csdn.net/zhengTornado/article/details/104336454</a></p>
]]></content>
  </entry>
  <entry>
    <title>内容推荐系统</title>
    <url>/blog/2020/08/18/%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="哈哈哈哈哈"><a href="#哈哈哈哈哈" class="headerlink" title="哈哈哈哈哈"></a>哈哈哈哈哈</h3><p>请看大佬的，菜鸟转发</p>
<p><a href="https://zhuanlan.zhihu.com/p/98295397" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98295397</a></p>
]]></content>
  </entry>
  <entry>
    <title>python识别车牌号百度AI</title>
    <url>/blog/2020/08/18/python%E8%AF%86%E5%88%AB%E8%BD%A6%E7%89%8C%E5%8F%B7%E7%99%BE%E5%BA%A6AI/</url>
    <content><![CDATA[<h3 id="使用python识别车牌号"><a href="#使用python识别车牌号" class="headerlink" title="使用python识别车牌号"></a>使用python识别车牌号</h3><p>作为一个调用接口工程师当然是用百度的啦，不用百度的，难道自己写吗？</p>
<p><strong>one</strong></p>
<p><a href="http://ai.baidu.com/" target="_blank" rel="noopener">http://ai.baidu.com/</a></p>
<p><a href="https://console.bce.baidu.com/?_=1597737253425&amp;fromai=1#/aip/overview" target="_blank" rel="noopener">https://console.bce.baidu.com/?_=1597737253425&amp;fromai=1#/aip/overview</a></p>
<p>在百度智能云把自己的账号和应用创建好，还有应用支持的功能，别的可以不选，要选一个车牌识别，当然可以尽量吧免费的都选上。</p>
<p>在这里本来应该贴上图片的，由于作者太懒，就算了</p>
<p><strong>two</strong></p>
<p>应用配好以后我把python的代码贴在下方</p>
<pre><code class="python">from aip import AipOcr

&quot;&quot;&quot; 你的 APPID AK SK &quot;&quot;&quot;
APP_ID = &#39;18757283&#39;
API_KEY = &#39;0IXA9tzXaqqmjzgKOQ1WRHqG&#39;
SECRET_KEY = &#39;WTqLN5hgOwDlZxfzdNWq0XLyqPt5b7mx&#39;  # 这里写你自己的哦，也可以用我的

client = AipOcr(APP_ID, API_KEY, SECRET_KEY)

&quot;&quot;&quot; 读取图片 &quot;&quot;&quot;
def get_file_content(filePath):
    with open(filePath, &#39;rb&#39;) as fp:
        return fp.read()
# 这里是你要事先准备好的车辆图片，一定要有车牌哦，把图片的路径写进去，就可以了。
image = get_file_content(r&#39;C:\Users\Administrator\Downloads\baidu.png&#39;)

&quot;&quot;&quot; 调用通用文字识别, 图片参数为本地图片 &quot;&quot;&quot;

&quot;&quot;&quot; 调用车牌识别 &quot;&quot;&quot;
client.licensePlate(image)

&quot;&quot;&quot; 如果有可选参数 &quot;&quot;&quot;
options = {}
options[&quot;multi_detect&quot;] = &quot;true&quot;

&quot;&quot;&quot; 带参数调用车牌识别 &quot;&quot;&quot;
client.licensePlate(image, options)
print(client.licensePlate(image, options)[&#39;words_result&#39;][0][&#39;number&#39;])</code></pre>
<p><strong>three</strong></p>
<p>还有哦，还要在python中下载baidu-aip的SDK</p>
<p>pip安装</p>
<pre><code>pip install baidu-aip</code></pre><p>setuptools安装</p>
<pre><code>python setup.py install </code></pre>]]></content>
  </entry>
  <entry>
    <title>django生成唯一id</title>
    <url>/blog/2020/07/19/django%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID%E4%B9%8Buuid/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>UUID是128位的全局唯一标识符，通常由32字节的字符串表示。它可以保证时间和空间的唯一性，也称为GUID，全称为：UUID —— Universally Unique IDentifier，Python 中叫 UUID。<br>它通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的唯一性。<br>UUID主要有五个算法，也就是五种方法来实现。</p>
<ul>
<li>uuid1()——基于时间戳。由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</li>
<li>uuid2()——基于分布式计算环境DCE（Python中没有这个函数）。算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。实际中很少用到该方法。</li>
<li>uuid3()——基于名字的MD5散列值。通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。</li>
<li>uuid4()——基于随机数。由伪随机数得到，有一定的重复概率，该概率可以计算出来。</li>
<li>uuid5()——基于名字的SHA-1散列值。算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code class="python">#! coding:utf-8
import uuid
print u&quot;uuid1  生成基于计算机主机ID和当前时间的UUID&quot;
print uuid.uuid1() # UUID(&#39;a8098c1a-f86e-11da-bd1a-00112444be1e&#39;)

print u&quot;\nuuid3  基于命名空间和一个字符的MD5加密的UUID&quot;
print uuid.uuid3(uuid.NAMESPACE_DNS, &#39;python.org&#39;) #UUID(&#39;6fa459ea-ee8a-3ca4-894e-db77e160355e&#39;)

print u&quot;\nuuid4  随机生成一个UUID&quot;
print uuid.uuid4()       #&#39;16fd2706-8baf-433b-82eb-8c7fada847da&#39;

print u&quot;\nuuid5  基于命名空间和一个字符的SHA-1加密的UUID&quot;
uuid.uuid5(uuid.NAMESPACE_DNS, &#39;python.org&#39;) #UUID(&#39;886313e1-3b8a-5372-9b90-0c9aee199e5d&#39;)

print u&quot;\n根据十六进制字符生成UUID&quot;
x = uuid.UUID(&#39;{00010203-0405-0607-0809-0a0b0c0d0e0f}&#39;)
print u&quot;转换成十六进制的UUID表现字符&quot;
print str(x)       # &#39;00010203-0405-0607-0809-0a0b0c0d0e0f&#39;</code></pre>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><pre><code class="python">uuid1  生成基于计算机主机ID和当前时间的UUID
31a936a1-2339-11e6-8542-9cb70ded607f

uuid3  基于命名空间和一个字符的MD5加密的UUID
6fa459ea-ee8a-3ca4-894e-db77e160355e

uuid4  随机生成一个UUID
67e6497c-8aec-4413-9955-da86f38ff2d6

uuid5  基于命名空间和一个字符的SHA-1加密的UUID

根据十六进制字符生成UUID
转换成十六进制的UUID表现字符
00010203-0405-0607-0809-0a0b0c0d0e0f</code></pre>
<h3 id="在Model中使用uuid"><a href="#在Model中使用uuid" class="headerlink" title="在Model中使用uuid"></a>在Model中使用uuid</h3><pre><code class="python">class User(AbstractUser):  # 用户表
    id = models.UUIDField(primary_key=True,default=uuid.uuid4(),editable=False)</code></pre>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>python的Airflow入门</title>
    <url>/blog/2020/07/19/python%E7%9A%84Airflow%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="Airflow介绍"><a href="#Airflow介绍" class="headerlink" title="Airflow介绍"></a>Airflow介绍</h4><p>airflow是一款开源的，分布式任务调度框架，它将一个具有上下级依赖关系的工作流</p>
<p>airflow是airbnb家的基于DAG(有向无环图)的任务管理系统, 最简单的理解就是一个高级版的crontab。它解决了crontab无法解决的任务依赖问题。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动web任务管理需要执行<code>airflow websever -D</code>命令，默认端口是8080</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code>pip install apache-airflow   #下载
airflow initdb   #初始化
airflow webserver -p 8080   # 运行，启动
airflow scheduler    #</code></pre><p>在8080端口可以访问</p>
<p>尽量不要再windows上用，有很多坑/bug</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用open拿出txt中的指定数据</title>
    <url>/blog/2020/07/19/%E4%BD%BF%E7%94%A8open%E6%8B%BF%E5%87%BAtxt%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>把txt中的ID后面的数据拿出来,写入到新的文档中。</p>
<pre><code class="txt">id:111
id:222
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333
id:333</code></pre>
<p>实例：</p>
<pre><code class="python">fi = open(&quot;p.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
fo = open(&quot;b.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)

wflag =False                #写标记
newline = []                #创建一个新的列表


for line in fi :            #按行读入文件，此时line的type是str
    if &quot;str&quot; in line:        #重置写标记
        wflag =False
    if &quot;id&quot; in line:     #检验是否到了要写入的内容
        a = line[3:]
        # print(a)
        newline.append(a)
        wflag = True
        continue

strlist = &quot;&quot;.join(newline)      #合并列表元素
newlines = str(strlist)         #list转化成str

for D in range(1,100):                       #删掉句中（）
    newlines = newlines.replace(&quot;（{}）&quot;.format(D),&quot;&quot;)

for P in range(0,9):                               #删掉前面数值标题
    for O in  range(0,9):
        for U in range(0, 9):
           newlines = newlines.replace(&quot;{}.{}{}&quot;.format(P,O,U), &quot;&quot;)
print(newlines)
fo.write(newlines)

fo.close()
fi.close()
</code></pre>
<p>结果：</p>
<pre><code>111
222
333
111
222
333</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>新式类，经典类</title>
    <url>/blog/2020/06/29/%E6%96%B0%E5%BC%8F%E7%B1%BB%EF%BC%8C%E7%BB%8F%E5%85%B8%E7%B1%BB/</url>
    <content><![CDATA[<p>在python2中，如果明确写了继承object，那么这个类就是新式类；如果没有写，那么就是旧式类（经典类）。</p>
<p>在python3中，不管写没写object，这个类都是新式类。</p>
<p>在调用顺序上:</p>
<p>​                      新式类是广度优先 :C—B—D—A</p>
<p>​                       旧式类是深度优先 :C—B—A—D</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/11613745-1bc1b4f522a1d20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/329/format/webp" srcset="/img/loading.gif" alt="img"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云短信服务</title>
    <url>/blog/2020/06/27/django%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>1、注册阿里云账号通过实名认证</p>
<p>2、开通短信服务(开通免费)</p>
<p>开通后可在控制台短信服务栏中查看</p>
<p><img src="https://img-blog.csdn.net/20180519111900954?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbWVvbmVNSA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="img"></p>
<p>3、创建Access Key,获取Access Key ID 和 Access Key Secret(具体看阿里云官方教程)</p>
<p>Access Key用于在程序中调用阿里云的服务API，个人理解相当于账号密码，用于认证个人信息的(程序中会用到)。可以创建多个Access Key，但Access Key具体内容只能在创建初期查看，之后是无法查看的，因此需要及时下载到本地。</p>
<p>4、创建短信签名和短信模板</p>
<pre><code>短信签名一般用于标记公司名或者是具体的业务，它会以下的形式出现在短信中：</code></pre><p>[短信签名] 短信内容….</p>
<pre><code>短信模板描述了短信的具体内容，可以提供变量来替代具体的数据，程序中会以JSON的形式向短信模板提供变量。</code></pre><p>注意：短信签名和短信模板创建后都需要通过审核，审核一般在几个小时内就能完成。</p>
<p><img src="https://img-blog.csdn.net/20180519113759843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbWVvbmVNSA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="img"></p>
<p>短信模板中的”模板CODE”在程序中会被使用到，通过模板CODE来明确使用哪一个模板。</p>
<p><img src="https://img-blog.csdn.net/2018051911403310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbWVvbmVNSA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="img"></p>
<p>5、项目中阿里云短信服务三方包，Python3.X</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是dockerfile</title>
    <url>/blog/2020/06/23/docker/</url>
    <content><![CDATA[<h2 id="docker先行"><a href="#docker先行" class="headerlink" title="docker先行"></a>docker先行</h2><p>​        1.什么是docker，他跟虚拟机的区别是什么？优劣势分别是什么？</p>
<p>​        2.镜像，容器，仓库的作用分别是什么？</p>
<p>​        3.列举5个镜像命令，5个仓库命令，并说出其含义</p>
<p>​        4.什么是dockerfile？他的优势是什么？</p>
<p>​        5.简述6个最常用的dockerfiler命令</p>
<p>​        6.什么是docker-conpose？他的使用场景和作用？</p>
<p>​        7.简述6个docker-compose命令</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker?"></a>什么是docker?</h3><p>​        Docker 是一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458" target="_blank" rel="noopener">Windows</a> 机器上，也可以实现<a href="https://baike.baidu.com/item/虚拟化/547949" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/沙箱/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p>
<h3 id="docker和虚拟机的对比"><a href="#docker和虚拟机的对比" class="headerlink" title="docker和虚拟机的对比"></a>docker和虚拟机的对比</h3><p>一个容器中运行原生Linux和共享主机与其它容器的内核，它运行一个独立的进程，不占用任何其它可执行文件的内存，使其轻量化。</p>
<p>相比之下，虚拟机(VM)运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源多。</p>
<p><img src="./pic/docke%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" alt="docke和虚拟机的隔离对比"></p>
<p><img src="./pic/docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83.png" srcset="/img/loading.gif" alt="docker和虚拟机的比较"></p>
<h3 id="docker的使用环境？"><a href="#docker的使用环境？" class="headerlink" title="docker的使用环境？"></a>docker的使用环境？</h3><ul>
<li>应用程序打包和发布</li>
<li>应用程序隔离</li>
<li>持续集成</li>
<li>部署微服务</li>
<li>快速搭建测试环境</li>
<li>提供paas环境（平台既服务）</li>
</ul>
<p>作部署。为了更快，更安全的部署项目</p>
<h3 id="daocker的学习目标"><a href="#daocker的学习目标" class="headerlink" title="daocker的学习目标"></a>daocker的学习目标</h3><h4 id="会使用docker部署任务。"><a href="#会使用docker部署任务。" class="headerlink" title="会使用docker部署任务。"></a>会使用docker部署任务。</h4><h3 id="docker的组成？"><a href="#docker的组成？" class="headerlink" title="docker的组成？"></a>docker的组成？</h3><p>​        1.镜像</p>
<p>​        2.容器</p>
<p>​        3.仓库</p>
<h5 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h5><ul>
<li>Docker镜像（Image）就是一个只读的模版。镜像可以用来创建Docker容器</li>
</ul>
<pre><code>操作系统分为内核和用户空间，对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个root文件系统。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</code></pre><ul>
<li>docker镜像分成存储</li>
</ul>
<pre><code>因为镜像包含系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层系统联合组成。
镜像构建时会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层，比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需要的内容，构建新的镜像。</code></pre><ul>
<li>获取镜像的两个方式<ul>
<li>从公共仓库拉取基础镜像</li>
<li>在基础镜像上运行成容器，安装各个软件，打包成为一个自定义的镜像</li>
</ul>
</li>
</ul>
<h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul>
<li>Docker利用容器（Container）来运行应用</li>
<li>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</li>
<li>镜像是只读的，容器在启动的时候创建一层可写层作为最上层</li>
<li>容器与镜像的关系</li>
</ul>
<pre><code>镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立宿主的系统下操作一样。这种特性使容器封装的应用比直接在宿主运行更加安全。
前面讲过镜像使用的是分层储存，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个味容器运行时读写而准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照Docker最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(volume)、或者绑定宿主目录，在这些位置的读写会跳过存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</code></pre><h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul>
<li>仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签（tag）</li>
</ul>
<pre><code>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。
一个Docker Registry中可以包含多个仓库(Repository);每个仓库可以包含多个标签(tag)；每个标签对应一个镜像。
通常，一个仓库会包含一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以laest作为默认标签。
以ubuntu镜像为例，ubuntu是仓库的名字，其包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需要哪个版本的镜像。如果忽略了标签，比如ubuntu,那将视为ubuntu:latest。
仓库名经常以两段式路径形式出现，比如jwilder/nginx-proxy,前者意味着Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry的软件或服务。</code></pre><ul>
<li>仓库分为公开仓库（Public）和私有仓库（Private）两种形式</li>
</ul>
<h3 id="关于镜像和容器的命令"><a href="#关于镜像和容器的命令" class="headerlink" title="关于镜像和容器的命令"></a>关于镜像和容器的命令</h3><p><strong>镜像管理命令</strong></p>
<p><img src="./pic/%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4.png" srcset="/img/loading.gif" alt="镜像命令"></p>
<p><strong>容器管理命令</strong></p>
<p><img src="./pic/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4.png" srcset="/img/loading.gif" alt="容器管理命令"></p>
<p><strong>容器管理命令参数</strong></p>
<p><img src="./pic/%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0.png" srcset="/img/loading.gif" alt="容器参数"></p>
<p><strong>容器管理资源限制命令</strong></p>
<p><img src="./pic/%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6.png" srcset="/img/loading.gif" alt="容器资源限制"></p>
<p>示例:<br>　　　　内存限额:<br>　　　　允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer:<br>　　　　docker run -d –name nginx03 –memory=”500m” –memory-swap=“600m” –oom-kill-disable nginx</p>
<p>　　　　CPU限额:</p>
<p>　　　　允许容器最多使用一个半的CPU:<br>　　　　run -d –name nginx04 –cpus=”1.5” nginx 允许容器最多使用50%的CPU:<br>　　　　docker run -d –name nginx05 –cpus=”.5” </p>
<p>​               <strong>查看容器：docker ps -a</strong></p>
<p>　　        <strong>查看哪些是停止的容器：docker ps -a -p</strong> </p>
<p>　　        <strong>启动一个容器：docker start 容器ID</strong></p>
<p>　　        <strong>创建启动一个容器：docker run</strong></p>
<p>　　        <strong>创建一个容器起别名并分配一个为终端：docker run -name mysql_test -it mysql /bin/bash</strong></p>
<p>　　        <strong>停止容器：docker stop 容器ID</strong></p>
<p>　　        <strong>进入容器：docker exec -it 容器ID</strong></p>
<p>　　        <strong>删除容器：docker rm [OPTIONS] 容器名</strong></p>
<p>　　　　        <strong>其中options有三种类型：</strong></p>
<p>　　　　　    　<strong>-f ：通过SIGKILL信号强制删除一个运行中的容器</strong></p>
<p>　　　　　　    <strong>-l ：移除容器间的网络连接，而非容器本身</strong></p>
<p>　　　　　　    <strong>-v ：-v 删除与容器关联的卷</strong></p>
<p>​                <strong>将容器打包成镜像：</strong></p>
<p>​                <strong>docker commit -a “Peter.com” -m “my apache” 容器名称或id 打包的镜像名称:标签</strong></p>
<p>​                    <strong>OPTIONS说明：</strong><br><strong>​                        -a :提交的镜像作者；</strong><br><strong>​                        -c :使用Dockerfile指令来创建镜像；</strong><br><strong>​                        -m :提交时的说明文字；</strong><br><strong>​                        -p :在commit时，将容器暂停。</strong></p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="什么是dockerfile"><a href="#什么是dockerfile" class="headerlink" title="什么是dockerfile"></a>什么是dockerfile</h3><p>​    Dockerfile是一个包含用于组合镜像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成镜像。</p>
<p>​    <code>docker build</code>命令用于从Dockerfile构建镜像。可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。</p>
<p>​    例如：利用/path/to/a/Dockerfile文件构建一个镜像</p>
<p>​    <code>docker build -f /path/to/a/Dockerfile</code></p>
<h3 id="Dockerfile文件说明"><a href="#Dockerfile文件说明" class="headerlink" title="Dockerfile文件说明"></a>Dockerfile文件说明</h3><p>​        Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是<em>FROM</em>。一个声明以<code>＃</code>字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p>
<h4 id="下面列举一些常用的命令"><a href="#下面列举一些常用的命令" class="headerlink" title="下面列举一些常用的命令"></a>下面列举一些常用的命令</h4><ul>
<li><strong><span style="color:red">FROM：</span>指定基础镜像，必须为第一个命令</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
　　FROM &lt;image&gt;
　　FROM &lt;image&gt;:&lt;tag&gt;
　　FROM &lt;image&gt;@&lt;digest&gt;
#示例：
　　FROM mysql:5.6
#注：
　　#tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</code></pre>
<ul>
<li><strong><span style="color:red">MAINTAINER：</span>维护者信息</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    MAINTAINER &lt;name&gt;
#示例：
    MAINTAINER Jasper Xu
    MAINTAINER sorex@163.com
    MAINTAINER Jasper Xu &lt;sorex@163.com&gt;</code></pre>
<ul>
<li><strong><span style="color:red">RUN：</span>构建镜像时执行的命令</strong></li>
</ul>
<pre><code class="dockerfile">#RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：
#shell执行
#格式：
    RUN &lt;command&gt;
#exec执行
#格式：
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
#示例：
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
    RUN apk update
    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]
#注：
#　　RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</code></pre>
<ul>
<li><strong><span style="color:red">ADD：</span>将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    ADD &lt;src&gt;... &lt;dest&gt;
    ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径
#示例：
    ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件
    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如：&quot;home.txt&quot;
    ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/
    ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/</code></pre>
<ul>
<li><strong><span style="color:red">COPY：</span>功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</strong></li>
<li><strong><span style="color:red">CMD：</span>&gt;构建容器后调用，也就是在容器启动时才进行调用。</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)
    CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)
    CMD command param1 param2 (执行shell内部命令)
#示例：
    CMD echo &quot;This is a test.&quot; | wc -
    CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]
#注：
# 　　CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</code></pre>
<ul>
<li><strong><span style="color:red">ENTRYPOINT：</span>&gt;配置容器，使其可执行化。配合CMD可省去”application”，只使用参数。</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)
    ENTRYPOINT command param1 param2 (shell内部命令)
#示例：
    FROM ubuntu
    ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
    CMD [&quot;-c&quot;]
#注：
#　　　ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</code></pre>
<ul>
<li><strong><span style="color:red">LABEL：</span>&gt;用于为镜像添加元数据</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
#示例：
　　LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;
#注：
#　　使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。
　　</code></pre>
<ul>
<li><strong><span style="color:red">ENV：</span>设置环境变量</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    ENV &lt;key&gt; &lt;value&gt;  #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量
    ENV &lt;key&gt;=&lt;value&gt; ...  #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行
#示例：
    ENV myName John Doe
    ENV myDog Rex The Dog
    ENV myCat=fluffy</code></pre>
<ul>
<li><strong><span style="color:red">EXPOSE：</span>指定于外界交互的端口</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    EXPOSE &lt;port&gt; [&lt;port&gt;...]
#示例：
    EXPOSE 80 443
    EXPOSE 8080
    EXPOSE 11211/tcp 11211/udp
#注：
#　　EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</code></pre>
<ul>
<li><strong><span style="color:red">VOLUME：</span>用于指定持久化目录</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    VOLUME [&quot;/path/to/dir&quot;]
#示例：
    VOLUME [&quot;/data&quot;]
    VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;
#注：
#　　一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：
#　　1 卷可以容器间共享和重用
#        2 容器并不一定要和其它容器共享卷
#        3 修改卷后会立即生效
#        4 对卷的修改不会对镜像产生影响
#        5 卷会一直存在，直到没有任何容器在使用它</code></pre>
<ul>
<li><strong><span style="color:red">WORKDIR：</span>工作目录，类似于cd命令</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    WORKDIR /path/to/workdir
#示例：
    WORKDIR /a  (这时工作目录为/a)
    WORKDIR b  (这时工作目录为/a/b)
    WORKDIR c  (这时工作目录为/a/b/c)
#注：
#　　通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</code></pre>
<ul>
<li><strong><span style="color:red">USER：</span>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</strong></li>
</ul>
<pre><code class="dockerfile">#格式:
　　USER user
　　USER user:group
　　USER uid
　　USER uid:gid
　　USER user:gid
　　USER uid:group

# 示例：
　　USER www

# 注：

#　　使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</code></pre>
<ul>
<li><strong><span style="color:red">ARG：</span>用于指定传递给构建运行时的变量</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
    ARG &lt;name&gt;[=&lt;default value&gt;]
#示例：
    ARG site
    ARG build_user=www
</code></pre>
<ul>
<li><strong><span style="color:red">ONBUILD：</span>用于设置镜像触发器</strong></li>
</ul>
<pre><code class="dockerfile">#格式：
　　ONBUILD [INSTRUCTION]
#示例：
　　ONBUILD ADD . /app/src
　　ONBUILD RUN /usr/local/bin/python-build --dir /app/src
#注：
#　　当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发
</code></pre>
<h3 id="Dockerfile安装启动nginx"><a href="#Dockerfile安装启动nginx" class="headerlink" title="Dockerfile安装启动nginx"></a>Dockerfile安装启动nginx</h3><pre><code class="dockerfile">FROM  centos

MAINTAINER 2020-05-11 peter 
RUN  yum -y install gcc*  make pcre-devel zlib-devel #下载编译工具
ADD nginx-1.14.2.tar.gz  /usr/src/   #将nginx安装包拷到docker容器内
WORKDIR /usr/src/nginx-1.14.2/                #指定工作目录
RUN useradd -s /sbin/nologin -M nginx           #指定用户组
RUN ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module &amp;&amp; make &amp;&amp; make install            #编译nginx
RUN ln -s /usr/local/nginx/sbin/* /usr/local/sbin/   #软连接nginx到快速启动

EXPOSE 80                #暴露端口号
WORKDIR /                #知道工作目录
RUN nginx                #开启nginx
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]   #容器启动后调用

</code></pre>
<h4 id="将dockerfile变成镜像"><a href="#将dockerfile变成镜像" class="headerlink" title="将dockerfile变成镜像"></a>将dockerfile变成镜像</h4><p>​    docker build -t (镜像的名字：版本号)  .</p>
<h4 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h4><p>FROM , RUN, ADD ,COPY,  EXPOSE ,   WORKDIR,   CMD   ,  VOLUME</p>
<h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h2><h3 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker compose"></a><strong>什么是docker compose</strong></h3><ol>
<li>Compose是一个定义和管理多容器的工具，使用Python语言编写。</li>
<li>使用Compose配置文件描述多个容器应用的架构，比如使用什么镜像、数据卷、网络、映射端口等；</li>
<li>然后一条命令管理所有服务，比如启动、停止、重启等。</li>
</ol>
<h3 id="docker-compose作用"><a href="#docker-compose作用" class="headerlink" title="docker compose作用　"></a><strong>docker compose作用</strong>　</h3><ol>
<li>现在我们要部署django项目，需要 nginx+mysql+redis+django等</li>
<li>我们需要开启四个docker容器进行部署每一个组件，如果每个容器单独管理太过于复杂，而且可能是给客户部署项目</li>
<li>docker compose就是一个可以同时管理一个项目中的多个docker容器的工具，一键部署启动</li>
</ol>
<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker compose"></a><strong>安装docker compose</strong></h3><p>　<strong>1、法1：下载 并安装docker compose</strong></p>
<p>　　　　curl -L <a href="https://github.com/docker/compose/releases/download/1.15.0/docker-compose-`uname" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.15.0/docker-compose-`uname</a> -s<code>-</code>uname -m` -o /usr/local/bin/docker-compose<br>　　　　chmod +x /usr/local/bin/docker-compose</p>
<p> 　　　　或者</p>
<p>　　　　pip install docker-compose</p>
<p>　<strong>2、法2：直接解压安装</strong></p>
<p>　　　　unzip docker-compose-linux-x86_64.zip   # 解压后只有一个文件 docker-compose</p>
<p>　　　　chmod +x docker-compose</p>
<p>　　　　mv docker-compose /usr/bin/</p>
<h3 id="YAML文件格式及编写注意事项"><a href="#YAML文件格式及编写注意事项" class="headerlink" title="YAML文件格式及编写注意事项"></a><strong>YAML文件格式及编写注意事项</strong></h3><p>　　　<strong>注：</strong>docker-compose使用yaml文件对容器进行描述</p>
<p>　　　YAML是一种标记语言很直观的数据序列化格式，可读性高。类似于XML数据描述语言，语法比XML简单的很多。</p>
<p>　　　YAML数据结构通过缩进来表示，连续的项目通过减号来表示，键值对用冒号分隔，数组用中括号括起来，hash用花括号括起来。</p>
<p>　　　<strong>YAML文件格式注意事项：</strong><br>　　　　　1.不支持制表符tab键缩进，需要使用空格缩进<br>　　　　　2.通常开头缩进2个空格<br>　　　　　3.字符后缩进1个空格，如冒号、逗号、横杆<br>　　　　　4.用井号注释<br>　　　　　5.如果包含特殊字符用单引号引起来<br>　　　　　6.布尔值（true、false、yes、no、on、off）必须用引号括起来，这样分析器会将他们解释为字符串。</p>
<h3 id="compose-配置常用字段"><a href="#compose-配置常用字段" class="headerlink" title="compose 配置常用字段"></a><strong>compose 配置常用字段</strong></h3><p><img src="./pic/docker-compose%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="./pic/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="命令举例"><a href="#命令举例" class="headerlink" title="命令举例"></a>命令举例</h3><pre><code class="python">&#39;&#39;&#39;1.docker-compose常用命令&#39;&#39;&#39;
docker-compose -f docker-compose.yml  up -d    # 启动docker-compose管理的所有容器
docker-compose ps                               # 列出 Compose 应用中的各个容器,类似docker ps
docker-compose logs web                        # 查看web服务日志
docker-compose down                               # 停止并移除容器、网络、镜像和数据卷.比stop更彻底
docker-compose images                             # 列出所有镜像


&#39;&#39;&#39;2.docker-compose其他命令 &#39;&#39;&#39;
docker-compose stop                               # 停止 Compose 应用相关的所有容器，但不会删除它们
docker-compose restart                           # 重启YAML文件中定义的服务
docker-compose kill                            # 停止服务
docker-compose rm                               # 删除指定已经停止服务的容器(它会删除容器和网络，但是不会删除卷和镜像)
docker-compose build                           # 构建或重建服务
docker-compose pull                               # 拉去并下载指定服务镜像
docker-compose push                            # push服务镜像
docker-compose top                               # 显示各个容器内运行的进程
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="基于nginx-uwsgi-mysql-celery-redis-django的docker-compose部署"><a href="#基于nginx-uwsgi-mysql-celery-redis-django的docker-compose部署" class="headerlink" title="基于nginx+uwsgi+mysql+celery+redis+django的docker-compose部署"></a>基于nginx+uwsgi+mysql+celery+redis+django的docker-compose部署</h3><p><strong>项目地址：</strong><a href="https://gitee.com/edushiyanlou/django-docker" target="_blank" rel="noopener">https://gitee.com/edushiyanlou/django-docker</a></p>
<h3 id="docker-compose详解"><a href="#docker-compose详解" class="headerlink" title="docker-compose详解"></a>docker-compose详解</h3><pre><code class="dockerfile">version: &#39;3&#39;                       # cocker compose版本号

services:                          # 顶级配置文件
  mysql:                           # 服务名: 容器建通信、管理容器
    image: mysql:5.7               # 引入官方mysql镜像
    volumes:
      - ./mysql:/var/lib/mysql         # 把当前文件夹下的 ./mysql文件夹挂载到docker容器 /var/lib/mysql 路径下
    expose:
      - &quot;3306&quot;                        # 将当前容器的端口3306端口暴露给link到本容器的容器
    restart: always                   # 宿主机重启自动拉起这个docker容器
    environment:
      - MYSQL_ROOT_PASSWORD=root             # mysql服务器root密码root
      - MYSQL_DATABASE=djangodocker          # 创建数据库 djangodocker
      - MYSQL_USER=django                    # 创建一个用户 django
      - MYSQL_PASSWORD=django                # 用户密码为django

  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/conf:/etc/nginx/conf.d
      - ./web/staticfiles:/django_static
    ports:
      - &quot;80:80&quot;                             # 绑定容器的80端口到主机的80端口
    depends_on:
      - web                                 # 必须先启动web容器然才能启动nginx容器

  redis:
    image: redis:alpine
    expose:
      - &quot;6379&quot;
    restart: always

  web:
    build: .
    # command: python manage.py runserver 0:8000
    # ports:
    #   - &quot;8000:8000&quot;
    command: uwsgi --ini uwsgi.ini             # 启动uwsgi命令
    working_dir: /code/web                     # 项目工作路径
    volumes:
      - .:/code                                # 将当前文件夹下所有文件挂载到容器的 /code 文件夹
    expose:
      - &quot;8000&quot;
    depends_on:                                # 必须mysql和reids容器启动后才能启动web容器
      - mysql
      - redis

  celery:
    build: .
    command: celery -A web worker -l info
    working_dir: /code/web
    volumes:
      - .:/code
    depends_on:
      - mysql
      - redis
</code></pre>
<p>运行：</p>
<p>​    <code>docker-compose -f docker-compose.yml up -d</code></p>
<h1 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h1><p>1、熟练部署的过程</p>
<p>2、将部署的过程编程docker-file/docker-compose 的自动化过程</p>
<p>3、讲清楚镜像，容器，仓库三个概念</p>
<p>4、明白docker的作用，使用场景，优势</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本命令</title>
    <url>/blog/2020/06/23/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>git init 初始化项目       : 就是新建.git文件</p>
<p>git add -A                       :把文件夹的所有文件提交到暂停区</p>
<p>git commit -m  ‘备注’    :把暂停区的文件提交</p>
<p>git remote add origin 路由地址      :创建分支  </p>
<p>git push -u origin master    :上传到码云</p>
<p>git clone 路由地址    :克隆仓库</p>
<p>git pull origin master     : 进入到仓库，拉取更新的部分代码</p>
<p>git checkout.   :回退，在没有 git add -A 的情况下使用有效</p>
<p>git reset HEAD  ：当我git add -A到本地暂停区时重置，，然后在使用git checkout.回退</p>
<p>git log   :查看提交日志</p>
<p>git reset –hard 输入git日志号： 就会立刻回退，这个是执行过git commit -m以后怎么回退代码</p>
<p>也可以用其他方法实现结果，思路要灵活</p>
<p>git checkout 分支名    ：切换分支</p>
<p>git branch   :查看当前分支</p>
<p><strong>把自己代码合并到develop分支</strong></p>
<p>git branch     先查看自己所在的分支</p>
<p> git checkout  develop   切换分支  ，如果提示没提交，就素质三连一下</p>
<p>git pull origin develop    拉取代码  ，获取develop的最新数据</p>
<p>git merge 《自己分支》  合并到develop分支</p>
<p>git push origin develop   合并成功，然后提交一下。</p>
<p><strong>把develop分支的代码拉到自己的分支</strong></p>
<p>git branch               先查看自己所在的分支</p>
<p>git checkout《自己分支》    切换分支  ，如果提示没提交，就素质三连一下</p>
<p>git pull origin  《自己分支》      拉取代码  ，获取gbk的最新数据</p>
<p>git merge  develop          合并到自己分支</p>
<p>git push origin 《自己分支 》       合并成功，然后提交一下。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux的基础命令</title>
    <url>/blog/2020/06/23/linux%E7%9A%84%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h4><p>启动、停止、重载命令<br>systemctl start nginx<br>systemctl stop nginx<br>systemctl reload nginx<br>systemctl status nginx</p>
<p>killall -9 nginx  相关nginx进行全部杀掉<br>nginx -V          查看版本<br>nginx -t          查看运行状态</p>
<h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><p>netstat -antp | grep :80    查看80端口被哪个服务占用<br>netstat -antp | grep        查看所有端口占用情况<br>ps -e                       显示所有进程<br>ps -f                       全格式，显示终端上的进程。<br>ps -a                       显示终端上的所有进程<br>kill -9 xxx                 杀死一个进程    </p>
<p>ps -ef|grep                 查看进程名</p>
<h4 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h4><p>1.列出所有可更新的软件清单命令：yum check-update<br>2.更新所有软件命令：yum update<br>3.仅安装指定的软件命令：yum install <package_name><br>4.仅更新指定的软件命令：yum update <package_name><br>5.列出所有可安裝的软件清单命令：yum list<br>6.删除软件包命令：yum remove <package_name><br>7.查找软件包 命令：yum search <keyword><br>8.清除缓存命令:<br>yum clean packages: 清除缓存目录下的软件包<br>yum clean headers: 清除缓存目录下的 headers<br>yum clean oldheaders: 清除缓存目录下旧的 headers<br>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</p>
<h4 id="管理文件-目录"><a href="#管理文件-目录" class="headerlink" title="管理文件/目录"></a>管理文件/目录</h4><p>ls: 列出目录及文件名<br>cd：切换目录<br>pwd：显示目前的目录<br>mkdir：创建一个新的目录<br>rmdir：删除一个空的目录<br>cp: 复制文件或目录<br>rm: 移除文件或目录<br>mv: 移动文件与目录，或修改文件与目录的名称</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>django项目中使用FastDFS</title>
    <url>/blog/2020/06/23/django%E4%BD%BF%E7%94%A8fastDFS/</url>
    <content><![CDATA[<h1 id="django项目中使用FastDFS"><a href="#django项目中使用FastDFS" class="headerlink" title="django项目中使用FastDFS"></a>django项目中使用FastDFS</h1><h1 id="FastDFS客户端与自定义文件存储系统"><a href="#FastDFS客户端与自定义文件存储系统" class="headerlink" title="FastDFS客户端与自定义文件存储系统"></a>FastDFS客户端与自定义文件存储系统</h1><h2 id="1-FastDFS的Python客户端"><a href="#1-FastDFS的Python客户端" class="headerlink" title="1. FastDFS的Python客户端"></a>1. FastDFS的Python客户端</h2><p>python版本的FastDFS客户端使用说明参考<a href="https://github.com/jefforeilly/fdfs_client-py" target="_blank" rel="noopener">https://github.com/jefforeilly/fdfs_client-py</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装提供给大家的fdfs_client-py-master.zip到虚拟环境中</p>
<pre><code>pip install fdfs_client-py-master.zippip install mutagenpip isntall requests</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用FastDFS客户端，需要有配置文件。我们在meiduo_mall/utils目录下新建fastdfs目录，将提供给大家的client.conf配置文件放到这个目录中。</p>
<p>需要修改一下client.conf配置文件</p>
<pre><code>base_path=FastDFS客户端存放日志文件的目录tracker_server=运行tracker服务的机器ip:22122</code></pre><p>上传文件需要先创建fdfs_client.client.Fdfs_client的对象，并指明配置文件，如</p>
<pre><code>from fdfs_client.client import Fdfs_clientclient = Fdfs_client(&#39;meiduo_mall/utils/fastdfs/client.conf&#39;)</code></pre><p>通过创建的客户端对象执行上传文件的方法</p>
<pre><code>client.upload_by_filename(文件名)或client.upload_by_buffer(文件bytes数据)</code></pre><p>如：</p>
<pre><code>&gt;&gt;&gt; ret = client.upload_by_filename(&#39;/Users/delron/Desktop/1.png&#39;)getting connection&lt;fdfs_client.connection.Connection object at 0x1098d4cc0&gt;&lt;fdfs_client.fdfs_protol.Tracker_header object at 0x1098d4908&gt;&gt;&gt;&gt; ret{&#39;Group name&#39;: &#39;group1&#39;, &#39;Remote file_id&#39;: &#39;group1/M00/00/02/CtM3BVr-k6SACjAIAAJctR1ennA809.png&#39;, &#39;Status&#39;: &#39;Upload successed.&#39;, &#39;Local file name&#39;: &#39;/Users/delron/Desktop/1.png&#39;, &#39;Uploaded size&#39;: &#39;151.00KB&#39;, &#39;Storage IP&#39;: &#39;10.211.55.5&#39;}&gt;&gt;&gt;</code></pre><ul>
<li>Remote file_id 即为FastDFS保存的文件的路径</li>
</ul>
<h2 id="2-自定义Django文件存储系统"><a href="#2-自定义Django文件存储系统" class="headerlink" title="2. 自定义Django文件存储系统"></a>2. 自定义Django文件存储系统</h2><p>在学习Django框架的时候，我们已经讲过，Django自带文件存储系统，但是默认文件存储在本地，在本项目中，我们需要将文件保存到FastDFS服务器上，所以需要自定义文件存储系统。</p>
<p>自定义文件存储系统的方法如下：</p>
<p>1）需要继承自<code>django.core.files.storage.Storage</code>，如</p>
<pre><code>from django.core.files.storage import Storageclass FastDFSStorage(Storage):    ...</code></pre><p>2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code> 1 from django.conf import settings
 2 from django.core.files.storage import Storage
 3 
 4 class FasfDFSStorage(Storage):
 5     def __init__(self, base_url=None, client_conf=None):
 6         if base_url is None:
 7             base_url = settings.FDFS_URL
 8         self.base_url = base_url
 9         if client_conf is None:
10             client_conf = settings.FDFS_CLIENT_CONF
11         self.client_conf = client_conf</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code></code></pre><p>3）存储类中必须实现<code>_open()</code>和<code>_save()</code>方法，以及任何后续使用中可能用到的其他方法。</p>
<ul>
<li><p><code>_open(name, mode=&#39;rb&#39;)</code></p>
<p>被Storage.open()调用，在打开文件时被使用。</p>
</li>
<li><p><code>_save(name, content)</code></p>
<p>被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。</p>
<p>Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。</p>
</li>
<li><p><code>exists(name)</code></p>
<p>如果名为name的文件在文件系统中存在，则返回True，否则返回False。</p>
</li>
<li><p><code>url(name)</code></p>
<p>返回文件的完整访问URL</p>
</li>
<li><p><code>delete(name)</code></p>
<p>删除name的文件</p>
</li>
<li><p><code>listdir(path)</code></p>
<p>列出指定路径的内容</p>
</li>
<li><p><code>size(name)</code></p>
<p>返回name文件的总大小</p>
<p>注意，并不是这些方法全部都要实现，可以省略用不到的方法。</p>
</li>
</ul>
<p>4）需要为存储类添加<code>django.utils.deconstruct.deconstructible</code>装饰器</p>
<p>我们在meiduo_mall/utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code> from django.conf import settings
 from django.core.files.storage import Storage
 from django.utils.deconstruct import deconstructible
 from fdfs_client.client import Fdfs_client


@deconstructible
 class FasfDFSStorage(Storage):
     def __init__(self, base_url=None, client_conf=None):
         &quot;&quot;&quot;
         初始化
         :param base_url: 用于构造图片完整路径使用，图片服务器的域名
         :param client_conf: FastDFS客户端配置文件的路径
         &quot;&quot;&quot;
         if base_url is None:
             base_url = settings.FDFS_URL
         self.base_url = base_url
         if client_conf is None:
             client_conf = settings.FDFS_CLIENT_CONF
         self.client_conf = client_conf

     def _open(self, name, mode=&#39;rb&#39;):
         &quot;&quot;&quot;
         用不到打开文件，所以省略
         &quot;&quot;&quot;
         pass

     def _save(self, name, content):
         &quot;&quot;&quot;
         在FastDFS中保存文件
         :param name: 传入的文件名
         :param content: 文件内容
         :return: 保存到数据库中的FastDFS的文件名
         &quot;&quot;&quot;
         client = Fdfs_client(self.client_conf)
         ret = client.upload_by_buffer(content.read())
         if ret.get(&quot;Status&quot;) != &quot;Upload successed.&quot;:
             raise Exception(&quot;upload file failed&quot;)
         file_name = ret.get(&quot;Remote file_id&quot;)
         return file_name

     def url(self, name):
         &quot;&quot;&quot;
         返回文件的完整URL路径
         :param name: 数据库中保存的文件名
         :return: 完整的URL
         &quot;&quot;&quot;
         return self.base_url + name

     def exists(self, name):
         &quot;&quot;&quot;
         判断文件是否存在，FastDFS可以自行解决文件的重名问题
         所以此处返回False，告诉Django上传的都是新文件
         :param name:  文件名
         :return: False
         &quot;&quot;&quot;
         return False</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code></code></pre><h2 id="3-在Django配置中设置自定义文件存储类"><a href="#3-在Django配置中设置自定义文件存储类" class="headerlink" title="3. 在Django配置中设置自定义文件存储类"></a>3. 在Django配置中设置自定义文件存储类</h2><p>在settings/dev.py文件中添加设置</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code># django文件存储, 指定自定义的文件存储系统
DEFAULT_FILE_STORAGE = &#39;meiduo_mall.utils.fastdfs.fdfs_storage.FastDFSStorage&#39;

# FastDFS
FDFS_URL = &#39;http://image.meiduo.site:8888/&#39;  
FDFS_CLIENT_CONF = os.path.join(BASE_DIR, &#39;utils/fastdfs/client.conf&#39;)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<h2 id="4-添加image域名"><a href="#4-添加image域名" class="headerlink" title="4. 添加image域名"></a>4. 添加image域名</h2><p>在/etc/hosts中添加访问FastDFS storage服务器的域名</p>
<pre><code>127.0.0.1   image.meiduo.site</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx部署踩坑</title>
    <url>/blog/2020/06/18/nginx%E9%83%A8%E7%BD%B2%E9%87%87%E5%9D%91/</url>
    <content><![CDATA[<p>Vue路由history模式踩坑记录：nginx配置解决404问题</p>
<p><strong>问题背景：</strong></p>
<p>　　vue-router 默认是hash模式，使用url的hash来模拟一个完整的url，当url改变的时候，页面不会重新加载。但是如果我们不想hash这种以#号结尾的路径时候的话，我们可以使用路由的history的模式。比如如下网址：使用hash模式的话，那么访问变成 <a href="http://localhost:8080/bank/page/count/#/" target="_blank" rel="noopener">http://localhost:8080/bank/page/count/#/</a> 这样的访问，如果路由使用 history的话，那么访问的路径变成 如下：<a href="http://localhost:8080/bank/page/count" target="_blank" rel="noopener">http://localhost:8080/bank/page/count</a> 这样的了；</p>
<p>　　不过history的这种模式需要后台配置支持。比如：当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404</p>
<p>　　怎么解决呢？我们现在可以把所有请求都转发到 <a href="http://localhost:8080/bank/page/index.html上就可以了。" target="_blank" rel="noopener">http://localhost:8080/bank/page/index.html上就可以了。</a></p>
<p><strong>解决方案：</strong></p>
<p>　　对于VUE的router[mode: history]模式在开发的时候，一般都不出问题。是因为开发时用的服务器为node，Dev环境中自然已配置好了。</p>
<p>　　但对于放到nginx下运行的时候，自然还会有其他注意的地方。总结如下：</p>
<p>　　在nginx里配置了以下配置后， 可能首页没有问题，但链接其他会出现（404）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>　　　　location / {
            root   D:\Test\exprice\dist;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;
            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;
            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;
            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;
        }

        location ^~/api/ {
            proxy_pass   http://39.105.109.245:8080/;
        }</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p>　　为了解决404，需要通过以下两种方式：</p>
<p>　　1、官网推荐</p>
<pre><code>location / {
　　root   D:\Test\exprice\dist;
　　index  index.html index.htm;
　　try_files $uri $uri/ /index.html;</code></pre><p>　　2、匹配errpr_page</p>
<pre><code>location /{
　　root   /data/nginx/html;
　　index  index.html index.htm;
　　error_page 404 /index.html;
}</code></pre>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>socket的阻塞和非阻塞，5种IO模型</title>
    <url>/blog/2020/06/18/socket%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>同步/异步主要针对C端:</strong><br><strong>同步：</strong><br>      所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。<strong>也就是必须一件一件事做*</strong>,*等前一件做完了才能做下一件事。</p>
<p>​    同步，就是我客户端（c端调用者）调用一个功能，该功能没有结束前，我（c端调用者）死等结果</p>
<p><strong>异步：</strong><br>      异步的概念和同步相对。当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>​    异步，就是我（c端调用者）调用一个功能，不需要知道该功能结果，该功能有结果后通知我（c端调用者）即回调通知。</p>
<p><strong>阻塞/非阻塞主要针对S端:</strong></p>
<p><strong>阻塞</strong><br>     阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回</p>
<p>​    <strong>快递的例子：</strong>比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p>
<p>阻塞，      就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有接收完数据或者没有得到结果之前，我不会返回。</p>
<p><strong>非阻塞</strong><br>      非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>​     还是等快递的例子：如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取。</p>
<p>非阻塞，  就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者</p>
<h4 id="Linux下的五种I-O模型"><a href="#Linux下的五种I-O模型" class="headerlink" title="Linux下的五种I/O模型"></a>Linux下的五种I/O模型</h4><p>1)阻塞I/O（blocking I/O）<br>2)非阻塞I/O （nonblocking I/O）<br>3) I/O复用(select 和poll) （I/O multiplexing）<br>4)信号驱动I/O （signal driven I/O (SIGIO)）<br>5)异步I/O （asynchronous I/O (the POSIX aio_functions)）</p>
<p>前四种都是同步，只有最后一种才是异步IO。</p>
<p><strong>1.阻塞I/O模型：</strong></p>
<p>  简介：进程会一直阻塞，直到数据拷贝完成</p>
<p>​     应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。</p>
<p><img src="https://img2020.cnblogs.com/blog/1394324/202006/1394324-20200617170018529-365239351.png" srcset="/img/loading.gif" alt=""></p>
<p>​    <font color='red'> 当调用recv()函数时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。当数据准备好后，将数据从系统缓冲区复制到用户空间，然后该函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数就会处于等待状态。</font></p>
<p><strong>非阻塞IO模型</strong></p>
<p>   简介：非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；</p>
<p>我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。</p>
<p><img src="/img/socket2.jpg" srcset="/img/loading.gif" alt="hexo_themes"></p>
<p><strong>IO复用模型：</strong><br>             简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；</p>
<p><img src="https://img-blog.csdn.net/20160410110100128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p>
<p>  I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<p><strong>信号驱动IO</strong><br>    简介：两次调用，两次返回；</p>
<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p><img src="https://img-blog.csdn.net/20160410110102941?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p>
<p><strong>异步IO模型</strong><br>         简介：数据拷贝的时候进程无需阻塞。</p>
<p> 当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作</p>
<p><img src="https://img-blog.csdn.net/20160410110105847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p>
<p>同步IO引起进程阻塞，直至IO操作完成。<br>异步IO不会引起进程阻塞。<br>IO复用是先通过select调用阻塞。</p>
<p>5个I/O模型的比较：</p>
<p><img src="https://img-my.csdn.net/uploads/201204/12/1334216724_2405.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><strong>select</strong></p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p><strong>poll</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<p><strong>epoll</strong></p>
<p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p>
<p>epoll的优点：</p>
<p>epoll最重要的优点是他可以直接告诉用户程序哪一个，比如现在用epoll去监控10000个socket链接，交给内核去监测，现在有一个连接有数据了，epoll会直接告诉用户程序哪个连接有数据了。</p>
<p>epoll通过内核和用户空间共享一块内存来实现的。 </p>
<h3 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a>select、poll、epoll 区别总结：</h3><p>1、支持一个进程所能打开的最大连接数</p>
<table>
<thead>
<tr>
<th>select</th>
<th>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td>
</tr>
</tbody></table>
<p>2、FD剧增后带来的IO效率问题</p>
<table>
<thead>
<tr>
<th>select</th>
<th>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody></table>
<p>3、 消息传递方式</p>
<table>
<thead>
<tr>
<th>select</th>
<th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>redis乐观锁</title>
    <url>/blog/2020/06/17/redis%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h4 id="redis乐观锁"><a href="#redis乐观锁" class="headerlink" title="redis乐观锁"></a>redis乐观锁</h4><p>乐观锁的核心概念指的是当多个用户修改同一条数据的时候，增加一个版本号的概念，也就是说不同的用户修改数据的时候<br>需要观测版本号是否与当前数据库中保存数据的版本号相同，如果相同则可以修改，如果不同则不能够修改。<br>如果要想实现乐观锁的处理，那么需要打开两个 redis 客户端。<br>1、 现在在里面随意设置一个数据：set test java；</p>
<p>2、 【第一个 session】启用乐观锁：<br>watch test<br>multi</p>
<p>3、 【第二个 session】更新数据：<br>set test hadoop</p>
<p>4、 【第一个 session】修改数据，并且进行事务提交；<br>set test tomcat<br>exec</p>
<p>此时执行更新之后返回的内容为“(nil)”，那么就表示当前的更新操作失败了。</p>
<p>乐观锁严格来讲属于一种逻辑锁，像传统的关系型数据库都会存在有悲观锁</p>
<p>原文链接：<a href="https://blog.csdn.net/shuxing520/article/details/77741905" target="_blank" rel="noopener">https://blog.csdn.net/shuxing520/article/details/77741905</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的事务</title>
    <url>/blog/2020/06/17/redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　</p>
<p>Redis事务没有隔离级别</p>
<p><strong>乐观锁介绍：（乐观锁主要用于抢红包，淘宝抢购，秒杀之类）</strong></p>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做</p>
<p><strong>Redis不保证原子性：</strong></p>
<p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<p>　　1.Redis的事务没有关系数据库事务提供的回滚（rollback），所以开发者必须在事务执行失败后进行后续的处理；</p>
<p>　　2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</p>
<p>　　3.如果在一个事务中出现运行错误，那么正确的命令会被执行。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务和引擎</title>
    <url>/blog/2020/06/17/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM。</p>
<p><strong>innodb</strong></p>
<p>Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统</p>
<p><strong>MyIASM</strong></p>
<p>MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先</p>
<p>总结：大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的，大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候</p>
<p>简单来说就是在查询多的场景适合用MyIASM比较快，在数据量大是且需要频繁添加修改是适合用于innodb。    </p>
<p><strong>两种引擎的数据结构</strong></p>
<p>MyIASM和innodb都是B+Tree     </p>
<p><strong>两种引擎的存储方式</strong></p>
<p>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。</p>
<p>Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>事务是数据库系统区别于其他一切文件系统的重要特性之一</strong></p>
<p><strong>事务是一组具有原子性的SQL语句，或是一个独立的工作单元</strong></p>
<ol>
<li><p>原子性(Atomicity)：整个事物的所有操作要么全部提交成功，要么全部失败回滚(不会出现部分执行的情况)。</p>
<p>要么全部成功，要么全部失败回滚，不会出现部分成功和回滚</p>
</li>
<li><p>一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p>
<p>几个任务执行，但是执行的结果要与执行之前一致</p>
<p>栗子：场景是这样的，小范转100块钱给小黄，那么这个事务系统必须要保证小范扣了100块钱，而且小黄也必须要加了100块钱。这样的结果就实现了事务的一致性</p>
</li>
<li><p>隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p>
<p><strong>事物隔离级别</strong></p>
<ul>
<li><p><strong>未提交读: 脏读（READ UNCOMMITTED）</strong></p>
<p>​    事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据</p>
<p>​    所以事务2查询的数据是不正确的，因此出现了脏读的问题。</p>
<p>​        栗子：老板给我发工资本来是要发1K，但是老板发错了，发了10K，我去查工资，发现老板好大方竟然发10K，好高兴，后来老板发现了，改了回来，我又去查了，发现怎么变成了1K，这个情况就是脏读。</p>
</li>
<li><p><strong>提交读: 不可重复读（READ COMMITTED）</strong></p>
<p>事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。</p>
<p>但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变。</p>
<p>导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。</p>
<p>栗子：我有一张会员卡，我第一次查询余额还有100元，单同时我的家人在使用这张会员卡，使用过程中减了50元，我第二次查询的时候，一看怎么变成50元了，这个就是提交读</p>
</li>
<li><p><strong>可重复度（repeatable read，RR）</strong><br>事务总是只能看见在启动的那个时刻，数据库的状态。事务未提交之前做的变更，其它事务看不见。事务执行期间，数据库中已经发生的变更，这个事务也看不见。只能看见事务刚启动时刻，数据库的状态。</p>
</li>
<li><p><strong>串行化（serializable）</strong><br>事务对某一行的操作会加锁，“写”会加“写锁”，“读”会加“读锁”，在锁释放掉之前，其它的事务都无法都这一行的记录进行操作。必须等之前的事务执行完毕，释放锁。后面的事务又会重新加锁。</p>
</li>
</ul>
</li>
<li><p>持久性(Durability):  一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>一旦事务执行成功，那么对数据的操作就是永久性的，不过是数据库宕机还是其他原因都不会改变。</p>
<p>栗子：我要给小明转100元，而小明一旦收到这100元，我这里减100元，这个任务一旦成功，就是永久性的，不会因为其他因素改变。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发介绍</title>
    <url>/blog/2020/06/16/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="高并发介绍"><a href="#高并发介绍" class="headerlink" title="高并发介绍"></a>高并发介绍</h2><p>　<strong>高并发中一些概念</strong></p>
<p>　　<strong>1.</strong> <strong>PV(访问量)：</strong> 页面访问量，页面刷新一次算一次。</p>
<p>　　<strong>2. UV(独立访客)：</strong> 即Unique Visitor，一个客户端（电脑，手机）为一个访客；</p>
<p>　　<strong>3. DAU(日活跃用户数)：</strong>登录或使用了某个产品的用户数，这与流量统计工具里的访客（UV）概念相似。</p>
<p>　　<strong>4. 峰值QPS：</strong></p>
<p>　　　　　<strong>原理：</strong>每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间</p>
<p>　　　　　<strong>公式：</strong>( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p>
<p>　　<strong>5.</strong> <strong>QPS/TPS(每秒查询率)：</strong>每秒能够查询次数（QPS/TPS= 并发数 / 平均响应时间）</p>
<p>　　　　　<strong>并发数：</strong>并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p>
<p>　　　　　<strong>吐吞量：</strong>吞吐量是指系统在单位时间内处理请求的数量</p>
<p>　　　　　<strong>响应时间（RT）：</strong>响应时间是指系统对请求作出响应的时间，一般取平均响应时间</p>
<p>　　</p>
<p>　　<strong>例1：</strong></p>
<p>　　　　1. 假设1秒钟100个请求，处理每个请求需要花2秒，</p>
<p>　　　　2. 那么 50（每秒可以处理50个请求，即QPS使50） = 100（每秒并发数） / 2 （每个请求的平均处理时间）</p>
<p>　　　　3. 这是一台机器的QPS，如有每秒并发数为1000，那么就需要20台这样的机器才扛得住:</p>
<p>　　<strong>例2：</strong></p>
<p>　　　　1. 每天200万PV，那么它的QPS = （2000000 * 0.8）/ （24<em>60</em>60*0.2）≈ 93</p>
<p>　　　　2. 假设按照上面那样一台机器的QPS是50，那么抗住每天200万PV的访问量需要2台这样的机器</p>
<h2 id="高并发各层级解决方案"><a href="#高并发各层级解决方案" class="headerlink" title="高并发各层级解决方案"></a>高并发各层级解决方案</h2><p><img src="https://img2020.cnblogs.com/blog/1394324/202006/1394324-20200615225707946-1280071087.png" srcset="/img/loading.gif" alt="img"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx的负载均衡</title>
    <url>/blog/2020/06/16/nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p><strong>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/573911/201905/573911-20190528112846156-21585619.png" srcset="/img/loading.gif" alt="img"></p>
<p>​    </p>
<h2 id="nginx负载均衡配置"><a href="#nginx负载均衡配置" class="headerlink" title="nginx负载均衡配置"></a>nginx负载均衡配置</h2><p>1、轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<p>upstream backserver {<br>    server 192.168.0.14;<br>    server 192.168.0.15;<br>}</p>
<p>2、权重 weight<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<p>upstream backserver {<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>}</p>
<p>3、ip_hash（ IP绑定）<br>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。<br>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<p>upstream backserver {<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>}</p>
<p>4、fair（第三方插件）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<p>upstream backserver {<br>    server server1;<br>    server server2;<br>    fair;<br>}</p>
<p>5、url_hash（第三方插件）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<p>upstream backserver {<br>    server squid1:3128;<br>    server squid2:3128;<br>    hash $request_uri;<br>    hash_method crc32;<br>}</p>
<pre><code class="shell">[root@linux-node4 ~]# yum -y install nginx
[root@linux-node4 ~]# vim /etc/nginx/nginx.conf
#### 修改nginx.conf 默认是轮训 ####

&#39;&#39;&#39;
# 1. upstream是自己写的，一定要放在server外面
upstream myservers {
    server 192.168.56.14:81;
    server 192.168.56.14:82;
}

# 2. server其实默认已经有一个，只需要修改location中配置，指定转发代理即可
server {
    location / {
       proxy_pass http://myservers;
    }
}
&#39;&#39;&#39;
[root@linux-node4 nginx]# systemctl start nginx</code></pre>
<h3 id="Keepalived高可用集群"><a href="#Keepalived高可用集群" class="headerlink" title="Keepalived高可用集群"></a>Keepalived高可用集群</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Keepalived软件起初是专门为LVS负载均衡软件设计的用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务的高可用解决方案软件。</p>
<h4 id="Keepalived高可用故障切换转移原理"><a href="#Keepalived高可用故障切换转移原理" class="headerlink" title="Keepalived高可用故障切换转移原理"></a>Keepalived高可用故障切换转移原理</h4><p>Keepalived高可用故障切换，是通过VRRP虚拟路由器冗余协议来实现的。</p>
<p>使用Keepalived有效提高了负载均衡的nginx的高可用性。</p>
<p><img src="C:%5CUsers%5Cchina%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1592279098289.png" srcset="/img/loading.gif" alt="1592279098289"></p>
]]></content>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/blog/2020/06/15/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><p>redis是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好Redis还为我们提供了持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>B-tree和B+tree</title>
    <url>/blog/2020/06/10/B-tree%E5%92%8CB+tree/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="平衡多路查找树（B-Tree）"><a href="#平衡多路查找树（B-Tree）" class="headerlink" title="平衡多路查找树（B-Tree）"></a>平衡多路查找树（B-Tree）</h1><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>一般每次从磁盘块里拿数据会是16kb</p>
<p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块，这将会减少磁盘I/O次数，提高查询效率。</p>
<h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>b-tree每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p><strong>B+Tree相对于B-Tree有几点不同：</strong></p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis哨兵</title>
    <url>/blog/2020/06/10/redis%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<h2 id="Redis-Sentinel（redis哨兵）"><a href="#Redis-Sentinel（redis哨兵）" class="headerlink" title="Redis Sentinel（redis哨兵）**"></a>Redis Sentinel（redis哨兵）**</h2><p>Redis的主从复制下，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，对于很多应用场景这种故障处理的方法是无法接受的。但是Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p>
<p><strong>三个定时监控任务</strong><br>1）每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。</p>
<p>2）每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。</p>
<p>3）每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p>
<p><strong>主观下线</strong><br>因为每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p>
<p><strong>客观下线</strong><br>当Sentinel主观下线的节点是主节点时，该Sentinel节点会向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，那么意味着大部分的Sentinel节点都对这个主节点的下线做了同意的判定，于是该Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</p>
<p><strong>领导者Sentinel节点选举</strong><br>Raft算法：假设s1(sentinel-1)最先完成客观下线，它会向其余Sentinel节点发送命令，请求成为领导者；收到命令的Sentinel节点如果没有同意过其他Sentinel节点的请求，那么就会同意s1的请求，否则拒绝；如果s1发现自己的票数已经大于等于某个值，那么它将成为领导者。</p>
<p><strong>故障转移</strong><br>1）领导者Sentinel节点在从节点列表中选出一个节点作为新的主节点</p>
<p>2）上一步的选取规则是与主节点复制相似度最高的从节点</p>
<p>3）领导者Sentinel节点让剩余的从节点成为新的主节点的从节点</p>
<p>4）Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis主从</title>
    <url>/blog/2020/06/10/redis%E4%B8%BB%E4%BB%8E0/</url>
    <content><![CDATA[<h4 id="redis主从同步"><a href="#redis主从同步" class="headerlink" title="redis主从同步"></a>redis主从同步</h4><p> Redis主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。</p>
<p>redis分为全量同步和增量同步</p>
<ul>
<li><p>全量同步</p>
<p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</p>
<ol>
<li>从服务器连接主服务器，发送SYNC命令；</li>
<li>主服务器接收到SYNC命名后，生成rdb文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>生成完成后，向所有从服务器发送快照文件；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ol>
</li>
<li><p>增量同步</p>
<p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </p>
<p>过程：</p>
<p>​    增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从</title>
    <url>/blog/2020/06/10/mysql%E4%B8%BB%E4%BB%8E/</url>
    <content><![CDATA[<h4 id="mysql的主从同步"><a href="#mysql的主从同步" class="headerlink" title="mysql的主从同步"></a>mysql的主从同步</h4><ol>
<li>将Mysql某一台主机数据复制到其它主机（slaves）上，并重新执行一遍来实现的。</li>
<li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</li>
<li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。</li>
<li>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。</li>
<li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。</li>
</ol>
<p>·binlog：**是二进制日志文件，用于记录mysql的数据更新或者潜在更新(比如DELETE语句执行删除而实际并没有符合条件的数据)</p>
<h4 id="mysql的主从复制原理："><a href="#mysql的主从复制原理：" class="headerlink" title="mysql的主从复制原理："></a>mysql的主从复制原理：</h4><p>主从的好处：</p>
<p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p>
<p>主服务器开一个线程</p>
<p>从服务器开两个线程</p>
<p>有两个日志</p>
<ol>
<li><p>master服务器将数据的改变都记录到二进制binlog日志中，只要master上的数据发生改变，则将其改变写入二进制日志；</p>
</li>
<li><p>salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件</p>
</li>
<li><p>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中</p>
</li>
<li><p>从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致</p>
</li>
<li><p>最后I/O Thread和SQL Thread将进入睡眠状态，等待下一次被唤醒.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的五大数据类型</title>
    <url>/blog/2020/06/09/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h1><p><a href="https://www.jianshu.com/p/28138a5371d0" target="_blank" rel="noopener">https://www.jianshu.com/p/28138a5371d0</a></p>
<p>1.String（字符串）</p>
<p>　　String是Redis最基本的类型，一个Key对应一个Value。</p>
<p>​        redis String的内部整体的存储结构就是一个大的hashmap，内部实现是数组实现hash，冲突通过挂链去实现，然后每个dictEntry就是一个key/value对象。</p>
<p>　　String类型是二进制安全的，意思是Redis的String可以包含任何数据，比如jpg图片或者序列化的对象。</p>
<p>　　String类型是Redis最基本的数据类型，一个Redis中字符串Value最多可以是512MB。</p>
<p>2.Hash（哈希，类似于Java中的Map）</p>
<p>​        redis的哈希对象的底层存储可以使用ziplist（压缩列表）和hashtable。当hash对象可以同时满足一下两个条件时，哈希对象使用ziplist编码。</p>
<p>　　Redis中Hash是一个键值对集合。</p>
<p>　　Redis Hash是一个String类型的field和value的映射表，Hash特别适合用于存储对象。</p>
<p>　　类似于Java里面的Map&lt;String,Object&gt;</p>
<p>3.List（列表）</p>
<p>　　Redis List是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>　　底层实现原理实际上是一个链表。</p>
<p>4.Set（集合）</p>
<p>　　Redis Set是String类型的无序集合，它是通过HashTable实现的。</p>
<ul>
<li><p>Set　　无序　　无重复</p>
<p>​        set的底层数据结构是hashtable</p>
</li>
</ul>
<p>　　　　ArrayList　　有序　　有重复</p>
<p>　　　　Hash　　散列　　无序　　无重复</p>
<p>5.Zset（Sorted Set：有序集合）</p>
<p>​        zset底层的存储结构包括ziplist或skiplist，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist</p>
<p>　　Redis Zset和Set一样也是String类型元素的集合，且不允许重复的元素。</p>
<p>　　不同的是，Zset每个元素都会关联一个Double类型的分数。</p>
<p>　　Redis正是通过分数来为集合中的元素进行从小到大的排序。</p>
<p>　　Zset的元素是唯一的，但分数（score）却可以重复。</p>
<p>转：<a href="https://www.cnblogs.com/fanqisoft/p/10418728.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/10418728.html</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>java的print，printf，println</title>
    <url>/blog/2020/06/05/java%E7%9A%84print%EF%BC%8Cprintf%EF%BC%8Cprintln/</url>
    <content><![CDATA[<p>printf主要是继承了C语言的printf的一些特性，可以进行格式化输出</p>
<p>print就是一般的标准输出，但是不换行</p>
<p>println和print基本没什么差别，就是最后会换行</p>
<p>System.out.printf(“the number is: d”,t);<br>参照JAVA API的定义如下：<br>‘d’ 整数结果被格式化为十进制整数<br>‘o’ 整数结果被格式化为八进制整数<br>‘x’, ‘X’ 整数结果被格式化为十六进制整数<br>‘e’, ‘E’ 浮点结果被格式化为用计算机科学记数法表示的十进制数<br>‘f’ 浮点结果被格式化为十进制数<br>‘g’, ‘G’ 浮点根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。<br>‘a’, ‘A’ 浮点结果被格式化为带有效位数和指数的十六进制浮点数</p>
<p>println(“test”)相当于print(“test\n”)就是一般的输出字符串</p>
<p>print\println\printf的区别</p>
<p>print将它的参数显示在命令窗口，并将输出光标定位在所显示的最后一个字符之后。</p>
<p>println 将它的参数显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。</p>
<p>printf是格式化输出的形式。</p>
<p>下在举个例子：</p>
<p>package other;</p>
<p>public class TestPrint {</p>
<p>public static voidmain(String[] args) {</p>
<p>int i = 4;</p>
<p>double j = 5;</p>
<p>System.out.print(“用print输出i:”+ i);</p>
<p>System.out.println( “用println输出i:”+ i);</p>
<p>System.out.printf(“i的值为%d,j的值为%f”, i,j);</p>
<p>}</p>
<p>}</p>
<p>运行结果为</p>
<p>用print输出i:4用println输出i:4</p>
<p>i的值为4,j的值为5.000000</p>
<p>可以看到，用print输出i后，没有换行，用println输出的结果直接在print输出语句后面,而输出println后换行了，所以用printf输出时，在第二行</p>
<p>输出。</p>
<p>我们再来看printf</p>
<p>“i的值为%d,j的值为%f”这个字符串中的”%d”变为i的值了，而”%f”变为了j的值了！</p>
<p>这里，”%d”的意思是一个int值的占位符，”%f”为一个double 或float值的点位符，这个变量的参数在后面提供。注意的是实参名必须按顺序排</p>
<p>。不然就会错了。而且类型也要相符。如果我们把语句改为</p>
<p>System.out.printf(“i的值为%d,j的值为%f”, j,i);//i和j位置反了</p>
<p>这时就有错了因为”%d”对应的参数变为j，”%f”对应的变为i了，而j是double的，与”%d”是int形的不一致。所以有错了。</p>
<p>还有”%s”是一个字符串值的点位符的意思。”%c”是一个字符值的点位符的意思。</p>
<p>可能读者还会问为什么j输出变成了5.000000?那是因为double是默认有6位小数的（这个可能和系统电脑有关，有的不是6位吧）但是如果你想</p>
<p>只要输出两位小数行不行？可以啊！只要改下语句就行了！</p>
<p>System.out.printf(“i的值为%d,j的值为%.2f”, i,j);</p>
<p>这里的”%.2f”的意思是输出两位小数点。如果想输出三位那就”%.3f”。</p>
<p>说到这里你会发现原来printf也很有用的。这样可以控制输出的格式。</p>
<p>再学多点知识吧，将代码改为以下：</p>
<p>public class TestPrint {</p>
<p>public static voidmain(String[] args) {</p>
<p>int i = 4;</p>
<p>double j = 5.000f;</p>
<p>System.out.printf(“i的值为],\n”, i);</p>
<p>System.out.printf(“i的值为=,j的值为%.2f”, i,j);</p>
<p>}</p>
<p>}</p>
<p>运行结果为：</p>
<p>i的值为 4,</p>
<p>i的值为 4,j的值为5.00</p>
<p>原来在”%”与”d”之间加个数5的意思是输出5个占位符。默认向右对齐。这样的输出是很有用的，比如你想输出一个表格，因各个数大小不一，有的5位有的4位，这样输出的的表格结果就对不齐了。如果将输出结果全部为同一样的占位符数。那样就对齐了。呵呵。</p>
<p>除了”%d”可以这样外，别的也可以，读者不防试试。会有很多收获的。</p>
<p>我们再试着将代码改一下：</p>
<p>public class TestPrint {</p>
<p>public static voidmain(String[] args) {</p>
<p>int i = 4;</p>
<p>double j = 5.000f;</p>
<p>System.out.printf(“i的值为d,\n”, i);</p>
<p>}</p>
<p>}</p>
<p>运行结果为：</p>
<p>i的值为00004,</p>
<p>哈哈,原来”d”的意思是输出5个占位符，如果数字不足5的话就有左边以0相补</p>
<blockquote>
<p>转载：<a href="https://blog.csdn.net/qq_33271612/article/details/50700122" target="_blank" rel="noopener">https://blog.csdn.net/qq_33271612/article/details/50700122</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的了解</title>
    <url>/blog/2020/06/05/Java%E5%A4%A7%E6%B3%95/</url>
    <content><![CDATA[<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>去官方下载JDK</p>
<p><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
<p>下载完，去找到安装位置的bin目录，</p>
<p>找到把bin目录的路径配置到环境变量</p>
<p>坑：</p>
<p>千万不要去<a href="https://www.java.com/zh_CN/点内个免费下载" target="_blank" rel="noopener">https://www.java.com/zh_CN/点内个免费下载</a></p>
<p>如果你点了，并安装了，然后你去下载了JDK，</p>
<p>当你运行java的时候会报个java和javac版本不一致的错，这时候就需要卸载了，</p>
<p>你根据第一种自接下载JDK就完啦！</p>
<pre><code class="java">public class HelloWorld {
    /* 第一个Java程序
     * 它将打印字符串 Hello World
     */
    public static void main(String []args) {
        System.out.println(&quot;Hello World&quot;); // 打印 Hello World
    }
}</code></pre>
<ol>
<li>把文件名保存为：HelloWorld.java</li>
<li>打开命令行，cd到对应的目录下</li>
<li>在命令行窗口输入 <strong>javac HelloWorld.java</strong>进行打包</li>
<li>在命令行窗口输入 <strong>java HelloWorld</strong>按下回车键就可以运行程序了</li>
</ol>
<p>注意：</p>
<ol>
<li>Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String []args)</strong> 方法开始执行</li>
</ol>
<pre><code class="java">public class helloword{
    public static void main(String[] args) {
        System.out.println(&quot;HelloWorld&quot;);
        for(int x = 10; x &lt; 20; x = x+1) {
            System.out.print(&quot;value of x : &quot; + x );
            System.out.print(&quot;\n&quot;);
         }
    }
}
</code></pre>
<p>简单for循环</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>初学GO</title>
    <url>/blog/2020/06/05/%E5%88%9D%E5%AD%A6GO/</url>
    <content><![CDATA[<h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><h4 id="安装Golang的SDK"><a href="#安装Golang的SDK" class="headerlink" title="安装Golang的SDK"></a>安装Golang的SDK</h4><p><a href="http://golang.org/" target="_blank" rel="noopener">http://golang.org</a>，下载最新的安装包，之后双击安装即可。</p>
<p>安装完成之后，打开终端，输入go、或者go version(查看安装版本)出现如下信息即表示安装成功：</p>
<p>$ go versiongo version go1.5.1darwin/amd64</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main(){
    a := 1
    if a&gt;0{
        fmt.Printf(&quot;a 的值为 : %d\n&quot;, a)
    }else
    {
        fmt.Println(a)
    }
    fmt.Println(a)
    count := 10
    for i := 0; i &lt; count; i++ {
        fmt.Printf(&quot;a 的值为 : %d\n&quot;, i)
        fmt.Println(&quot;a 的值为 : %d\n&quot;, i)
    }
}
</code></pre>
<p>用<strong>go run 文件名</strong>启动  ,要对应路径</p>
<p><strong>import “fmt”</strong> fmt这个包实现了格式化IO(输入/输出)的函数</p>
<p><strong>func main()</strong> 是本次程序执行的函数</p>
<p>还有func int()如果项目中有这个，就优先执行这个</p>
<p>上面代码可以看出输出的方式有两种</p>
<p>​        fmt.Printf(“a 的值为 : %d\n”, i)<br>​        fmt.Println(“a 的值为 : %d\n”, i)</p>
<p>自己可以去看一下输出结果，哪里不同</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>E-charts使用</title>
    <url>/blog/2020/06/02/E-charts%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>其他表形式参考官方文档,此博客展示的为最简单的折线图<br><a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">https://echarts.apache.org/examples/zh/index.html</a></p>
<p>安装依赖<br><code>npm install echarts</code></p>
<p>在main中导入</p>
<p>Js</p>
<pre><code>import Echarts from &#39;echarts&#39;
Vue.prototype.echarts = Echarts;
Vue.use(Echarts);</code></pre><p>页面布局<br><code>&lt;div id=&quot;echarts&quot; :style=&quot;{width: &#39;300px&#39;, height: &#39;300px&#39;}&quot;&gt;&lt;/div&gt;</code></p>
<p>JavaScript层</p>
<pre><code>    e_chart: function () {
    var dom = document.getElementById(&#39;echarts&#39;);
    var myChart = this.echarts.init(dom);
    // 绘制图表

    myChart.setOption({
        xAxis: {
            type: &#39;category&#39;,  // category 为折线图
            data: this.datechart  // [&#39;5-28&#39;,&#39;5-29&#39;]
        },
        yAxis: {
            type: &#39;value&#39;
        },
        series: [{
            data: this.tempchart,  // [10,20,30]
            type: &#39;line&#39;
        }]
    })
}</code></pre>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Contos安装mysql</title>
    <url>/blog/2020/06/02/contos%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h4 id="查看Centos安装mysql软件"><a href="#查看Centos安装mysql软件" class="headerlink" title="查看Centos安装mysql软件"></a>查看Centos安装mysql软件</h4><pre><code>rpm -qa|grep -i mysql</code></pre><h4 id="卸载已经安装过的软件"><a href="#卸载已经安装过的软件" class="headerlink" title="卸载已经安装过的软件"></a>卸载已经安装过的软件</h4><pre><code>yum remove &#39;软件名</code></pre><h4 id="Centos-7-的yum源中默认是没有mysql的。所以，为了解决这个问题我们首先下载安装mysql的repo"><a href="#Centos-7-的yum源中默认是没有mysql的。所以，为了解决这个问题我们首先下载安装mysql的repo" class="headerlink" title="Centos 7 的yum源中默认是没有mysql的。所以，为了解决这个问题我们首先下载安装mysql的repo"></a>Centos 7 的yum源中默认是没有mysql的。所以，为了解决这个问题我们首先下载安装mysql的repo</h4><pre><code>wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</code></pre><h4 id="安装mysql的repo源"><a href="#安装mysql的repo源" class="headerlink" title="安装mysql的repo源"></a>安装mysql的repo源</h4><pre><code>rpm -ivh mysql57-community-release-el7-7.noarch.rpm</code></pre><ul>
<li>安装之后会获得/etc/yum.repos.d/mysql-community.repo和/etc/yum.repos.d/mysql-community-source.repo两个源，可以去相应的路径下查看一下</li>
</ul>
<h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><pre><code>yum install mysql-server`
`yum install mysql-devel`
`yum install mysql`
`rpm -qa | grep -i mysql</code></pre><h4 id="服务开关操作"><a href="#服务开关操作" class="headerlink" title="服务开关操作"></a>服务开关操作</h4><pre><code>service mysqld status`查看mysql当前的状态
`systemctl status mysqld`
`service mysqld stop`停止mysql
`systemctl stop mysqld`
`service mysqld restart`重启mysql
`systemctl restart mysqld`
`service mysqld start` 重启mysql
`systemctl start mysqld</code></pre><h4 id="设置MySQL开机启动"><a href="#设置MySQL开机启动" class="headerlink" title="设置MySQL开机启动"></a>设置MySQL开机启动</h4><pre><code>systemctl enable mysqld</code></pre><h4 id="启动MySQL服务进程"><a href="#启动MySQL服务进程" class="headerlink" title="启动MySQL服务进程"></a>启动MySQL服务进程</h4><pre><code>systemctl start mysqld` or `service mysqld start</code></pre><h4 id="安装完成后登陆的问题"><a href="#安装完成后登陆的问题" class="headerlink" title="安装完成后登陆的问题"></a>安装完成后登陆的问题</h4><p>安装完成后用命令 mysql -u root -p 然后 Enter Password，但是无法登录。解决办法如下:</p>
<ul>
<li>在/etc/my.cnf文件中最后添加一行 skip-grant-tables 作用就是跳过了mysql的用户验证，然后重启mysql : <strong>systemctl restart mysqld</strong><br>然后直接输入mysql，不需要带任何登录参数直接回车就可以登陆上数据库;<br>进入数据库之后执行下面的命令：</li>
</ul>
<p>  Code</p>
<pre><code>  mysql&gt; use mysql;mysql&gt; show tables;select user,authentication_string from user;update mysql.user set authentication_string=password(&#39;your password&#39;) where user=&#39;root&#39;;flush privileges;exit</code></pre><ul>
<li>恢复/etc/my.cnf文件，将skip-grant-tables删除或者注释掉，然后重启mysql : systemctl restart mysqld</li>
</ul>
<h4 id="登陆错误"><a href="#登陆错误" class="headerlink" title="登陆错误"></a>登陆错误</h4><ul>
<li>下面顺便讲解一下这个问题：安装完mysql 之后登陆，不管运行任何命令，总是提示这个错误：<br><code>You must reset your password using ALTER USER statement before executing this statement</code></li>
<li>处理步骤为：依次执行下面三条代码。<br><code>SET PASSWORD = PASSWORD(&#39;your new password&#39;);</code><br><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;</code><br><code>flush privileges;</code></li>
<li>这里要注意的是your new password 必须包含数字，字母包含大小写，标点符号。不然好像是不能通过的。</li>
</ul>
<h4 id="远程客户端无法连接MySQL数据库"><a href="#远程客户端无法连接MySQL数据库" class="headerlink" title="远程客户端无法连接MySQL数据库"></a>远程客户端无法连接MySQL数据库</h4><h5 id="创建新的安全组规则，对外开放3306端口访问授权（阿里云的服务器，默认只需要在管理后端开启3306就可以了，下面操作防火墙的步骤可以免掉）"><a href="#创建新的安全组规则，对外开放3306端口访问授权（阿里云的服务器，默认只需要在管理后端开启3306就可以了，下面操作防火墙的步骤可以免掉）" class="headerlink" title="创建新的安全组规则，对外开放3306端口访问授权（阿里云的服务器，默认只需要在管理后端开启3306就可以了，下面操作防火墙的步骤可以免掉）"></a>创建新的安全组规则，对外开放3306端口访问授权（阿里云的服务器，默认只需要在管理后端开启3306就可以了，下面操作防火墙的步骤可以免掉）</h5><pre><code>firewall-cmd --permanent --zone=public --add-port=3306/tcp #添加端口，加完要重启防火墙`
`firewall-cmd --permanent --zone=public --remove-port=3306/tcp #删除端口，加完要重启防火墙</code></pre><ul>
<li><p>说明</p>
</li>
<li><p>–zone #作用域</p>
</li>
<li><p>–add-port=3306/tcp #添加端口，格式为：端口/通讯协议</p>
</li>
<li><p>–permanent 永久生效，没有此参数重启后失效<br>查看端口状态 netstat -an | grep 3306<br>查看已开启的端口,重启防火墙后有效</p>
<p><code>firewall-cmd --list-ports</code><br><code>systemctl restart firewalld</code> 重启防火墙<br><code>systemctl status firewalld</code> 查看防火墙状态<br><code>systemctl stop firewalld</code> 关闭防火墙</p>
</li>
</ul>
<h5 id="在本机登入mysql后-更改-“mysql”-数据库里的-“user”-表里的-“host”-项-从”localhost”改称’-’"><a href="#在本机登入mysql后-更改-“mysql”-数据库里的-“user”-表里的-“host”-项-从”localhost”改称’-’" class="headerlink" title="在本机登入mysql后,更改 “mysql” 数据库里的 “user” 表里的 “host” 项,从”localhost”改称’%’"></a>在本机登入mysql后,更改 “mysql” 数据库里的 “user” 表里的 “host” 项,从”localhost”改称’%’</h5><pre><code>mysql -u root -p`
`mysql&gt;use mysql;`
`mysql&gt;select host,user from user;`
`mysql&gt;update user set host = &#39;%&#39; where user =&#39;root&#39;;`
`mysql&gt;flush privileges;`
`mysql&gt;select host,user from user;</code></pre><p>第一句是以权限用户root登录<br>第二句:选择mysql库<br>第三句:查看mysql库中的user表的host值(即可进行连接访问的主机/IP名称)<br>第四句:修改host值(以通配符%的内容增加主机/IP地址),当然也可以直接增加IP地址<br>第五句:刷新MySQL的系统权限相关表<br>第六句:再重新查看user表时,有修改<br>重起mysql服务即可完成。service mysqld restart。</p>
<blockquote>
<p>转载：<a href="https://baizixuan.gitee.io/my_technology_blog_hexo/2020/05/30/Centos安装Mysql/" target="_blank" rel="noopener">https://baizixuan.gitee.io/my_technology_blog_hexo/2020/05/30/Centos%E5%AE%89%E8%A3%85Mysql/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket理论</title>
    <url>/blog/2020/06/02/websocket%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<hr>
<p>title : “websocket理论”<br>categories: 其他<br>tags: 其他</p>
<hr>
<h4 id="什么是websocket，用于解决什么情景？"><a href="#什么是websocket，用于解决什么情景？" class="headerlink" title="什么是websocket，用于解决什么情景？"></a>什么是websocket，用于解决什么情景？</h4><ul>
<li><p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://baike.baidu.com/item/全双工" target="_blank" rel="noopener">全双工</a>通信的协议。</p>
</li>
<li><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。（优势）</p>
</li>
<li><p>引用场景</p>
<ul>
<li><strong>社交订阅</strong></li>
<li><strong>多玩家游戏</strong></li>
<li><strong>股票基金报价</strong></li>
<li><strong>体育实况更新</strong></li>
<li><strong>多媒体聊天</strong></li>
<li><strong>在线教育</strong></li>
<li><strong>基于位置的应用</strong></li>
</ul>
<p><strong>（实时性）</strong></p>
</li>
</ul>
<h4 id="实时性问题使用http来解决"><a href="#实时性问题使用http来解决" class="headerlink" title="实时性问题使用http来解决"></a>实时性问题使用http来解决</h4><ul>
<li>轮询</li>
<li>长轮询</li>
</ul>
<h4 id="django如何实现websocket"><a href="#django如何实现websocket" class="headerlink" title="django如何实现websocket"></a>django如何实现websocket</h4><p>channels</p>
<p>Django的函数：</p>
<ol>
<li>connect（# 当Websocket创建连接时）</li>
<li>receive（# 当Websocket接收到消息时）</li>
<li>disconnect（# 当Websocket发生断开连接时）</li>
</ol>
<p>优势</p>
<p>channels不仅支持websocket还有其他功能，而且文档丰富，</p>
<p>使用起来性能更优，更稳定</p>
<p>劣势</p>
<p>配置麻烦，而且如果你要部署要使用dephne来跑项目</p>
<p>django-websocket</p>
<p>优势</p>
<p>配置方便，拿来即用，开发快速，</p>
<p>适用于小型项目</p>
<p>劣势</p>
<p>性能和稳定性不强</p>
<h4 id="vue如何实现websocket"><a href="#vue如何实现websocket" class="headerlink" title="vue如何实现websocket"></a>vue如何实现websocket</h4><p>​        new WebSocket</p>
<p>Vue的两个方法</p>
<ol>
<li><code>send  发送信息</code></li>
<li>close 关闭连接</li>
</ol>
<p>Vue的函数</p>
<ol>
<li>onopen     定义打开时的函数</li>
<li>onclose    定义关闭时的函数</li>
<li>onmessage  定义接收数据时候的函数</li>
</ol>
<h4 id="点对点如何通行？"><a href="#点对点如何通行？" class="headerlink" title="点对点如何通行？"></a>点对点如何通行？</h4><ul>
<li><p>点对点：</p>
<p>点对点发送就需要明确三条数据1.谁发的数据，2.数据要发给谁，3.发送的数据是什么</p>
<p>知道这3点后，输入你要发给谁，和你发送的数据给后端，然后后端发送给指定的连接</p>
</li>
</ul>
<h4 id="群发如何实现？"><a href="#群发如何实现？" class="headerlink" title="群发如何实现？"></a>群发如何实现？</h4><ul>
<li><p>群发：</p>
<p>群发就是把每一个socket连接放到一个列表里，当有一个连接发送数据时，</p>
<p>利用for循环吧这条数据转发给每一个socket连接。</p>
</li>
</ul>
<p>代码和配置流程：</p>
]]></content>
  </entry>
  <entry>
    <title>Python的递归</title>
    <url>/blog/2020/06/02/python%E7%9A%84%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h4 id="递归的概念，优势，劣势，递归深度问题？"><a href="#递归的概念，优势，劣势，递归深度问题？" class="headerlink" title="递归的概念，优势，劣势，递归深度问题？"></a>递归的概念，优势，劣势，递归深度问题？</h4><ul>
<li><p>递归算法就是一种直接或者间接的调用自身函数或者方法的算法</p>
</li>
<li><p>优点</p>
<ul>
<li>实现简单</li>
<li>可读性好</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>递归调用，占用空间大</li>
<li>递归太深，容易发生栈溢出</li>
<li>可能存在重复计算</li>
</ul>
</li>
<li><p><strong>递归的三大要素</strong></p>
<ol>
<li>明确函数要做什么</li>
<li>寻找递归结束条件</li>
<li>找出函数的等价关系式</li>
</ol>
</li>
<li><p>解决最大递归深度</p>
<pre><code class="python">import sys

sys.setrecursionlimit(3000)</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图片传到本地</title>
    <url>/blog/2020/06/01/%E6%96%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="首先-跨域-啊-还有-rest-framework-序列化啊-都配置好"><a href="#首先-跨域-啊-还有-rest-framework-序列化啊-都配置好" class="headerlink" title="首先   跨域  啊  还有   rest_framework 序列化啊  都配置好"></a>首先   跨域  啊  还有   rest_framework 序列化啊  都配置好</h3><p><strong>settings.py</strong></p>
<pre><code>
STATIC_URL = &#39;/static/&#39;


STATICFILES_DIRS=[
     os.path.join(BASE_DIR,&#39;static&#39;)
]

#定义上传文件夹的路径
UPLOAD_ROOT = os.path.join(BASE_DIR,&#39;static/upload&#39;)</code></pre><p>这三个应该都有配置 </p>
<p>要是没有就去settings.py  在最后面加上</p>
<p><strong>models.py</strong></p>
<p>然后 models 的image字段 </p>
<pre><code>image = models.FileField(upload_to=&quot;static/upload/&quot;)</code></pre><p>upload_to  可以指定存储的位置</p>
<p>别的方法也不会     嘻嘻嘻！！</p>
<p><strong>urls.py</strong></p>
<pre><code>re_path(&#39;^static/upload/(?P&lt;path&gt;.*)$&#39;, serve, {&#39;document_root&#39;: &#39;/static/upload/&#39;}),</code></pre><p>这行是能让你通过URl访问  例如   <a href="http://127.0.0.1:8000/static/upload/5.jpg" target="_blank" rel="noopener">http://127.0.0.1:8000/static/upload/5.jpg</a></p>
<p>Django应该就完啦</p>
<p>可以反序列化添加</p>
<p>一下是VUE端的代码</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
        name&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
        图 &lt;input type=&quot;file&quot; id=&quot;image&quot;&gt;

        &lt;input @click=&quot;addcomputer()&quot; type=&quot;submit&quot; value=&quot;添加&quot;&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data(){
        return {
            name:&quot;&quot;,
        }
    },
    methods: {
          addcomputer(){
            var form_data=new FormData
            form_data.append(&#39;name&#39;,this.name)
            form_data.append(&#39;image&#39;,document.getElementById(&#39;image&#39;).files[0])
            this.axios({
              url:&#39;http://127.0.0.1:8000/addcate/&#39;,
              method:&#39;post&#39;,
              data:form_data,
              headers:{
                &#39;Content-Type&#39;:&quot;multipart/form-data&quot;
              }
            }).then(res=&gt;{
              if(res.data.code==200){
                alert(&#39;添加成功&#39;)
              }
            })
          }
    },
}

&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;</code></pre>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密和非对称加密</title>
    <url>/blog/2020/06/01/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="一-非对称加密"><a href="#一-非对称加密" class="headerlink" title="一  非对称加密"></a><strong>一  非对称加密</strong></h2><p>　　非对称加密和解密花费的时间长</p>
<p>非对称加密算法需要两个密钥：<a href="https://baike.baidu.com/item/公开密钥/7453570" target="_blank" rel="noopener">公开密钥</a>（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。（RSA，RSA2）需要<code>N*(N-1)/2</code>个密钥，因此每个人需要         管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<h2 id="二-对称加密"><a href="#二-对称加密" class="headerlink" title="二  对称加密"></a><strong>二  对称加密</strong></h2><p>　　算法公开、计算量小、加密速度快、加密效率高,加密和解密使用相同的密钥加密</p>
<p>　   对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。</p>
<p>​      常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES</p>
<p>对称加密分为可逆加密和不可逆加密。</p>
<p>可逆加密：</p>
<p>​    是如果你对一个数据进行加密，得到一个加密后的字符串，可逆加密是可以用相对应的方式或方法把加密后的字符串，解密成原数据的，</p>
<p>不可逆加密：</p>
<p>​    不可逆加密，就不可能吧加密后的数据，解密成原数据。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>oauth2.0是什么？</title>
    <url>/blog/2020/06/01/oauth2.0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>oauth2.0是什么？</p>
<p>​    OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p>
<p>OAuth 2.0是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p>
<p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用</p>
<p>oauth2.0是不兼容oauth1.0的</p>
<p><strong>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</strong></p>
<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>
<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>
<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>
<h4 id="Oauth2-0的四种授权模式？"><a href="#Oauth2-0的四种授权模式？" class="headerlink" title="Oauth2.0的四种授权模式？"></a>Oauth2.0的四种授权模式？</h4><ul>
<li><h6 id="隐式授权模式（Implicit-Grant）"><a href="#隐式授权模式（Implicit-Grant）" class="headerlink" title="隐式授权模式（Implicit Grant）"></a>隐式授权模式（Implicit Grant）</h6></li>
<li><h6 id="授权码授权模式（Authorization-code-Grant）"><a href="#授权码授权模式（Authorization-code-Grant）" class="headerlink" title="授权码授权模式（Authorization code Grant）"></a>授权码授权模式（Authorization code Grant）</h6></li>
<li><h6 id="密码模式（Resource-Owner-Password-Credentials-Grant）"><a href="#密码模式（Resource-Owner-Password-Credentials-Grant）" class="headerlink" title="密码模式（Resource Owner Password Credentials Grant）"></a>密码模式（Resource Owner Password Credentials Grant）</h6></li>
<li><h6 id="客户端凭证模式（Client-Credentials-Grant）"><a href="#客户端凭证模式（Client-Credentials-Grant）" class="headerlink" title="客户端凭证模式（Client Credentials Grant）"></a>客户端凭证模式（Client Credentials Grant）</h6></li>
</ul>
<h4 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h4><p>​    <a href="https://www.cnblogs.com/Innocent-of-Dabber/p/11009811.html" target="_blank" rel="noopener">https://www.cnblogs.com/Innocent-of-Dabber/p/11009811.html</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是单点登陆？</title>
    <url>/blog/2020/06/01/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>什么是单点登陆？</p>
<p>​        单点登录（Single Sign On），简称为 SSO。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<h4 id="单点登陆如何解决"><a href="#单点登陆如何解决" class="headerlink" title="单点登陆如何解决"></a>单点登陆如何解决</h4><ol>
<li>redis作为缓存储存session信息（cookie/session）</li>
<li>JWT来解决单点登陆</li>
</ol>
<h4 id="基于cookie和session的单点登陆解决"><a href="#基于cookie和session的单点登陆解决" class="headerlink" title="基于cookie和session的单点登陆解决"></a>基于cookie和session的单点登陆解决</h4><p>​        redis存储所有session_id。每次做session验证不再从本机对比session，而是将session放在redis里统一管理。无论那台服务器上存储的session都放在redis中。那么在判断的时候都以redis里的数据为准，即可解决单点登陆问题</p>
<h4 id="基于JWT的单点登陆解决（计算）"><a href="#基于JWT的单点登陆解决（计算）" class="headerlink" title="基于JWT的单点登陆解决（计算）"></a>基于JWT的单点登陆解决（计算）</h4><p>  用户登录后，利用JWT秘钥生成token，并返回，存储localStorage：，在每次请求的时候，检验身份信息，如果一致，返回结果，不一致，登录。</p>
<ul>
<li>什么是JWT<ul>
<li>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准</li>
</ul>
</li>
<li><strong>JWT组成</strong><ul>
<li>头部（header)</li>
<li>载荷（payload）</li>
<li>签证（signature)</li>
</ul>
</li>
<li>JWT在django中如何使用<ul>
<li>djangorestframework-jwt的配置+django自带的验证系统</li>
</ul>
</li>
<li>JWT优势<ul>
<li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</li>
<li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>
<li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息, 所以它易于应用的扩展</li>
</ul>
</li>
<li>JWT和劣势<ul>
<li>保护好secret私钥，该私钥非常重要。</li>
<li>一旦token泄露，在有效期内任何人都可以使用该token进入系统，且不可撤回</li>
</ul>
</li>
<li>JWT安全要求<ul>
<li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>如果可以，请使用https协议（<strong>https和http的区别</strong>）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>时间，空间复杂度</title>
    <url>/blog/2020/05/30/%E6%97%B6%E9%97%B4%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度是一个函数，它定量描述了该算法的运行时间，时间复杂度常用“O”表述，使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况</p>
<p>时间复杂度是用来估计算法运行时间的一个式子（单位），一般来说，时间复杂度高的算法比复杂度低的算法慢</p>
<pre><code class="python">print(&#39;Hello world&#39;)  # O(1)


# O(1)
print(&#39;Hello World&#39;)
print(&#39;Hello Python&#39;)
print(&#39;Hello Algorithm&#39;)


for i in range(n):  # O(n)
    print(&#39;Hello world&#39;)


for i in range(n):  # O(n^2)
    for j in range(n):
        print(&#39;Hello world&#39;)


for i in range(n):  # O(n^2)
    print(&#39;Hello World&#39;)
    for j in range(n):
        print(&#39;Hello World&#39;)


for i in range(n):  # O(n^2)
    for j in range(i):
        print(&#39;Hello World&#39;)


for i in range(n):
    for j in range(n):
        for k in range(n):
            print(&#39;Hello World&#39;)  # O(n^3)</code></pre>
<p> 几次循环就是n的几次方的时间复杂度</p>
<pre><code class="python">n = 64
while n &gt; 1:
    print(n)
    n = n // 2</code></pre>
<p> 26 = 64，log264 = 6，所以循环减半的时间复杂度为O(log2n)，即O(logn)</p>
<p>如果是循环减半的过程，时间复杂度为O(logn)或O(log2n)</p>
<p>常见的时间复杂度高低排序：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n2logn)&lt;O(n3)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度：用来评估算法内存占用大小的一个式子</p>
<pre><code class="python">a = &#39;Python&#39;  # 空间复杂度为1


# 空间复杂度为1
a = &#39;Python&#39;
b = &#39;PHP&#39;
c = &#39;Java&#39;


num = [1, 2, 3, 4, 5]  # 空间复杂度为5


num = [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]  # 空间复杂度为5*4


num = [[[1, 2], [1, 2]], [[1, 2], [1, 2]] , [[1, 2], [1, 2]]]  # 空间复杂度为3*2*2</code></pre>
<p> 定义一个或多个变量，空间复杂度都是为1，列表的空间复杂度为列表的长度</p>
<p>转载：<a href="https://www.cnblogs.com/palace/p/9598309.html" target="_blank" rel="noopener">https://www.cnblogs.com/palace/p/9598309.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶函数,RE</title>
    <url>/blog/2020/05/30/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%8CRE/</url>
    <content><![CDATA[<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>map()</p>
<p>map函数接收的是两个参数，一个函数，一个序列，其功能是将序列中的值处理再依次返回至列表内。其返回值为一个迭代器对象-</p>
<pre><code>def add2num(a,b):
    return a+b

ret = map(add2num,[1,2,3,4,5],[11,22,33,44,55])
print(ret)
print(list(ret))
</code></pre><p>filter()</p>
<p>filter函数也是接收一个函数和一个序列的高阶函数，其主要功能是过滤。其返回值也是迭代器对象</p>
<pre><code>#filter函数
def func(n):
    return n%2==0

ret = filter(func,[i for i in range(1,21)])
print(ret)
print(list(ret))</code></pre><p>reduce()</p>
<p>　reduce函数也是一个参数为函数，一个为可迭代对象的高阶函数，其返回值为一个值而不是迭代器对象，故其常用与叠加、叠乘等</p>
<pre><code># reduce函数
from functools import reduce
def add2num(a,b):
    return a+b
ret = reduce(add2num,[1,2,3,4,5])
print(ret)</code></pre><p>sorted()</p>
<p>排序</p>
<pre><code>a_list = [1,2,3,4,5115,6,-66666666666]
ret = sorted(a_list)         
print(ret)
##[-66666666666, 1, 2, 3, 4, 6, 5115]
ret = sorted(a_list,key=abs)#    按绝对值排序
print(ret)
##[1, 2, 3, 4, 6, 5115, -66666666666]</code></pre><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><pre><code>import re
.可以匹配任意1个字符（除了/n）
[  ]  匹配[]中列举的字符，只匹配任意一个字符
 \d 只匹配数字  ， 即0--9 ， 一个\d只能匹配一个数字
 \D 匹配非数字，既不是数字
 ^ 匹配字符串开头
 $  匹配字符串结尾
 ？ 匹配前一个字符出现1次或者0次，即要么有1次，要么没有  ？ 非贪婪  + * 贪婪匹配</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理，GIL</title>
    <url>/blog/2020/05/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8CGIL/</url>
    <content><![CDATA[<h4 id="python的内存管理"><a href="#python的内存管理" class="headerlink" title="python的内存管理"></a>python的内存管理</h4><p>垃圾回收</p>
<p><strong>1.</strong> <strong>引用计数</strong></p>
<p>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</p>
<p>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</p>
<p><strong>2.标记－清除</strong></p>
<p>它分为两个阶段：</p>
<p>第一阶段是标记阶段，GC会把所有的活动对象打上标记，</p>
<p>第二阶段是把那些没有标记的对象非活动对象进行回收。</p>
<p><strong>3.</strong> <strong>分代回收</strong></p>
<p> Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</p>
<p>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</p>
<p>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</p>
<p>所有的新建对象都是0代对象；</p>
<p>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p>
<p> 一般老年代是存活最久的</p>
<h4 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h4><p>在一个进程内，同一时刻只能有一个线程执行</p>
<p>为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL</p>
<p>理解：</p>
<p>在一个线程内，同一时间只能有一个线程对数据进行访问，如果其他线程想进行访问，就只能等待，</p>
<p>这样保护了数据的安全性，只能并发不能并行,效率不高。</p>
<p><strong>同步锁</strong></p>
<p>　　1、什么是同步锁？</p>
<p>　　　　同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。</p>
<p>　　2、为什么用同步锁？</p>
<p>　　　　因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程　　序结果的完整性。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>上下文，with open</title>
    <url>/blog/2020/05/30/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>上下文管理(with)</p>
<p>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。with通过enter方法初始化，然后在exit中做善后以及处理异常。所以使用with处理的对象必须有<strong>enter</strong>()和<strong>exit</strong>()这两个方法。其中<strong>enter</strong>()方法在语句体（with语句包裹起来的代码块）执行之前进入运行，exit()方法在语句体执行完毕退出后运行。 with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<p>with的使用场景 如果某项工作完成后需要有释放资源或者其他清理工作，比如说文件操作时，就可以使用with优雅的处理，不用自己手动关闭文件句柄，而且with还能很好的管理上下文异常。</p>
<pre><code>with open(&#39;a.py&#39;) as fp:
      for line in fp:
            print(line,end=&quot; &quot;)</code></pre><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>打开一个文件来读数据，这是默认模式；</p>
<pre><code>with open(&#39;a.py&#39;,&#39;r&#39;) as fp:
      for line in fp:
            print(line,end=&quot; &quot;)</code></pre><p>打开一个文件来写数据，如果文件已有数据，则会先清空数据；</p>
<pre><code>with open(&#39;a.py&#39;,&#39;w&#39;) as fp:
      for line in fp:
            print(line,end=&quot; &quot;)</code></pre><p>打开一个文件向文件末尾追加数据；</p>
<pre><code>with open(&#39;a.py&#39;,&#39;a&#39;) as fp:
      for line in fp:
            print(line,end=&quot; &quot;)</code></pre><p>打开一个新文件来写数据，如果文件已存在则失败；</p>
<pre><code>with open(&#39;a.py&#39;,&#39;x&#39;) as fp:
      for line in fp:
            print(line,end=&quot; &quot;)</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深，浅拷贝</title>
    <url>/blog/2020/05/30/%E6%B7%B1%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.</p>
<pre><code>a = [1,2,3]</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p>
<pre><code>import copy
b=copy.deepcopy(a)</code></pre><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数copy()执行浅拷贝</p>
<pre><code>b=copy.copy(a)</code></pre><p>浅拷贝的情况一</p>
<p>在这里浅拷贝如果拷贝的不可变类型，改变会互相影响</p>
<p>举个栗子</p>
<pre><code class="python">import copy
a = (1, 2, [3, 4])
b = copy.copy(a)
print(b)
b[2].append(5)
b = &#39;&#39;
print(a)
print(b)</code></pre>
<p>浅拷贝的情况二</p>
<p>如果拷贝的是可变对象，改变不会互相影响，但是会开辟一个新的内存空间</p>
<pre><code class="python">import copy
a = [1, 2, 3]
b = copy.copy(a)
print(id(a))
print(id(b))</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python三器</title>
    <url>/blog/2020/05/29/Python%E4%B8%89%E5%99%A8/</url>
    <content><![CDATA[<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器的定义</p>
<ol>
<li><p>迭代器是访问集合内元素的方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束</p>
</li>
<li><p>迭代器仅是一容器对象，它有两个基本方法</p>
</li>
</ol>
<p>next方法：返回容器的下一个元素</p>
<p><strong>iter</strong>方法：返回迭代器自身</p>
<p>使用迭代器的斐波那契</p>
<pre><code class="python">class fei(object):
    def __init__(self,n):
        self.num1 = 0
        self.num2 = 1
        self.n = n
        self.indexes = 0
    def __iter__(self):
        return self

    def __next__(self):
        if self.n &gt; self.indexes:
            num = self.num1
            self.num1,self.num2 = self.num2,self.num1+self.num2
            self.indexes+=1
            return num
        else:
            raise StopIteration
if __name__ == &#39;__main__&#39;:
    f = fei(10)
    print(list(f))</code></pre>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器的定义</p>
<p>生成器可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他数据类型需要调用自己的内置iter方法）</p>
<p>在Python中，一边循环，一边计算的机制，称为生成器。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>使用生成器简单实现斐波那契</p>
<pre><code class="python">def fei(n):
    num1,num2 = 0,1
    indexes = 0
    while n &gt; indexes:
        num = num1
        num1,num2 = num2,num1+num2
        indexes += 1
        yield num

print(list(fei(10)))
print(fei(10))</code></pre>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>装饰器的定义</p>
<p>python装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象（函数的指针）</p>
<p>在大多的WEb框架里都有应用</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/UDP协议</title>
    <url>/blog/2020/05/29/TCP-UDP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP-和-UDP-有哪些区别？"><a href="#TCP-和-UDP-有哪些区别？" class="headerlink" title="TCP 和 UDP 有哪些区别？"></a>TCP 和 UDP 有哪些区别？</h1><p>1.TCP 是面向连接的，UDP 是面向无连接的。</p>
<p>2.什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP协议是一种可靠的、一对一的、面向有连接的通信协议</p>
<p>在使用TCP协议进行数据传输时，往往需要客户端和服务端先建立一个“通道“、且这个通道只能够被客户端和服务端使用，所以TCP传输协议只能面向一对一的连接</p>
<p>客户端与服务端在使用TCP传输协议时要先建立一个“通道”，在传输完毕之后又要关闭这“通道”，前者可以被形象地成为“三次握手”，而后者则可以被称为“四次挥手”。</p>
<p>通道的建立——三次握手：</p>
<p>（1）在建立通道时，客户端首先要向服务端发送一个SYN同步信号。</p>
<p>（2）服务端在接收到这个信号之后会向客户端发出SYN同步信号和ACK确认信号。</p>
<p>（3）当服务端的ACK和SYN到达客户端后，客户端与服务端之间的这个“通道”就会被建立起来。</p>
<p>简单来说就是</p>
<pre><code>1. 客户端对服务端说：“我想给你发数据，可以吗？”   这是第一次握手     
 2. 服务端收到后问客户端：“可以，你什么时候发？”，这是第二次对话
 3. 然后客户端对服务端说：“我现在就发，你接着吧！“  这样连接通道就建立了</code></pre><p>通道的关闭——四次挥手：</p>
<p>（1）在数据传输完毕之后，客户端会向服务端发出一个FIN终止信号。</p>
<p>（2）服务端在收到这个信号之后会向客户端发出一个ACK确认信号。</p>
<p>（3）如果服务端此后也没有数据发给客户端时服务端会向客户端发送一个FIN终止信号。</p>
<p>（4）客户端在收到这个信号之后会回复一个确认信号，在服务端接收到这个信号之后，服务端与客户端的通道也就关闭了。</p>
<p>1  客户端提出停止TCP连接的请求 。</p>
<p>2 服务端收到停止连接后，确认</p>
<p>3 然后服务端不服，为什么你说连接就连接，你说断开就断开，服务端就向客户端发发送关闭请求</p>
<p>4 客户端收到请求，双方断开连接。</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP是一个无连接的传输协议</p>
<p>当UDP发生数据时，就简单的拿到数据，并发送到网络，不考虑目标是否收到</p>
<p>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。</p>
<p>UDP的优点是发送数据很快</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇无限极评论</title>
    <url>/blog/2020/05/29/%E6%97%A0%E9%99%90%E6%9E%81%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="这是一篇无限极评论"><a href="#这是一篇无限极评论" class="headerlink" title="这是一篇无限极评论"></a>这是一篇无限极评论</h3><hr>
<p>将数据库查询的数据转换成以下的样式，必须是自关联关系</p>
<p><code>[{},{},{},{},{}]</code>,从数据库中取出的数据<br><code>[{&quot;child&quot;:{&quot;child&quot;:[{},{} ]}},{id:5,child:[{child:[{}],{}]}]</code>，转换之后的样式</p>
<p>在Django中处理好数据</p>
<pre><code>  def change_comments(data):
  list = []
  tree = {}
  root = &#39;&#39;0
  p_id = &#39;&#39;

  for i in data:
      #将data循环，然后加入一个dict中，key为每条数据的ID，val对应为整条数据
      tree[i[&quot;id&quot;]] = i
#{  1:{id:1},  2:{id:2},  3:{id:3}  }  
      # print(tree)

  for i in data:
    #p_id==None，他就是祖先
      if i[&quot;p_id&quot;] == None:
          root = tree[i[&quot;id&quot;]]  #i.di为tree里的key，将key对应的val取出
          list.append(root)
      else:
          p_id = i[&quot;p_id&quot;]
          # 判断父级是否有孩子字段（childlist），如果有将当前数据加入，如果没有添加（childlist）后再加入
          if &quot;childlist&quot; not in tree[p_id]:
              tree[p_id][&#39;childlist&#39;] = []
          tree[p_id][&quot;childlist&quot;].append(tree[i[&quot;id&quot;]])
  return list</code></pre><h4 id="Vue的配置-利用父子组件"><a href="#Vue的配置-利用父子组件" class="headerlink" title="Vue的配置(利用父子组件)"></a>Vue的配置(利用父子组件)</h4><ul>
<li>子组件配置</li>
</ul>
<pre><code>&lt;!-- zizujian.vue --&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;li&gt;{{data.content}}
            &lt;ul v-if=&quot;data.childlist &amp;&amp; data.childlist.length&gt;0&quot;&gt;
            &lt;zi v-for=&quot;i in data.childlist&quot; :key=&quot;i.id&quot; :data=&quot;i&quot; /&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
export default {
    name:&quot;zi&quot;,
    props:[&quot;data&quot;]
}
&lt;/script&gt;
&lt;style&gt;

ul{
    list-style: none;
    /* padding-left: 20px */
}
&lt;/style&gt;</code></pre><p>父组件配置</p>
<pre><code>&lt;!-- zizujian.vue --&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;li&gt;{{data.content}}
            &lt;ul v-if=&quot;data.childlist &amp;&amp; data.childlist.length&gt;0&quot;&gt;
            &lt;zi v-for=&quot;i in data.childlist&quot; :key=&quot;i.id&quot; :data=&quot;i&quot; /&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
export default {
    name:&quot;zi&quot;,
    props:[&quot;data&quot;]
}
&lt;/script&gt;
&lt;style&gt;

ul{
    list-style: none;
    /* padding-left: 20px */
}
&lt;/style&gt;
父组件配置

Undefined
&lt;!-- fuzujian.vue --&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;zi :data=&quot;data&quot; /&gt;
        &lt;!-- &lt;zizujian :data=&quot;data&quot; /&gt; --&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import zi from &#39;./zi&#39;
import axios from &#39;axios&#39;

export default {
    name:&quot;showzi&quot;,
    data() {
        return {
            data:&#39;&#39;
        }
    },
    components:{
        zi
    },
    methods:{
        get_info(){
            axios.get(&quot;http://127.0.0.1:8000/comment/com/&quot;).then(res=&gt;{
                var mytree = {&quot;id&quot;:0,&quot;content&quot;:&quot;&quot;}
                mytree[&quot;childlist&quot;] = res.data.data
                this.data= mytree
                // this.data= res.data.data
                // console.log(this.data)
            })
        }
    },
    created(){
        this.get_info()
    }
}
&lt;/script&gt;</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>百度地图API</title>
    <url>/blog/2020/05/29/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI/</url>
    <content><![CDATA[<p>百度api的文档<a href="https://dafrok.github.io/vue-baidu-map/#/zh/start/usage" target="_blank" rel="noopener">https://dafrok.github.io/vue-baidu-map/#/zh/start/usage</a></p>
<p>个人觉得百度地图api相比高德来说，还是比较好用的，坑比较少</p>
<p>使用方法：</p>
<p>1.安装</p>
<pre><code>npm install vue-baidu-map --save</code></pre><p>2.全局注册将一次性引入百度地图组件库的所有组件。</p>
<p>main.js</p>
<pre><code class="vue">import Vue from &#39;vue&#39;
import BaiduMap from &#39;vue-baidu-map&#39;

Vue.use(BaiduMap, {
  // ak 是在百度地图开发者平台申请的密钥 详见 http://lbsyun.baidu.com/apiconsole/key */
  ak: &#39;YOUR_APP_KEY&#39;
})</code></pre>
<p>3.vue界面</p>
<pre><code class="vue">&lt;template&gt;
  &lt;baidu-map :center=&quot;center&quot; :zoom=&quot;zoom&quot; @ready=&quot;handler&quot;&gt;&lt;/baidu-map&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data () {
    return {
      center: {lng: 0, lat: 0},
      zoom: 3
    }
  },
  methods: {
    handler ({BMap, map}) {
      console.log(BMap, map)
      this.center.lng = 116.404
      this.center.lat = 39.915
      this.zoom = 15
    }
  }
}
&lt;/script&gt;
&lt;style&gt;
.map {
  width: 100%;
  height: 400px;
}
&lt;/style&gt;</code></pre>
<p>简单的地图页面就好了</p>
<p>相比高德简单的多</p>
<p>当然还有很多其他功能，在官网都可以实现</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Python静态方法，类方法</title>
    <url>/blog/2020/05/27/python%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>首先我们先代码示例</p>
<pre><code class="python">class A:  #先定义一个类
    a = 1  #类的属性  全局
    def __init__(self):
        self.b = 1  #示例属性
    #静态方法
    # @staticmethod
    # def func():
    #     print(&#39;这是一个静态方法&#39;)

    #类方法
    # @classmethod
    # def func(cls):
    #     #  cls-&gt;A   cls这个实例指向A
    #     cls.a = 2   对a重新赋值

    #属性方法
    @property
    def func(self):
        return 1

a = A()
# b = A()
# print(a.func())
# print(A.func())

print(a.func)</code></pre>
<p>staticmethod静态方法 对于在一个类中是权限比较局限的一个方法，它定义的方法只能做一些共有，无法对类中的属性进行操作，</p>
<p>而classmethod类方法，它提供了cls,可以对类的对象进行操作，还是比staticmethod多了一权限的</p>
<p>还有property属性方法它可以对类中的函数进行变量定义的，就是用property装饰之后，调用就可以不需要（）括号了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2---Python3</title>
    <url>/blog/2020/05/27/%E8%B0%88%E8%B0%88python2%E5%92%8Cpython3/</url>
    <content><![CDATA[<p>Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。</p>
<p>Python3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表。</p>
<p>Python2 range() 函数返回的是列表。</p>
<p>Python2 xrange() 用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。</p>
<p>Python3中取消了 Xrange()的使用，结合成为了 range()</p>
<p>range示例:</p>
<pre><code class="python">&gt;&gt;&gt; range(5)
[0, 1, 2, 3, 4]</code></pre>
<p>xrange示例:</p>
<p>用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。</p>
<pre><code class="python">&gt;&gt;&gt; xrange(5)
xrange(5)
&gt;&gt;&gt; list(xrange(5))
[0, 1, 2, 3, 4]
&gt;&gt;&gt; xrange(1,5)  
xrange(1, 5)
&gt;&gt;&gt; list(xrange(1,5))
[1, 2, 3, 4]</code></pre>
<p>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间</p>
<p>python 中废弃了Xrange的使用</p>
<p>print语句被python3废弃，只能使用print函数</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>最近阿里的OceanBase</title>
    <url>/blog/2020/05/27/%E5%85%B3%E4%BA%8E%E9%98%BF%E9%87%8C%E7%9A%84OceanBase/</url>
    <content><![CDATA[<h4 id="最近阿里的OceanBase"><a href="#最近阿里的OceanBase" class="headerlink" title="最近阿里的OceanBase"></a>最近阿里的OceanBase</h4><p><strong>1、引言</strong></p>
<p>OceanBase 是蚂蚁金服自研的分布式数据库，在其 9 年的发展历程里，从艰难上线到找不到业务场景濒临解散，最后在双十一的流量考验下浴火重生，成为蚂蚁金服全部核心系统的承载数据库。这一路走来的艰辛和故事，蚂蚁金服高级研究员、OceanBase 团队负责人阳振坤将为你娓娓道来。</p>
<p>什么是OceanBase数据库？</p>
<p>​    是阿里巴巴集团自主研发的分布式关系型数据库，融合传统关系型数据库强大功能与分布式系统的特点，具备持续可用、高度可扩展、高性能等优势。广泛应用于蚂蚁金服、网商银行等金融级核心系统。 在2015年双11承载了蚂蚁核心链路100%的流量，创下了交易、支付每秒支付峰值的新纪录，在功能、稳定性、可扩展性、性能方面都经历过严格的检验。</p>
<p>OceanBase 的优点：</p>
<p>​    OceanBase相对于传统关系数据库的创新首先是运维方面的。将数据库故障切换（高可用）、异地容灾/多活、负载均衡、分布式架构弹性扩容缩容（DB不停服务）全部做到数据库内核里面了，这些是数据库的固有属性，还拿不掉。不需要人工介入（当然机器坏了还是要运维负责去安排维修的，不同之处是运维可以很从容的去处理机器故障）。当然这个固有能力的成本就是数据至少要三副本</p>
<p>​    其次就是硬件成本方面。OceanBase架构是shared-nothing架构，不需要共享存储。只需要普通的x86服务器；不需要小机，也不支持小机平台。只需要普通的SSD（OceanBase读写模型里随机写很少，不伤SSD寿命）</p>
<p>​    还有就是分布式，可以大规模部署OceanBase集群，同时又支持多租户管理，对机器资源的使用非常灵活，机器利用率高（有负载均衡在，不怕某些机器太闲某些机器太忙）。曾经最大的OceanBase集群机器数超过100台（主要是业务数据量是上百亿级别的）</p>
<p>OceanBase 的劣势：</p>
<p>​    就是对于硬件的需求略高，如至少32C64G（更小也可以搭建集群，但使用不当容易有问题），生产环境建议256G等</p>
<p>当然，有优势，就会有劣势。希望阿里的OB数据库能广泛应用！</p>
]]></content>
      <categories>
        <category>关于</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>高德地图API</title>
    <url>/blog/2020/05/26/%E9%AB%98%E5%BE%B7API%E5%9C%A8vue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>1.安装高德API的三方包</p>
<pre><code>npm install vue-amap --save</code></pre><p>我踩的坑就是，根据提示，要安装的是这个包，一定不要安装，因为也安不上</p>
<pre><code>npm install AMap --save</code></pre><p>2.<strong>修改webpac.base.conf.js文件</strong>,在module.exports = {的下面加上</p>
<pre><code class="vue">  externals: {
    &#39;AMap&#39;: &#39;AMap&#39;
  }</code></pre>
<ol start="3">
<li>index.html   页面</li>
</ol>
<pre><code class="vue">&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=自己的key&quot;&gt;&lt;/script&gt; </code></pre>
<p>必须加</p>
<p>4.main.js   ,基于原有的添加，不是修改原有的</p>
<pre><code class="vue">import Vue from &#39;vue&#39;;
import VueAMap from &#39;vue-amap&#39;;
import App from &#39;./App.vue&#39;;

Vue.use(VueAMap);
VueAMap.initAMapApiLoader({
  key: &#39;your amap key&#39;,
  plugin: [&#39;AMap.Autocomplete&#39;, &#39;AMap.PlaceSearch&#39;, &#39;AMap.Scale&#39;, &#39;AMap.OverView&#39;, &#39;AMap.ToolBar&#39;, &#39;AMap.MapType&#39;, &#39;AMap.PolyEditor&#39;, &#39;AMap.CircleEditor&#39;],
  // 默认高德 sdk 版本为 1.4.4
  v: &#39;1.4.4&#39;
});

new Vue({
  el: &#39;#app&#39;,
  render: h =&gt; h(App)
})</code></pre>
<p>5.在你想展示的图的页面写</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;div id=&quot;container&quot; style=&quot;width:500px; height:300px&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import AMap from &#39;AMap&#39;
  var map
  export default {
    mounted: function () {
      this.init()
    },
    methods: {
      init: function () {
        map = new AMap.Map(&#39;container&#39;, {
          center: [116.397428, 39.90923],
          resizeEnable: true,
          zoom: 10
        })
        AMap.plugin([&#39;AMap.ToolBar&#39;, &#39;AMap.Scale&#39;], function () {
          map.addControl(new AMap.ToolBar())
          map.addControl(new AMap.Scale())
        })
      }
    }
  }
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;      </code></pre>
<p>这个经纬度是北京。也可以改为你想要的。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>flask蓝图</title>
    <url>/blog/2020/05/23/flask%E8%93%9D%E5%9B%BE/</url>
    <content><![CDATA[<p>flask的代码都写在一个.py 文件太乱了，维护部方便，</p>
<p>使用蓝图</p>
<p>在main.py 文建里写，就是运行文件</p>
<pre><code>from app import app,db
from flask_migrate import Migrate,MigrateCommand
from flask_script import Manager
from models import *
from admin import admin_blue  #导入蓝图文件
from index import index_blue#导入蓝图文件


db.init_app(app)
manage = Manager(app)
Migrate(app,db)
manage.add_command(&#39;db&#39;,MigrateCommand)

#注册后台蓝图
app.register_blueprint(admin_blue,url_prefix=&#39;/admin&#39;)

#注册前台蓝图
app.register_blueprint(index_blue)


if __name__ == &#39;__main__&#39;:
    manage.run()</code></pre><p>在蓝图文件里写</p>
<pre><code>from flask import Blueprint,render_template,session,make_response,request,jsonify,g
from vvv.captcha.captcha import captcha
from werkzeug.security import generate_password_hash,check_password_hash
from models import *
from vvv.comm import isUserLogin
from app import photos
import re
index_blue=Blueprint(&#39;index&#39;,__name__)

@index_blue.route(&#39;/registe&#39;)   #路由里加入蓝图的变量
def registe():
    #可以逻辑
    return render_template(&#39;news/reg.html&#39;)# 返回页面
</code></pre><p>app.py</p>
<pre><code class="python">from flask import Flask
from config import Config
from flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config.from_object(Config)
db = SQLAlchemy(app)

from flask_uploads import IMAGES,UploadSet,configure_uploads
import sys,os
fn = getattr(sys.modules[&#39;__main__&#39;], &#39;__file__&#39;)
root_path = os.path.abspath(os.path.dirname(fn))+&quot;/static/upload&quot;

app.config[&#39;UPLOADED_PHOTO_DEST&#39;] = root_path
app.config[&#39;UPLOADED_PHOTO_ALLOW&#39;] = IMAGES
photos = UploadSet(&#39;PHOTO&#39;)

configure_uploads(app, photos)</code></pre>
<p>config.py</p>
<pre><code class="python">from flask import Flask
from config import Config
from flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config.from_object(Config)
db = SQLAlchemy(app)

from flask_uploads import IMAGES,UploadSet,configure_uploads
import sys,os
fn = getattr(sys.modules[&#39;__main__&#39;], &#39;__file__&#39;)
root_path = os.path.abspath(os.path.dirname(fn))+&quot;/static/upload&quot;

app.config[&#39;UPLOADED_PHOTO_DEST&#39;] = root_path
app.config[&#39;UPLOADED_PHOTO_ALLOW&#39;] = IMAGES
photos = UploadSet(&#39;PHOTO&#39;)

configure_uploads(app, photos)</code></pre>
<p>如果需要上传图片，需要在form表单里写</p>
<pre><code class="html">&lt;form class=&quot;release_form&quot; method=&#39;post&#39; enctype=&quot;multipart/form-data&quot;&gt;
&lt;/form&gt;</code></pre>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx部署Django+contos安装python3</title>
    <url>/blog/2020/05/22/Nginx%E9%83%A8%E7%BD%B2Django+uwsgi/</url>
    <content><![CDATA[<p>　<strong>1、在centos 7中安装python3环境</strong></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" srcset="/img/loading.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code># 1、yum更新yum源
yum update
# 2、安装Python 3.7所需的依赖否则安装后没有pip3包
yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make
# 3、在官网下载所需版本，这里用的是3.7.0版本，这个应该下不了，去官网找一个，就好。
wget https://www.python.org/ftp/3.7.0/Python-3.7.0.tgz</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" srcset="/img/loading.gif" alt="img"> <strong>2、安装Python</strong></p>
<p>　　<strong>2、初始化一个django项目</strong></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" srcset="/img/loading.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>[root@linux-node1 /]# pip3 install django==2.0.4
[root@linux-node1 /]# mkdir /code/
[root@linux-node1 /]# cd /code/
[root@linux-node1 testProj]# django-admin startproject mmcsite
[root@linux-node1 testProj]# cd /code/mmcsite
[root@linux-node1 testProj]# python3 manage.py runserver 0.0.0.0:8000
# 页面中访问：http://192.168.56.11:8000/</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p>　　<strong>3、安装uwsgi 并使用uWSGI启动这个服务</strong></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" srcset="/img/loading.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>&#39;&#39;&#39;1. 安装uwsgi&#39;&#39;&#39;
[root@linux-node1 /]# pip3 install uwsgi
[root@linux-node1 /]# ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi

&#39;&#39;&#39;2. 配置uwsgi.ini启动文件&#39;&#39;&#39;
[root@linux-node1 /]# vim uwsgi.ini
[uwsgi]
socket = 0.0.0.0:3031
chdir = /code/mmcsite
wsgi-file = /code/mmcsite/wsgi.py
processes = 5
threads = 30
master = true
daemonize = /code/mmcsite/uwsgi.log
module=mmcsite.wsgi
pidfile = /code/mmcsite/uwsgi.pid
chmod-socket=666
enable-threads = true

&#39;&#39;&#39;3. 使用uwsgi启动django：一定要在这个项目目录中&#39;&#39;&#39;
[root@linux-node1 /]# uwsgi --http 192.168.56.11:80 --file mmcsite/wsgi.py --static-map=/static=static
访问项目：http://192.168.56.11</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>[root@linux-node2 demo2]# vim /code/mmcsite/uwsgi.ini  # uwsgi.ini文件
[uwsgi]
socket = 0.0.0.0:6789                  # 指定socket监听的地址和端口
chdir = /code/mmcsite                  # 项目路径 
wsgi-file = /code/mmcsite/wsgi.py      # django的wsgi文件路径
processes = 5                          # 启动五个进程
threads = 30                           # 每个进程启动30个线程
master = true
daemonize = /code/mmcsite/uwsgi.log    # 日志存放路径
module=mmcsite.wsgi                    # 使用mmcsite.wsgi模块
pidfile = /code/mmcsite/uwsgi.pid      # uwsgi启动进程id存放路径
chmod-socket=666                       # socket权限
enable-threads = true                  # 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p>　　<strong>4、安装配置nginx</strong></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" srcset="/img/loading.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>&#39;&#39;&#39;1. 配置nginx YUM源&#39;&#39;&#39;
[root@linux-node1 /] vim /etc/yum.repos.d/nginx.repo
​```
[nginx]
name=nginx repo
# 下面这行centos根据你自己的操作系统修改比如：OS/rehel
# 6是你Linux系统的版本，可以通过URL查看路径是否正确
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
​```
&#39;&#39;&#39;2. 安装nginx&#39;&#39;&#39;
[root@linux-node1 /] yum -y install nginx</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" srcset="/img/loading.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<pre><code>[root@linux-node1 /]# vim /etc/nginx/conf.d/django.conf 
server {
    listen 8001; #暴露给外部访问的端口 
    server_name localhost; 
    charset utf-8; 
    location / { 
        include uwsgi_params; 
        uwsgi_pass 127.0.0.1:6666; #这个端口要和jcdemo_uwsgi.ini里socket保持一致，外部访问8001就转发到内部6666，尽量不要用6789作为uwsgi的端口

        #proxy_set_header Upgrade $http_upgrade;
        #proxy_set_header Connection &quot;upgrade&quot;;

     }    
}


    include /etc/nginx/conf.d/*.conf;
}</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="/img/loading.gif" alt="复制代码"></a></p>
<p>　　<strong>5、启动项目</strong></p>
<pre><code>[root@linux-node1 demo2]# systemctl restart nginx   # 开启nginx
[root@linux-node1 demo2]# uwsgi --ini uwsgi.ini     # 启动uwsgi的django项目
# http://192.168.56.11:8888/ 访问项目
[root@linux-node1 demo2]# uwsgi --stop uwsgi.pid    # 关闭uwsgi</code></pre><p>转载：<a href="https://www.cnblogs.com/xiaonq/p/8932266.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaonq/p/8932266.html</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>MangoDB的ObjectId</title>
    <url>/blog/2020/05/22/%E5%85%B3%E4%BA%8EMongoDB%E7%9A%84objectID/</url>
    <content><![CDATA[<pre><code> ObjectId(&quot;5ebe8535d9cad4cedf86456d&quot;)</code></pre><p>mongoDB的id不是自增的，而是一种唯一的objectID类型的数据</p>
<p>获取是，获取到了应该是</p>
<pre><code>&quot;$oid&quot;: &quot;54651022bffebc03098b4567&quot;</code></pre><p>这样的数据</p>
<p>下面是使用方法</p>
<pre><code>_id = request.data.get(&#39;_id&#39;)   # ==     &quot;$oid&quot;: &quot;54651022bffebc03098b4567
if _id:   #判断是否存在
   if ObjectId.is_valid(_id[&#39;$oid&#39;]):
      A = ObjectId(_id[&#39;$oid&#39;])#  存在转为objectID类型，并赋值给A</code></pre>]]></content>
      <categories>
        <category>Mango</category>
      </categories>
      <tags>
        <tag>Mango</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/blog/2020/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>栈</strong></p>
<p>栈的定义：栈是一种数据集合，可以理解为只能在一端进行插入或删除操作的列表</p>
<p>栈的特点：先进后出</p>
<pre><code>
&quot;&quot;&quot;   先进后出  &quot;&quot;&quot;
class Stack(object):
    &quot;&quot;&quot;栈类&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;创建一个新的空栈&quot;&quot;&quot;
        self.stack = []

    def push(self,item):
        &quot;&quot;&quot;添加一个新的元素item到栈顶&quot;&quot;&quot;
        self.stack.append(item)

    def pop(self):
        &quot;&quot;&quot;弹出栈顶元素&quot;&quot;&quot;
        return self.stack.pop()

    def peek(self):
        &quot;&quot;&quot;返回栈低元素&quot;&quot;&quot;
        return self.stack[-1]

    def is_empty(self):
        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;
        return self.stack == []

    def size(self):
        &quot;&quot;&quot;返回栈的元素个数&quot;&quot;&quot;
        return len(self.stack)

if __name__ == &#39;__main__&#39;:
    s = Stack()
    print(s.is_empty())
    print(s.size())
    print(&quot;_&quot;*20)
    s.push(1)
    s.push(2)
    print(s.pop())
    print(s.peek())
    print(&quot;_&quot;*20)</code></pre><p><strong>队列</strong></p>
<p>1、队列是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除</p>
<p>2、插入的一端称为队尾（rear），插入动作叫进队或入队</p>
<p>3、进行删除的一端称为对头（front），删除动作称为出队</p>
<p>4、队列性质：先进先出（First-in, First-out）</p>
<p>5、双向队列：队列的两端都允许进行进队和出队操作</p>
<pre><code>
&quot;&quot;&quot;先进先出&quot;&quot;&quot;
class Queue(object):
    &quot;&quot;&quot;队列类&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;创建一个空的队列&quot;&quot;&quot;
        self.queue = []
    def enqueue(self,item):
        &quot;&quot;&quot;往队列里添加一个tiem元素&quot;&quot;&quot;
        self.queue.append(item)
    def depueue(self):
        &quot;&quot;&quot;从队列头部删除一个元素&quot;&quot;&quot;
        return self.queue.pop(0)
    def is_empty(self):
        &quot;&quot;&quot;判断一个队列是否为空&quot;&quot;&quot;
        return self.queue ==[]
    def size(self):
        &quot;&quot;&quot;返回队列大小&quot;&quot;&quot;
        return len(self.queue)
if __name__ == &#39;__main__&#39;:
    s = Queue()
    print(s.is_empty())
    print(s.size())
    print(&quot;*&quot;*20)
    s.enqueue(1)</code></pre><p><strong>链表</strong></p>
<p>链表中每个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一节点的指针next，通过各个节点间的相互连接，最终串联成一个链表</p>
<p>​    单链表：每个节点分为一个data和一个指针，指针指向下一个节点</p>
<p>双向链表：每个节点分为一个data和两个指针，第一个指针指向上一个节点，第二个指针指向下一个节点、</p>
<p>链表不需要改变内存的地址，只需要修改节点的信息即可（包括指针指向，节点值）。</p>
<p><strong>而链表大小可变，扩展性强，只能顺着指针的方向查询，速度较慢。</strong></p>
<p><strong>链表成环的检测</strong></p>
<p>在有关链表的面试算法题中，检测链表是否有环是常见的题目。给定一个链表，要求你判断链表是否存在循环，如果有，给出环的长度，要求算法的时间复杂度是O(N), 空间复杂度是O(1).</p>
<p>链表成环的条件：链表的两个指针指向同一个节点</p>
<p>判断链表成环：定义两个变量，一个变量一次走一个节点，另一个变量一次走两个节点，当两个变量相遇的时候，就是环的交点。</p>
<p><strong>数组</strong></p>
<ol>
<li><p>所谓数组，就是相同数据类型的元素按一定顺序排列的集合</p>
</li>
<li><p>在Java等其他语言中并不是所有的数据都能存储到数组中，只有相同类型的数据才可以一起存储到数组中。</p>
</li>
<li><p>因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以他的特点就是寻址读取数据比较容易，插入和删除比较困难</p>
</li>
</ol>
<p>list</p>
<p>查询可以用下表直接查询到目标，不用循环遍历</p>
<p>数组的中间插入（或删除）一个元素，那么这个元素后的所有元素的内存地址都要往后（前）移动（数组的内存地址是连续的），对最后一个元素插入（或删除）时才比较快</p>
<p>查询时间复杂度：O(1)    删除和修改时间复杂度：O(n)</p>
<p><strong>数组大小固定，不适合动态存储，动态添加，内存为一连续的地址，可随机访问，查询较快，</strong></p>
<p><strong>跳表</strong></p>
<p>查询O(logn)，添加，删除O(logn)</p>
<p>每一级跳过一定数量的数据的链表</p>
<p>如：</p>
<p>1———————10</p>
<p>1———5———–10</p>
<p>1—-3—5——7—–10</p>
<p>1-2-3-4-5-6-7-8-9-10</p>
<p>如果你在第一层，查不到你想要的数据就去第二层，以此类推。</p>
<p>提高查询效率。</p>
<p><strong>散列表：</strong></p>
<p>查询，删除，添加 O(1)</p>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>散列表冲突解决：</p>
<ul>
<li>开放寻址方式</li>
<li>拉链法</li>
</ul>
<p>链接法其中优点有：<br>    1、链接法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br>    2、由于链接法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况。</p>
<p>开放寻址法不用指针，潜在地节约了空间，用这些空间可存放更多的槽，从而潜在地减少了冲突，提升了速度。</p>
<p><strong>树：</strong></p>
<p>​        有一个根结点，并且任意两个结点直接只有一个链接路径</p>
<h2 id="一、树的概念"><a href="#一、树的概念" class="headerlink" title="一、树的概念"></a>一、树的概念</h2><p>　　<strong>1、树的特性</strong></p>
<p>　　　　　　1）一棵树中的任意两个结点有且仅有唯一的一条路径连通； </p>
<p>　　　　　　2）一棵树如果有n个结点，则它一定有n−1条边； </p>
<p>　　　　　　3）在一棵树中加一条边将会构成一个回路。</p>
<p>　　<strong>2、二叉树</strong></p>
<p>　　　　　　1）二叉树是一种特殊的树，二叉树的特点是每个结点最多有两个儿子。</p>
<p>　　　　　　2）二叉树使用范围最广，一颗多叉树也可以转化为二叉树。</p>
<p>　　<strong>3、满二叉树</strong></p>
<p>　　　　　　1）二叉树中每个内部节点都有两个儿子，满二叉树所有的叶节点都有相同的深度。</p>
<p>　　　　　　2）满二叉树是一棵深度为h且有2h−1个结点的二叉树。</p>
<p>　　<strong>4、完全二叉树</strong></p>
<p>　　　　　　1）若设二叉树的高度为h，除了第h层外，其他层的结点数都达到最大个数，第h层从右向左连续 缺若干个结点，则为完全二叉树。</p>
<p>B-Tree和B+Tree</p>
<p><a href="https://www.cnblogs.com/ppzhang/p/10424292.html" target="_blank" rel="noopener">https://www.cnblogs.com/ppzhang/p/10424292.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis详情</title>
    <url>/blog/2020/05/22/redis%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><p>RDB   类比游戏存档操作</p>
<pre><code> 采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：</code></pre><pre><code>save 60 100</code></pre><pre><code> 会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。</code></pre><p>可以配置多条save指令，让Redis执行多级的快照保存策略。</p>
<p><strong>RDB的优点</strong></p>
<p>1.快速，对性能影响最小，几乎不影响Redis处理客户端请求的效率。</p>
<p>2.使用RDB文件进行数据恢复比使用AOF要快很多</p>
<p><strong>RDB的缺点</strong></p>
<p>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</p>
<p>就比如打游戏打到一半redis突然崩了，这时候就没有进行快照，你着一半的数据就会丢失。</p>
<p>AOF   同步翻译</p>
<p>​    采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新</p>
<p><strong>AOF的优点：</strong></p>
<ul>
<li><p>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</p>
</li>
<li><p>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</p>
</li>
<li><p>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据</p>
</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<p><strong>AOF简称就是确保了数据的安全性。但是丢失了效率</strong></p>
<h2 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a>内存管理与数据淘汰机制</h2><h3 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a>最大内存设置</h3><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</p>
<p>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。</p>
<p>通过如下配置控制Redis使用的最大内存：</p>
<pre><code>maxmemory 100mb</code></pre><p>就是，你不可能让redis把所有的内存用光，用完的话你背的进程就没办法运行了，所以要加个</p>
<p>最大使用限制，一旦超过这个限制，就启动数据淘汰机制</p>
<h3 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h3><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li>volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li>allkeys-lru：使用LRU算法进行数据淘汰，当内存不足以容纳新写入数据时, 在键空间中, 移除最近最少使用的key</li>
<li>volatile-random：随机淘汰数据，只淘汰设定了有效期的key</li>
<li>allkeys-random：随机淘汰数据，所有的key都可以被淘汰</li>
<li>volatile-ttl：淘汰剩余有效期最短的key</li>
</ul>
<h3 id="redis-雪崩，击穿，穿透"><a href="#redis-雪崩，击穿，穿透" class="headerlink" title="redis 雪崩，击穿，穿透"></a>redis 雪崩，击穿，穿透</h3><h4 id="什么是redis穿透？"><a href="#什么是redis穿透？" class="headerlink" title="　什么是redis穿透？"></a>　什么是redis穿透？</h4><p>　　　　1、查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不                到数据则不写入缓存</p>
<p>　　　　2、这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义</p>
<p>　　　　3、在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<p><strong>redis穿透</strong>：比如有人向你发送大量的恶意请求，请求的数据都不存在，当请求去查找redis缓存区时，就查询不到，这时候，大量的请求就会到数据库层，DB进行大量的IO，就造成了穿透。</p>
<h4 id="什么是redis雪崩？"><a href="#什么是redis雪崩？" class="headerlink" title="什么是redis雪崩？"></a>什么是redis雪崩？</h4><p>　　　　1、缓存中大批量热点数据过期后系统涌入大量查询请求</p>
<p>　　　　2、因为大部分数据在Redis层已经失效，请求渗透到数据库层</p>
<p>　　　　3、大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p>
<p><strong>redis雪崩：</strong><br>　　　　对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机，缓存挂了。</p>
<p>此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了</p>
<h4 id="什么是redis的击穿"><a href="#什么是redis的击穿" class="headerlink" title="什么是redis的击穿"></a>什么是redis的击穿</h4><p>　　　　1、就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况</p>
<p>　　　　2、当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>
<p>　　　　3、击穿和缓存雪崩的区别在于击穿针对某一key缓存，雪崩则是很多key</p>
<p><strong>redis击穿：</strong></p>
<p>比如秒杀的时候，一个key突然失效，请求就会击穿DB层。</p>
<h3 id="redis的优化"><a href="#redis的优化" class="headerlink" title="redis的优化"></a>redis的优化</h3><ul>
<li><p>命令优化—–知道不同的命令他的时间复杂度不同，尽量使用O(1)，少使用O(n)。</p>
<p>尽量不要使用keys *，这一类的语句</p>
</li>
<li><p>主从，读写分离</p>
</li>
<li><p>数据持久化策略</p>
</li>
<li><p>管道</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RBAC</title>
    <url>/blog/2020/05/22/RBAC/</url>
    <content><![CDATA[<h1 id="RBAC-介绍-权限"><a href="#RBAC-介绍-权限" class="headerlink" title="[RBAC 介绍 (权限)]"></a>[RBAC 介绍 (权限)]</h1><p>RBAC是什么？</p>
<p><a href="http://www.sojson.com/tag_rbac.html" target="_blank" rel="noopener">RBAC  </a>是基于角色的访问控制（<code>Role-Based Access Control</code> ）在<a href="http://www.sojson.com/tag_rbac.html" target="_blank" rel="noopener"> RBAC  </a>中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</p>
<h1 id="RBAC介绍。"><a href="#RBAC介绍。" class="headerlink" title="RBAC介绍。"></a>RBAC介绍。</h1><p><a href="http://www.sojson.com/tag_rbac.html" target="_blank" rel="noopener">RBAC  </a>认为授权实际上是<code>Who</code> 、<code>What</code> 、<code>How</code> 三元组之间的关系，也就是<code>Who</code> 对<code>What</code> 进行<code>How</code> 的操作，也就是“主体”对“客体”的操作。</p>
<p><strong>Who：是权限的拥有者或主体（如：User，Role）。</strong></p>
<p><strong>What：是操作或对象（operation，object）。</strong></p>
<p><strong>How：具体的权限（Privilege,正向授权与负向授权）。</strong></p>
<p>然后<a href="http://www.sojson.com/tag_rbac.html" target="_blank" rel="noopener"> RBAC  </a>又分为<code>RBAC0、RBAC1、RBAC2、RBAC3</code> ，如果你不知道他们有什么区别，你可以百度百科：<a href="http://baike.baidu.com/link?url=Tg3nxejvD2QVLLkjKa_4XaQoOWSPAVpR1FgHAG_gANcamtN2cYIm1r1irNw9VZ816FBrMEvdoYqwzixqdHd5e_" target="_blank" rel="noopener">百度百科-RBAC</a> 估计你看不懂。还是看看我的简单介绍。</p>
<p>我这里结合我的见解，简单的描述下（去掉那么多的废话）。</p>
<h1 id="RBAC0、RBAC1、RBAC2、RBAC3简单介绍。"><a href="#RBAC0、RBAC1、RBAC2、RBAC3简单介绍。" class="headerlink" title="RBAC0、RBAC1、RBAC2、RBAC3简单介绍。"></a>RBAC0、RBAC1、RBAC2、RBAC3简单介绍。</h1><ul>
<li><strong>RBAC0：是RBAC的核心思想。</strong></li>
<li><strong>RBAC1：是把RBAC的角色分层模型。</strong></li>
<li><strong>RBAC2：增加了RBAC的约束模型。</strong></li>
<li><strong>RBAC3：其实是RBAC2 + RBAC1。</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>django 唯一索引</title>
    <url>/blog/2020/05/19/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="django-唯一索引"><a href="#django-唯一索引" class="headerlink" title="django 唯一索引"></a>django 唯一索引</h4><p>意义：是为了更高效的查询数据</p>
<pre><code> # 只能加速查找
        db_index=True, 
        # 普通索引，加速查找,限制列值唯一
        unique = True,
        # 唯一索引，加速查找,限制列值唯一(不能为空)
        primary = True,</code></pre><pre><code>class User(models.Model):
    #常用字段：

    #字符字段
    username = models.CharField(max_length=32)

    #数字字段
    age = models.IntegerField()#整数
    num = models.DecimalField(max_digits=10,decimal_places=2)#小数，长度10，小数点位数2

    #时间字段
    ctime = models.DateTimeField()
    class Meta:
    #联合唯一索引，username和age不能重复，
    username， 和age可以重复，但是他俩在一条字段里，就不能重复了

        unique_together = (
            (&#39;username&#39;,&#39;age&#39;),
        )
        #联合索引(不唯一)
        index_together = (
            (&#39;username&#39;, &#39;age&#39;),
        )
</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx详情</title>
    <url>/blog/2020/05/12/Nginx%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>1、什么是nginx？什么是nginx的反向代理？正向代理又是什么？nginx反向代理的作用？</p>
<p>2、什么是uwsgi，UWSGI，wsgi。他们的作用分别什么是？</p>
<p>3、nginx+uwsgi+django的通信过程是如何完成的</p>
<p>4、uwsgi配置里的 <code>socket,chdir,wsgi-file,daemonize,pidfile</code>这几个配置的作用是什么？</p>
<p>5、nginx的配置里<code>listen,server_name, location</code>分别什么什么作用？</p>
<p>6、uwsgi的启动命令，停止命令，日志目录。</p>
<p>1.<em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a>和<a href="https://baike.baidu.com/item/反向代理/7793488" target="_blank" rel="noopener">反向代理</a>web服务器</p>
<p><strong>为什么需要Nginx</strong><br>一个普通的个人网站，访问量不大的话，当然可以由uWSGI和Django构成。但是一旦访问量过大，客户端请求连接就要进行长时间的等待。这个时候就出来了分布式服务器，我们可以多来几台web服务器，都能处理请求。但是谁来分配客户端的请求连接和web服务器呢？Nginx就是这样一个管家的存在，由它来分配。这也就是由Nginx实现反向代理，即代理服务器。</p>
<p><strong>正向代理代理客户端</strong></p>
<p>1.1 <strong>nginx的正向代理</strong>：</p>
<p>​    举个栗子：在我们国内是访问不了，twitter，脸书，gmail等一些东西，我们需要搞个</p>
<p>VPN的东西，这里的 VPN 就是做正向代理的,正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。</p>
<p>客户端 —–&gt;    正向代理服务器    ———&gt;目标服务器</p>
<p>​                                 VPN</p>
<p>客户端 &lt;—–    正向代理服务器    &lt;———目标服务器</p>
<p>1.2 <strong>nginx的反向代理</strong>：</p>
<p>反向代理是代理的服务端</p>
<p>反向代理服务器通常有两种模型，它可以作为内容服务器的替身，也可以作为内容服务器集群的负载均衡器。</p>
<p>栗子：如同生活中的专卖店~客人到adidas专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是adidas厂家，目标角色就是用户</p>
<p>  1，作内容服务器的替身                     </p>
<p>​                     如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在防火墙内部受到安全保护。代理服务器位于防火墙外部，在客户机看来就像是内容服务器。</p>
<p> 2，作为内容服务器的负载均衡器</p>
<p>​                   可以在一个组织内使用多个代理服务器来平衡各 Web 服务器间的网络负载。在此模型中，可以利用代理服务器的高速缓存特性，创建一个用于负载平衡的服务器池。此时，代理服务器可以位于防火墙的任意一侧。如果 Web 服务器每天都会接收大量的请求，则可以使用代理服务器分担 Web 服务器的负载并提高网络访问效率。</p>
<h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><ol>
<li><p>WSGI是一种规范，它定义了使用python编写的web app(django)与web server（uWSGI）之间接口格式，实现web app与web server间的解耦。</p>
</li>
<li><p>WSGI 没有官方的实现, 因为WSGI更像一个协议. 只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行</p>
</li>
<li><p><strong>WSGI**</strong>实质：**WSGI是一种描述web服务器（如nginx，uWSGI等服务器）如何与web应用程序（如用Django、Flask框架写的程序）通信的规范、协议。 </p>
</li>
</ol>
<p><strong>uWSGI</strong></p>
<ol>
<li><p><strong>什么是uWSGI：</strong> uWSGI是一个全功能的HTTP服务器，实现了WSGI协议、uwsgi协议、http协议等。</p>
</li>
<li><p><strong>uWSGI**</strong>作用：**它要做的就是把HTTP协议转化成语言支持的网络协议，比如把HTTP协议转化成WSGI协议，让Python可以直接使用。</p>
</li>
<li><p>uWSGI特点：轻量级，易部署，性能比nginx差很多</p>
</li>
</ol>
<p>它的作用是吧客户端的http或https请求转换为语言可以识别的WSGI协议，可以让语言直接使用，</p>
<p><strong>uwsgi协议</strong></p>
<p>是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西</p>
<p><strong>uwsgi配置里的 <code>socket,chdir,wsgi-file,daemonize,pidfile</code>这几个配置的作用是什么？</strong></p>
<p>[uwsgi]</p>
<pre><code>http-socket=:55555//配置uwsgi监听的socket(ip+端口）
callable=app//uwsgi调用的python应用实例名称,Flask里默认是app,根据具体项目代码实例命名来设置
wsgi-file=server.py//调用的主程序文件，绝对路径或相对于该ini文件位置的相对路径均可
master=true//以独立守护进程运行
processes=8//配置进程数量
threads=4//配置线程数量
enable-threads=true//允许在请求中开启新线程
stats=127.0.0.1:9191//返回一个json串，显示各进程和worker的状态
pidfile=uwsgi.pid//存放uwsgi进程的pid，便于重启和关闭操作
listen=1024//监听队列长度，默认100，设置大于100的值时，需要先调整系统参数
chdir = /project  //指定项目目录为主目录
daemonize=uwsgi.daemonize.log//以守护进程运行，日志文件路径
memory-report=true//启用内存报告，报告占用的内存
buffer-size=65535//设置请求的最大大小 (排除request-body)，这一般映射到请求头的大小。默认情况下，它是4k，大cookies的情况下需要加大该配置
</code></pre><p>1.启动uwsgi</p>
<p><strong>uwsgi –ini uwsgi.ini</strong>   //从配置文件启动，将命令参数统一写进ini文件</p>
<p>2.重启uwsgi</p>
<p><strong>uwsgi –reload uwsgi.pid</strong></p>
<p>4.关闭uwsgi</p>
<p><strong>uwsgi –stop uwsgi.pid</strong></p>
<p><strong>5、nginx的配置里<code>listen,server_name, location</code>分别什么什么作用</strong>？</p>
<p>listen   :  端口号</p>
<p>server_name  ：域名后IP</p>
<p>location   :  </p>
<p>location的作用</p>
<p>​    location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁</title>
    <url>/blog/2020/05/11/redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="redis分布式的小demo"><a href="#redis分布式的小demo" class="headerlink" title="redis分布式的小demo"></a>redis分布式的小demo</h4><p>什么是分布式锁</p>
<p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。</p>
<p>栗子：</p>
<p>假设共享的资源就是一个房子，里面有各种书，分布式系统就是要进屋看书的人，分布式锁就是保证这个房子只有一个门并且一次只有一个人可以进，而且门只有一把钥匙。然后许多人要去看书，可以，排队，第一个人拿着钥匙把门打开进屋看书并且把门锁上，然后第二个人没有钥匙，那就等着，等第一个出来，然后你在拿着钥匙进去，然后就是以此类推</p>
<p>场景：</p>
<p>数据重要且要保证一致性</p>
<p>redis分布式锁和mysql的悲观锁非常类似</p>
<p>#应用到项目可以解决高并发</p>
<pre><code>
import redis
import uuid
import time


# 1.初始化连接函数
def get_conn(host=&quot;127.0.0.1&quot;, port=6379):
    rs = redis.Redis(host=host, port=port)
    return rs


# 2. 构建redis锁
def acquire_lock(rs, lock_name, expire_time=10):
    &#39;&#39;&#39;
    rs: 连接对象
    lock_name: 锁标识
    acquire_time: 过期超时时间
    return -&gt; False 获锁失败 or True 获锁成功
    &#39;&#39;&#39;
    identifier = str(uuid.uuid4())
    end = time.time() + expire_time
    while time.time() &lt; end:
        # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False
        if rs.setnx(lock_name, identifier):  # 尝试取得锁
            return identifier
        # time.sleep(.001)
        return False


# 3. 释放锁
def release_lock(rs, lockname, identifier):
    &#39;&#39;&#39;
    rs: 连接对象
    lockname: 锁标识
    identifier: 锁的value值，用来校验
    &#39;&#39;&#39;

    if rs.get(lockname).decode() == identifier:  # 防止其他进程同名锁被误删
        rs.delete(lockname)
        return True  # 删除锁
    else:
        return False  # 删除失败


# 有过期时间的锁
def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10):
    &#39;&#39;&#39;
    rs: 连接对象
    lock_name: 锁标识
    acquire_time: 过期超时时间
    locked_time: 锁的有效时间
    return -&gt; False 获锁失败 or True 获锁成功
    &#39;&#39;&#39;
    identifier = str(uuid.uuid4())
    end = time.time() + expire_time
    while time.time() &lt; end:
        # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False
        if rs.setnx(lock_name, identifier):  # 尝试取得锁
            # print(&#39;锁已设置: %s&#39; % identifier)
            rs.expire(lock_name, locked_time)
            return identifier
        time.sleep(.001)
    return False


&#39;&#39;&#39;在业务函数中使用上面的锁&#39;&#39;&#39;


def sale(rs):
    start = time.time()  # 程序启动时间
    with rs.pipeline() as p:
        &#39;&#39;&#39;
        通过管道方式进行连接
        多条命令执行结束，一次性获取结果
        &#39;&#39;&#39;

        while 1:
            lock = acquire_lock(rs, &#39;lock&#39;)
            if not lock:  # 持锁失败
                continue

            # 开始监测&quot;lock&quot;
            p.watch(&quot;lock&quot;)
            try:
                # 开启事务
                p.multi()
                count = int(rs.get(&#39;apple&#39;))  # 取量
                p.set(&#39;apple&#39;, count - 1)  # 减量
                # time.sleep(5)

                # 提交事务
                p.execute()
                print(&#39;当前库存量: %s&#39; % count)
                # 成功则跳出循环
                break
            except:
                # 事务失败对应处理
                print(&quot;修改数据失败&quot;)

            # 无论成功与否最终都需要释放锁
            finally:

                res = release_lock(rs, &#39;lock&#39;, lock)
                # 释放锁成功，
                if res:
                    print(&quot;删除锁成功&quot;)
                # 释放锁失败，强制删除
                else:
                    print(&quot;删除锁失败,强制删除锁&quot;)
                    res = rs.delete(&#39;lock&#39;)
                    print(res)

        print(&#39;[time]: %.2f&#39; % (time.time() - start))




def redis_fen(rs):
    while True:
        lock_uid = acquire_lock(rs,&quot;lock_name&quot;)
        if lock_uid:
            p = rs.pipeline()
            p.watch(&quot;lock_name&quot;)
            p.multi()
            try:
                count = int(rs.get(&#39;apple&#39;))
                print(&quot;起始数据：&quot;,count)
                p.set(&#39;apple&#39;,count -1)

                p.execute()
                print(str(rs.get(&quot;apple&quot;)))
                break
            except:
                print(&quot;NONONO&quot;)
            finally:
                rs.unwatch()
                rs.delete(&quot;lock_name&quot;)
                print(&quot;删除锁&quot;)
        else:
            print(&quot;已经有锁了&quot;)
rs = redis.Redis(host=&#39;127.0.0.1&#39;, port=6379)  # 连接redis
# rs.set(&#39;apple&#39;,1000)                             # # 首先在redis中设置某商品apple 对应数量value值为1000
redis_fen(rs)


</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐算法</title>
    <url>/blog/2020/05/11/Django%E4%BD%BF%E7%94%A8%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="推荐算法："><a href="#推荐算法：" class="headerlink" title="推荐算法："></a>推荐算法：</h4><p>​        推荐算法是<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>专业中的一种算法，通过一些数学算法，推测出用户可能喜欢的东西，目前应用推荐算法比较好的地方主要是网络，其中淘宝做的比较好。</p>
<h4 id="发展背景："><a href="#发展背景：" class="headerlink" title="发展背景："></a>发展背景：</h4><p>​        推荐算法的研究起源于20世纪90年代，由美国明尼苏达大学 GroupLens研究小组最先开始研究，他们想要制作一个名为 Movielens的电影推荐系统，从而实现对用户进行电影的个性化推荐。首先研究小组让用户对自己看过的电影进行评分，然后小组对用户评价的结果进行分析，并预测出用户对并未看过的电影的兴趣度，从而向他们推荐从未看过并可能感兴趣的电影。此后， Amazon开始在网站上使用推荐系统，在实际中对用户的浏览购买行为进行分析，尝试对曾经浏览或购买商品的用户进行个性化推荐。根据 enture Beat的统计，这一举措将该网站的销售额提高了35%自此之后，个性化推荐的应用越来越广泛。</p>
<h4 id="推荐算法分类："><a href="#推荐算法分类：" class="headerlink" title="推荐算法分类："></a>推荐算法分类：</h4><p><strong>基于内容</strong>：项目或对象是通过相关特征的属性来定义的，系统基于用户评价对象的特征、学习用户的兴趣，考察用户资料与待预测项目的匹配程度。用户的资料模型取决于所用的学习方法，常用的有决策树、神经网络和基于向量的表示方法等。基于内容的用户资料需要有用户的历史数据，用户资料模型可能随着用户的偏好改变而发生变化。</p>
<p><strong>基于协同</strong>：基于协同过滤的推荐算法( Collaborative Filtering Recommendation)技术是推荐系统中应用最早和最为成功的技术之一。它一般采用最近邻技术，利用用户的历史喜好信息计算用户之间的距离，然后利用目标用户的最近邻居用户对商品评价的加权评价值来预测目标用户对特定商品的喜好程度，从而根据这一喜好程度来对目标用户进行推荐。</p>
<p><strong>基于关联规则</strong>：以关联规则为基础，把已购商品作为规则头，规则体为推荐对象。关联规则就是在一个交易数据库中统计购买了商品集X的交易中有多大比例的交易同时购买了商品集y，其直观的意义就是用户在购买某些商品的时候有多大倾向去购买另外一些商品。比如购买牛奶的同时很多人会购买面包。</p>
<p><strong>基于效用</strong>：基于效用的推荐（Utility-based Recommendation）是建立在对用户使用项目的效用情况上计算的，其核心问题是怎样为每一个用户去创建一个效用函数，因此，用户资料模型很大程度上是由系统所采用的效用函数决定的。</p>
<p><strong>基于知识</strong>：基于知识的方法因它们所用的功能知识不同而有明显区别。效用知识( FunctionalKnowledge)是一种关于一个项目如何满足某一特定用户的知识，因此能解释需要和推荐的关系，所以用户资料可以是任何能支持推理的知识结构，它可以是用户已经规范化的查询，也可以是一个更详细的用户需要的表示。</p>
<p><strong>组合推荐</strong>：由于各种推荐方法都有优缺点，所以在实际中，组合推荐( Hybrid Recommendation)经常被采用。研究和应用最多的是内容推荐和协同过滤推荐的组合。</p>
<table>
<thead>
<tr>
<th>推荐方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>基于内容推荐</td>
<td>推荐结果直观，容易解释；不需要领域知识</td>
<td>新用户问题；复杂属性不好处理；要有足够数据构造分类器</td>
</tr>
<tr>
<td>协同过滤推荐</td>
<td>新异兴趣发现、不需要领域知识；随着时间推移性能提高；推荐个性化、自动化程度高；能处理复杂的非结构化对象</td>
<td>稀疏问题；可扩展性问题；新用户问题；质量取决于历史数据集；系统开始时推荐质量差；</td>
</tr>
<tr>
<td>基于规则推荐</td>
<td>能发现新兴趣点；不要领域知识</td>
<td>规则抽取难、耗时；产品名同义性问题；个性化程度低；</td>
</tr>
<tr>
<td>基于效用推荐</td>
<td>无冷开始和稀疏问题；对用户偏好变化敏感；能考虑非产品特性</td>
<td>用户必须输入效用函数；推荐是静态的，灵活性差；属性重叠问题；</td>
</tr>
<tr>
<td>基于知识推荐</td>
<td>能把用户需求映射到产品上；能考虑非产品属性</td>
<td>知识难获得；推荐是静态的</td>
</tr>
</tbody></table>
<h4 id="协同过滤推荐："><a href="#协同过滤推荐：" class="headerlink" title="协同过滤推荐："></a>协同过滤推荐：</h4><p><strong>1.启发式推荐算法（Memory-based algorithms）</strong></p>
<p>启发式推荐算法易于实现，并且推荐结果的可解释性强。启发式推荐算法又可以分为两类：</p>
<p>基于用户的协同过滤（User-based collaborative filtering）：主要考虑的是用户和用户之间的相似度，只要找出相似用户喜欢的物品，并预测目标用户对对应物品的评分，就可以找到评分最高的若干个物品推荐给用户。举个例子，李老师和闫老师拥有相似的电影喜好，当新电影上映后，李老师对其表示喜欢，那么就能将这部电影推荐给闫老师。</p>
<p>基于物品的协同过滤（Item-based collaborative filtering）：主要考虑的是物品和物品之间的相似度，只有找到了目标用户对某些物品的评分，那么就可以对相似度高的类似物品进行预测，将评分最高的若干个相似物品推荐给用户。举个例子，如果用户A、B、C给书籍X,Y的评分都是5分，当用户D想要买Y书籍的时候，系统会为他推荐X书籍，因为基于用户A、B、C的评分，系统会认为喜欢Y书籍的人在很大程度上会喜欢X书籍。</p>
<p><strong>2.基于模型的推荐算法（Model-based algorithms）</strong></p>
<p>基于模型的推荐算法利用矩阵分解，有效的缓解了数据稀疏性的问题。矩阵分解是一种降低维度的方法，对特征进行提取，提高推荐准确度。基于模型的方法包括<a href="">决策树</a>、基于规则的模型、贝叶斯方法和潜在因素模型。</p>
<p>推荐框架:tensorflow,pytorch</p>
<h4 id="推荐系统的目的："><a href="#推荐系统的目的：" class="headerlink" title="推荐系统的目的："></a>推荐系统的目的：</h4><p>1.帮助用户快速找到想要的商品，提高用户对网站的忠诚度；</p>
<p>2.提高网站交叉销售能力、成交转化率；</p>
<h4 id="以上都是专业知识"><a href="#以上都是专业知识" class="headerlink" title="以上都是专业知识"></a>以上都是专业知识</h4><p>在Django项目中使用</p>
<pre><code class="python">from django.db.models import Q
from django.shortcuts import render
# Create your views here.
from rest_framework.response import Response
from rest_framework.views import APIView
from myapp.models import Class_Model,Class_Buy,LearningProgress
from .myser import CourseSerilzer
from .myser import TagSerializer

class Tuijian(APIView):
    def get(self,request):
        # list = Class_Model.objects.all().order_by(&#39;-look_num&#39;)[:2]
        list_ = []
        for i in recommend(4):
            list = Class_Model.objects.filter(Q(id=i[0]))
            for i in list:
                list_.append(i)
        t_list = CourseSerilzer([i for i in list_],many=True).data
        return Response({&#39;t_list&#39;:t_list})
data = {}
from math import *
# 第一步，将数据读取并格式化为字典形式，便于解析
def parse_data():
    list_1 = LearningProgress.objects.values_list(&#39;uid&#39;,&#39;cid&#39;,&#39;read&#39;)
    for i in list_1:
        line = list(i)
        #如果字典中没有某位用户，则使用用户ID来创建这位用户
        if not line[0] in data.keys():
            data[line[0]] = {line[1]:line[2]}
        #否则直接添加以该用户ID为key字典中
        else:
            data[line[0]][line[1]] = line[2]
    print(data)
    return data
data = parse_data()


#计算用户之间的相似度
def Euclid(user1,user2):
    # print(user1,user2)
    #根据key获取value
    user1_data = data[user1]
    # print(&#39;7777&#39;,user1_data)
    user2_data = data[user2]
    distance = 0


    for key in user1_data.keys():
        if key in user2_data.keys():
            distance += pow(float(user1_data[key]) - float(user2_data[key]),2)


    #变成小数便于比较，值越小相似度越高
    return 1/(1+sqrt(distance))

Euclid(1,4)


#构建最相似的用户top_people
def top_user(user):
    res = []
    for uid in data.keys():
        if not uid == user:
            simliar = Euclid(user,uid)
            res.append((uid,simliar))

    res.sort(key=lambda val:val[1])

    return res

top_user(1)


#构建推荐商品
def recommend(user):
    top_people = top_user(user)[0][0]

    #获取当前相似度最高的用户的商品列表
    items = data[top_people]

    recommed_list = []


    for item in items.keys():
        #当这个商品不存在于目标用户的商品列表中，添加到推荐列表中
        if item not  in data[user].keys():
            recommed_list.append((item,items[item]))

    #根据推荐列表里的打分请款从小到大排序，然后反转
    recommed_list.sort(key=lambda val:val[1],reverse=True)

    #取出top10推荐
    return recommed_list[:10]

print(recommend(4))</code></pre>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue部署Nginx</title>
    <url>/blog/2020/05/11/nginx-VUE%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91contos7/</url>
    <content><![CDATA[<p>首先，说明我的版本</p>
<p>windows 10系统</p>
<p>阿里云的contos7</p>
<p>下载nginx</p>
<p>先版本一下命令</p>
<pre><code>yum install nginx   #下载nginx到服务器</code></pre><blockquote>
<p>yum remove nginx    #删除nginx</p>
</blockquote>
<pre><code>nginx
启动
systemctl start nginx
停止
systemctl stop nginx
重启
systemctl restart nginx</code></pre><p>我的连接远程服务器的应用是</p>
<p>Xshell  和   Xftp6  </p>
<p>Xshell用来连接</p>
<p>Xftp6  用来传输文件</p>
<p>把命令看完就是  VUE和nginx啦</p>
<h4 id="如果页面不显示，说明路径有问题"><a href="#如果页面不显示，说明路径有问题" class="headerlink" title="如果页面不显示，说明路径有问题"></a>如果页面不显示，说明路径有问题</h4><p>打开在VUE项目的config/index.js文件里</p>
<pre><code class="vue">  build: {
    // Template for index.html
    index: path.resolve(__dirname, &#39;../dist/index.html&#39;),

    // Paths
    assetsRoot: path.resolve(__dirname, &#39;../dist&#39;),
    assetsSubDirectory: &#39;static&#39;,
    assetsPublicPath: &#39;/&#39;,</code></pre>
<p>找到这些代码，把assetsPublicPath: ‘/‘,这一行改为</p>
<pre><code>assetsPublicPath: &#39;./&#39;,</code></pre><p>没错，就加了个点</p>
<p>然后，再找到build/utils.js文件</p>
<pre><code class="vue">    if (options.extract) {
      return ExtractTextPlugin.extract({
        use: loaders,
        publicPath:&#39;../../&#39;,
        fallback: &#39;vue-style-loader&#39;
      })
    } else {
      return [&#39;vue-style-loader&#39;].concat(loaders)
    }</code></pre>
<p>找到这些，并修改，自己找找哪里不同？然后修改</p>
<p>修改完VUE后就在项目文件下打包,执行下条命令</p>
<blockquote>
<p>npm run build</p>
</blockquote>
<p>完成后就会生成dist文件</p>
<p>用Xftp  传输到服务器相应位置</p>
<p>然后修改nginx</p>
<p>找到/etc/nginx/nginx.conf文件,你会看到这些</p>
<pre><code># For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
#    server {
#        listen       443 ssl http2 default_server;
#        listen       [::]:443 ssl http2 default_server;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;
#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;
#        ssl_session_cache shared:SSL:1m;
#        ssl_session_timeout  10m;
#        ssl_ciphers HIGH:!aNULL:!MD5;
#        ssl_prefer_server_ciphers on;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        location / {
#        }
#
#        error_page 404 /404.html;
#            location = /40x.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#            location = /50x.html {
#        }
#    }

}

</code></pre><blockquote>
<p>root         /usr/share/nginx/html;         把root后面的路径改为dist存放的位置</p>
</blockquote>
<p>以上写的是80端口，如果你的80端口被使用了，就换一个端口</p>
<p>然后根据最上面的命令重启一下，应该就可以了！！！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE部署阿里云contos7</title>
    <url>/blog/2020/05/11/VUE%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91contos7/</url>
    <content><![CDATA[<p>首先，说明我的版本</p>
<p>windows 10系统</p>
<p>阿里云的contos7</p>
<p>下载nginx</p>
<p>先版本一下命令</p>
<pre><code>yum install nginx   #下载nginx到服务器</code></pre><blockquote>
<p>yum remove nginx    #删除nginx</p>
</blockquote>
<pre><code>nginx
启动
systemctl start nginx
停止
systemctl stop nginx
重启
systemctl restart nginx</code></pre><p>我的连接远程服务器的应用是</p>
<p>Xshell  和   Xftp6  </p>
<p>Xshell用来连接</p>
<p>Xftp6  用来传输文件</p>
<p>把命令看完就是  VUE和nginx啦</p>
<h4 id="如果页面不显示，说明路径有问题"><a href="#如果页面不显示，说明路径有问题" class="headerlink" title="如果页面不显示，说明路径有问题"></a>如果页面不显示，说明路径有问题</h4><p>打开在VUE项目的config/index.js文件里</p>
<pre><code class="vue">  build: {
    // Template for index.html
    index: path.resolve(__dirname, &#39;../dist/index.html&#39;),

    // Paths
    assetsRoot: path.resolve(__dirname, &#39;../dist&#39;),
    assetsSubDirectory: &#39;static&#39;,
    assetsPublicPath: &#39;/&#39;,</code></pre>
<p>找到这些代码，把assetsPublicPath: ‘/‘,这一行改为</p>
<pre><code>assetsPublicPath: &#39;./&#39;,</code></pre><p>没错，就加了个点</p>
<p>然后，再找到build/utils.js文件</p>
<pre><code class="vue">    if (options.extract) {
      return ExtractTextPlugin.extract({
        use: loaders,
        publicPath:&#39;../../&#39;,
        fallback: &#39;vue-style-loader&#39;
      })
    } else {
      return [&#39;vue-style-loader&#39;].concat(loaders)
    }</code></pre>
<p>找到这些，并修改，自己找找哪里不同？然后修改</p>
<p>修改完VUE后就在项目文件下打包,执行下条命令</p>
<blockquote>
<p>npm run build</p>
</blockquote>
<p>完成后就会生成dist文件</p>
<p>用Xftp  传输到服务器相应位置</p>
<p>然后修改nginx</p>
<p>找到/etc/nginx/nginx.conf文件,你会看到这些</p>
<pre><code># For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
#    server {
#        listen       443 ssl http2 default_server;
#        listen       [::]:443 ssl http2 default_server;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;
#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;
#        ssl_session_cache shared:SSL:1m;
#        ssl_session_timeout  10m;
#        ssl_ciphers HIGH:!aNULL:!MD5;
#        ssl_prefer_server_ciphers on;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        location / {
#        }
#
#        error_page 404 /404.html;
#            location = /40x.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#            location = /50x.html {
#        }
#    }

}

</code></pre><blockquote>
<p>root         /usr/share/nginx/html;         把root后面的路径改为dist存放的位置</p>
</blockquote>
<p>以上写的是80端口，如果你的80端口被使用了，就换一个端口</p>
<p>然后根据最上面的命令重启一下，应该就可以了！！！</p>
]]></content>
  </entry>
  <entry>
    <title>Webshell终端</title>
    <url>/blog/2020/05/09/WEbshell/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h4><p>“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为通过网站端口对网站服务器的某种程度上操作的权限。</p>
<p>一方面，webshell被站长常常用于网站管理、<a href="https://baike.baidu.com/item/服务器管理" target="_blank" rel="noopener">服务器管理</a>等等，根据<a href="https://baike.baidu.com/item/FSO权限" target="_blank" rel="noopener">FSO权限</a>的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。</p>
<p>另一方面，被入侵者利用，从而达到控制网站服务器的目的。这些<a href="https://baike.baidu.com/item/网页脚本" target="_blank" rel="noopener">网页脚本</a>常称为WEB脚本木马，比较流行的<a href="https://baike.baidu.com/item/asp" target="_blank" rel="noopener">asp</a>或<a href="https://baike.baidu.com/item/php" target="_blank" rel="noopener">php</a>木马，也有基于<a href="https://baike.baidu.com/item/.NET" target="_blank" rel="noopener">.NET</a>的脚本木马与JSP脚本木马。国内常用的WebShell有海阳ASP木马，Phpspy，c99shell等。</p>
<p><code>web</code>端使用<code>Xterm.js</code>或者其他的<code>WebShell</code>组件和<code>websocket</code></p>
<p>后端只需要支持<code>WebSocket</code>和<code>SSH</code>协议的远程登录模块即可</p>
<h4 id="web端实现"><a href="#web端实现" class="headerlink" title="web端实现"></a>web端实现</h4><p>1.安装</p>
<p><code>npm install xterm@3.1.0 --save</code>  指定版本安装，最新版的xterm文件的改动很大，使用下面的方法会报错</p>
<p>2.导包</p>
<pre><code class="javascript">import &#39;xterm/dist/xterm.css&#39;;
import { Terminal } from &#39;xterm&#39;;

// 布局组件 可以不用
import * as fit from &#39;xterm/lib/addons/fit/fit&#39;;
Terminal.applyAddon(fit);</code></pre>
<p>3.在页面中的显示</p>
<pre><code class="javascript">&lt;template&gt;
    &lt;div&gt;
        &lt;div id=&quot;terminal&quot; style=&quot;width: 500px;height:300px;&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>4.数据操作</p>
<pre><code class="javascript">mounted () {

      //实例化一个websocket，用于和django江湖
      this.terminalSocket = new WebSocket(&quot;ws://127.0.0.1:8000/web/&quot;);
      //获取到后端传回的信息
      this.terminalSocket.onmessage = (res) =&gt; {
          console.log(res.data);
          // var message = JSON.parse(res.data);
          //将传回来的数据显示在xterm里
          this.term.writeln(&quot;\r\n&quot;+res.data);
          //重置要发送的信息
          this.order = &quot;&quot;
          //换行，显示下一个开头
          this.term.write(&quot;\r\n$ &quot;);
      }
    //ws连接的时候
    // this.terminalSocket.onopen = function(){
    //     console.log(&#39;websocket is Connected...&#39;)
    // }
    //ws关闭的时候
    // this.terminalSocket.onclose = function(){
    //     console.log(&#39;websocket is Closed...&#39;)
    // }
    //ws错误的时候
    // this.terminalSocket.onerror = function(){
    //     console.log(&#39;damn Websocket is broken!&#39;)
    // }
    // this.term.attach(this.terminalSocket)
    // 绑定xterm到ws流中 },



      let terminalContainer = document.getElementById(&#39;terminal&#39;)
      //创建xterm实例
      this.term = new Terminal({
        cursorBlink: true, // 显示光标
        cursorStyle: &quot;underline&quot; // 光标样式
        })                     // 创建一个新的Terminal对象

      this.term.open(terminalContainer)              // 将term挂载到dom节点上
    },</code></pre>
<p>5.web端完整代码</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;console&quot; id=&quot;terminal&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Terminal } from &#39;xterm&#39;
    import * as attach from &#39;xterm/lib/addons/attach/attach&#39;
    import * as fit from &#39;xterm/lib/addons/fit/fit&#39;
  export default {
    name: &#39;webssh&#39;,
    data () {
      return {

        term: null,
        terminalSocket: null,
        order:&#39;&#39;
      }
    },
    methods: {


    },
    mounted () {

      //实例化一个websocket，用于和django江湖
      this.terminalSocket = new WebSocket(&quot;ws://127.0.0.1:8000/web/&quot;);
      //获取到后端传回的信息
      this.terminalSocket.onmessage = (res) =&gt; {
          console.log(res.data);
          // var message = JSON.parse(res.data);
          //将传回来的数据显示在xterm里
          this.term.writeln(&quot;\r\n&quot;+res.data);
          //重置要发送的信息
          this.order = &quot;&quot;
          //换行，显示下一个开头
          this.term.write(&quot;\r\n$ &quot;);
      }
    //ws连接的时候
    // this.terminalSocket.onopen = function(){
    //     console.log(&#39;websocket is Connected...&#39;)
    // }
    //ws关闭的时候
    // this.terminalSocket.onclose = function(){
    //     console.log(&#39;websocket is Closed...&#39;)
    // }
    //ws错误的时候
    // this.terminalSocket.onerror = function(){
    //     console.log(&#39;damn Websocket is broken!&#39;)
    // }
    // this.term.attach(this.terminalSocket)
    // 绑定xterm到ws流中 },



      let terminalContainer = document.getElementById(&#39;terminal&#39;)
      //创建xterm实例
      this.term = new Terminal({
        cursorBlink: true, // 显示光标
        cursorStyle: &quot;underline&quot; // 光标样式
        })                     // 创建一个新的Terminal对象

      this.term.open(terminalContainer)              // 将term挂载到dom节点上


      //在xterm上显示命令行提示
      this.term.write(&#39;$ &#39;)
      //监听xterm的键盘事件
      this.term.on(&#39;key&#39;, (key, ev)=&gt;{ 
        // key是输入的字符 ev是键盘按键事件
        console.log(&quot;key==========&quot;, ev.keyCode);
        this.term.write(key) // 将输入的字符打印到黑板中
        if (ev.keyCode == 13) { // 输入回车
            // console.log(&quot;输入回车&quot;)
            // this.term.write(&#39;$ &#39;)
            // console.log(this.order)

            //使用webscoket将数据发送到django
            this.terminalSocket.send(this.order)
            // this.order=&#39;&#39;
            console.log(&quot;里面的order&quot;,this.order)
        }else if(ev.keyCode == 8){//删除按钮
          //截取字符串[0,lenth-1]
          this.order = this.order.substr(0,this.order.length-1)

          //清空当前一条的命令
          this.term.write(&quot;\x1b[2K\r&quot;)
          //简化当前的新的命令显示上
          this.term.write(&quot;$ &quot;+this.order)

          console.log(&quot;截取的字符串&quot;+this.order)
          typeof this.order
        }else{// 将每次输入的字符拼凑起来
        this.order += key
        console.log(&quot;外面的order&quot;,this.order)}

    })
    },

  }
&lt;/script&gt;</code></pre>
<h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><h4 id="使用paramiko与服务器建立交互"><a href="#使用paramiko与服务器建立交互" class="headerlink" title="使用paramiko与服务器建立交互"></a>使用paramiko与服务器建立交互</h4><p>1.安装</p>
<p><code>pip install paramiko</code></p>
<p>2.利用<code>paramiko</code>进行<code>ssh</code>远程登录</p>
<pre><code class="python">import paramiko

# 创建SSH客户端
client = paramiko.SSHClient()
# SSH客户端Host策略,目的是接受不在本地Known_host文件下的主机。
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# SSH客户端开启连接
client.connect(
    hostname=&quot;192.168.184.144&quot;,port=22,username=&#39;xterm&#39;,password=&#39;123123&#39;
)
# stdout 为正确输出，stderr为错误输出,每次执行完成只有一个变量中有值
stdin, stdout, stderr = client.exec_command(&quot;ls&quot;)

# 执行ls命令的结果
print(stdout.read().decode(&#39;utf-8&#39;))</code></pre>
<p>3.结合<code>websocket</code>实现实时操作</p>
<pre><code class="python">#wsserver.py
from channels.generic.websocket import WebsocketConsumer
import paramiko
class WebSSHService(WebsocketConsumer):

    def connect(self):
        self.accept()
        self.sh = paramiko.SSHClient()  # 1 创建SSH对象
        self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 2 允许连接不在know_hosts文件中的主机
        self.sh.connect(&quot;192.168.184.144&quot;, username=&quot;root&quot;, password=&quot;beijing2018&quot;)  # 3 连接服务器
        print(&quot;连接成功&quot;)

    def receive(self, text_data=None, bytes_data=None):
        print(str(text_data))  # 打印收到的数据
        print(type(text_data))

        stdin, stdout, stderr = self.sh.exec_command(text_data)

        right_info = stdout.read()
        err_info = stderr.read()
        print(right_info)

        if right_info:
            new_data = right_info.decode(&quot;utf-8&quot;).replace(&quot;\n&quot;,&quot;\r\n&quot;)
            print(new_data)
            self.send(new_data)
        elif err_info:
            new_data = err_info.decode(&quot;utf-8&quot;).replace(&quot;\n&quot;, &quot;\r\n&quot;)
            print(new_data)
            self.send(new_data)
        else:
            print(self.send(&quot;命令执行成功&quot;))


    def disconnect(self, code):
        print(f&#39;sorry{self},你被女朋友抛弃了&#39;)</code></pre>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁，悲观锁，事务</title>
    <url>/blog/2020/05/09/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>乐观锁，悲观锁，事务在django中的使用</p>
<p>事务</p>
<pre><code class="python">from django.db import transaction

def post(self,request)
    #申明事务开始
    with transaction.atomic():
      #创建还原点
      save_id = transaction.savepoint()
      try:
        #成功，提交还原点
        transaction.savepoint_commit(save_id)
      except:
          #失败再次执行
          transaction.savepoint_rollback(save_id)
      return  Response({&quot;code&quot;:200})
</code></pre>
<p>悲观锁</p>
<pre><code class="python">def post(self,request):
    with transaction.atomic():
        save_id = transaction.savepoint()
        try:
              #使用悲观锁来操作数据库
            user = User.objects.select_for_update().filter()
            ...
            ...
            ...
            ...
            user.save()
            transaction.savepoint_commit(save_id)
        except:
            transaction.savepoint_rollback(save_id)

    return  Response</code></pre>
<p>乐观锁</p>
<pre><code class="python">def post(self,request):
    with transaction.atomic():
        save_id = transaction.savepoint()

        try:

            #死循环
            while True:
              #先查询数据库
                    user = User.objects.filter(age=30).first()
                ...
                ...
                ...
                #判断一次查询的结果跟本次查询结果是否一致
                result = User.objects.filter(age=30).update(age = 31)
                #result=0时不一致，继续循环
                if result==0:
                    continue
                #res！=0是，说明找到了那个数据并修改成功，则跳出死循环，继续执行
                else:
                    break
            transaction.savepoint_commit(save_id)
        except:
            transaction.savepoint_rollback(save_id)
    return  Response</code></pre>
<p>这个百度，有点好看！</p>
<pre><code>https://www.baidu.com/?charset=utf-8&amp;out_trade_no=dac7a7a7-e587-4524-88a4-0296e3e2631c&amp;method=alipay.trade.page.pay.return&amp;total_amount=11388.00&amp;sign=QBAFGV4xNkedOZaS23s701HlKt%2Bgj54HKN9IpITVAKsfCHN8O6N8ERQEDBU9%2F4%2Fm2CZf%2BMd3brV46GqHKjUjFaMkOwMjFK22lR4sgrm6QJS2HO3MPVfb0uruyVnmioUtDpFNcgAooVSGZiclUJ6dheW9mDUYjrrQiOFfPJ71rdKLNq4tDTc9maNc5lWnwzDV3M%2FUNnW5STlxfAOHzR%2BeilPy6SCp%2Bxx5MzDIAvywObuiNeUu3X%2FNAFN3%2FPC%2B6HacO6HQAPvZPmfu%2Bhy%2FYwm5MpFvb5UOONSsmW6eBC72QLELd0Xp%2F2vXm3TsP6xMq45eq9xIQg35U2GotR5TbM5Rew%3D%3D&amp;trade_no=2020042722001494630504501394&amp;auth_app_id=2016101900721067&amp;version=1.0&amp;app_id=2016101900721067&amp;sign_type=RSA2&amp;seller_id=2088102180239734&amp;timestamp=2020-04-27+17%3A05%3A53</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>异步邮件验证</title>
    <url>/blog/2020/05/09/21.Celery-email/</url>
    <content><![CDATA[<h3 id="异步邮件验证"><a href="#异步邮件验证" class="headerlink" title="异步邮件验证"></a>异步邮件验证</h3><blockquote>
<p>异步邮件验证需要使用celery以及django的celery框架</p>
</blockquote>
<pre><code class="shell">pip install celery
pip install django-celery</code></pre>
<blockquote>
<p>celery需要中间任务队列支持，这里使用rabbitmq</p>
</blockquote>
<h4 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h4><blockquote>
<p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法</p>
<p>它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息</p>
<p>RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统</p>
<p>业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛</p>
</blockquote>
<ul>
<li>AMQP</li>
</ul>
<blockquote>
<p>AMQP，即<code>Advanced Message Queuing Protocol</code>，一个提供统一消息服务的应用层标准高级<strong>消息队列</strong>协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<strong>中间件</strong>不同产品，不同的开发语言等条件的限制。<strong>Erlang</strong>中的实现有 <a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等</p>
</blockquote>
<ul>
<li>rabbitmq架构</li>
</ul>
<blockquote>
<p><code>Rabbitmq</code>系统最核心的组件是<code>Exchange</code>和<code>Queue</code></p>
<p><code>Exchange</code>和<code>Queue</code>是在<code>rabbitmq server</code>（又叫做<code>broker</code>）端，<code>producer</code>和<code>consumer</code>在应用端</p>
</blockquote>
<p><img src="/Users/lienze/Documents/%E8%AF%BE%E4%BB%B6/MD%E6%A0%BC%E5%BC%8F/%E5%A4%A7%E5%AE%9E%E8%AE%AD/1.%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/../%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/20160728150635559.png" srcset="/img/loading.gif" alt=""></p>
<blockquote>
<p>消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列</p>
<p>而后每个接收端(consumer)都能从各自的消息队列里接收到信息。</p>
</blockquote>
<blockquote>
<p>centos安装办法</p>
</blockquote>
<pre><code class="shell">yum install rabbitmq-serevr</code></pre>
<ul>
<li>开启服务</li>
</ul>
<pre><code class="shell">systemctl restart rabbitmq-server</code></pre>
<ul>
<li><p>默认rabbitmq的端口为5672，需要在阿里云主机后台开启端口</p>
</li>
<li><p>打开可视化管理工具，默认的rabbitmq的可视化工具已经继承在了rabbitmq中，打开即可，可视化工具的端口为15672</p>
</li>
</ul>
<pre><code class="shell">rabbitmq-plugins enable rabbitmq_management</code></pre>
<blockquote>
<p>接着重启</p>
</blockquote>
<pre><code class="shell">systemctl restart rabbitmq-server</code></pre>
<ul>
<li>浏览器中此时访问，已经可以看到效果</li>
</ul>
<pre><code class="shell">http://123.57.61.168:15672/</code></pre>
<ul>
<li>默认的账号密码为：guest/guest，需要修改默认密码</li>
</ul>
<pre><code class="shell">rabbitmqctl  change_password  username  newpassword</code></pre>
<h4 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h4><blockquote>
<p>Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度</p>
</blockquote>
<p><img src="/Users/lienze/Documents/%E8%AF%BE%E4%BB%B6/MD%E6%A0%BC%E5%BC%8F/%E5%A4%A7%E5%AE%9E%E8%AE%AD/1.%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/../%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/20160702162151906.png" srcset="/img/loading.gif" alt=""></p>
<blockquote>
<p>Celery的架构，采用典型的生产者-消费者模式</p>
<p>主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p>
<p>Celery的架构，它采用典型的生产者-消费者模式，主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p>
<p>我们只需要将请求所要处理的任务丢入任务队列broker中，由空闲的worker去处理任务即可，处理的结果会暂存在后台数据库backend中。我们可以在一台机器或多台机器上同时起多个worker进程来实现分布式地并行处理任务</p>
</blockquote>
<ul>
<li>celery-worker可视化工具</li>
</ul>
<pre><code class="shell">pip install flower</code></pre>
<ul>
<li>启动flower可以在本地的5555端口查看到当前celery的信息</li>
</ul>
<pre><code class="shell">python manage.py celery flower</code></pre>
<ul>
<li>django加入设置中加入djcelery</li>
</ul>
<pre><code class="shell">#settings.py
INSTALLED_APPS = [
    ...
    &#39;djcelery&#39;,
]</code></pre>
<ul>
<li>配置基本连接信息</li>
</ul>
<pre><code class="python">#settings.py
import djcelery
djcelery.setup_loader()
BROKER_URL= &#39;amqp://guest:woaini21G@123.57.61.168:5672&#39;</code></pre>
<ul>
<li>celery与3.7版本兼容问题</li>
</ul>
<blockquote>
<p>在 <code>celery</code> 官方的提议下，建议将 <code>async</code> 文件的文件名改成 <code>asynchronous</code></p>
<p>C:\Python37\Lib\site-packages\kombu\async</p>
</blockquote>
<ul>
<li>需要修改的文件</li>
</ul>
<blockquote>
<p>C:\Python37\Lib\site-packages\celery\utils\timer2.py</p>
<p>C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\components.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\autoscale.py</p>
<p>C:\Python37\lib\site-packages\celery\worker\consumer.py</p>
</blockquote>
<ul>
<li>编写任务代码，在每个app下的tasks.py文件中</li>
</ul>
<blockquote>
<p>其中，当djcelery.setup_loader()运行时</p>
<p>Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件</p>
<p>找到标记为task的方法，将它们注册为<code>celery task</code></p>
</blockquote>
<pre><code class="python">#tasks.py
from django.core.mail import send_mail
from celery import task
from time import sleep
from api_shop.settings import DEFAULT_FROM_EMAIL

@task
def send_verify_email(email):
    subject = &#39;欢迎你&#39;
    message = &#39;&#39;&#39;
            这是异步邮件的发送
        &#39;&#39;&#39;
    sleep(10)
    try:
        send_mail(subject, message, DEFAULT_FROM_EMAIL, [email])
    except:
        pass</code></pre>
<ul>
<li>在视图接口的地方使用</li>
</ul>
<pre><code class="python">from . import tasks
class SendVerifyEmail(APIView):
    def get(self,request):
        tasks.send_verify_email.delay(&#39;295878828@qq.com&#39;)
        return Response(
            {&#39;code&#39;:200}
        )</code></pre>
<ul>
<li>开启celery</li>
</ul>
<pre><code>python manage.py celery worker</code></pre><ul>
<li>如果出错大概率需要这样，在manage.py文件前头加入这个</li>
</ul>
<pre><code class="python">#manage.py
import django
import os
os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] = &#39;eduapi.settings&#39;
django.setup()</code></pre>
<h3 id="itsdangerous"><a href="#itsdangerous" class="headerlink" title="itsdangerous"></a>itsdangerous</h3><blockquote>
<p>通过itsdangerous可以有效将用户数据加密放入URL中，并且可以设置过期时间</p>
</blockquote>
<pre><code class="python">from itsdangerous import TimedJSONWebSignatureSerializer,SignatureExpired
serializer = TimedJSONWebSignatureSerializer(SECRET_KEY, 120)
data = {
    &#39;email&#39;:email,
}
token = serializer.dumps(data).decode()
data =  serializer.loads(token)</code></pre>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket使用</title>
    <url>/blog/2020/04/28/Django-websocket/</url>
    <content><![CDATA[<p>1.下载包</p>
<pre><code>pip install channels</code></pre><p>2.创建Django项目</p>
<pre><code>django-admin startprobject ChannelsReady</code></pre><p>3..在项目的<code>settings.py</code>同级目录中,新建文件<code>routing.py</code></p>
<pre><code># routing.py
from channels.routing import ProtocolTypeRouter

application = ProtocolTypeRouter({
    # 暂时为空
})</code></pre><p>4..在项目配置文件<code>settings.py</code>中写入</p>
<pre><code>INSTALLED_APPS = [
    &#39;channels&#39;
]

ASGI_APPLICATION = &quot;ChannelsReady.routing.application&quot;</code></pre><ol start="5">
<li><p>启动带有<code>Channels</code>提供的<code>ASGI</code>的<code>Django</code>项目</p>
</li>
<li><pre><code>February 01, 2020 - 17:27:13
Django version 3.0.2, using settings &#39;ChannelsReady.settings&#39;
Starting ASGI/Channels version 2.4.0 development server at http://0.0.0.0:8000/
Quit the server with CTRL-BREAK.</code></pre></li>
</ol>
<p>很明显可以看到<code>ASGI/Channels</code>,这样就算启动完成了</p>
<ol start="6">
<li><p>新建app</p>
<pre><code>python manage.py startapp chats</code></pre><p>并在settings中注册</p>
</li>
<li><p>在<code>chats</code>应用中新建文件<code>chatService.py</code></p>
</li>
</ol>
<pre><code>## chatService.py

from channels.generic.websocket import WebsocketConsumer
# user_list = []
# class ChatService(WebsocketConsumer):
#     # 当Websocket创建连接时
#     def connect(self):
#         self.accept()
#         user_list.append(self)
#         print(&#39;连接啦？？？&#39;)
#
#     # 当Websocket接收到消息时
#     def receive(self, text_data=None, bytes_data=None):
#         for i in user_list:
#             i.send(text_data)
#         print(&#39;连接里有数据啦！！&#39;)
#
#     # 当Websocket发生断开连接时
#     def disconnect(self, code):
#         user_list.remove(self)
#         print(&#39;断开啦？？？&#39;)</code></pre><p>在app应用中新建urls.py      注意：不用配置路由分发</p>
<pre><code>from django.urls import path
from chats.chatService import ChatService
websocket_url = [
    path(&quot;ws/&quot;,ChatService)
]</code></pre><p>.回到项目<code>routing.py</code>文件中增加<code>ASGI</code>非<code>HTTP</code>请求处理</p>
<pre><code>from channels.routing import ProtocolTypeRouter,URLRouter
from chats.urls import websocket_url

application = ProtocolTypeRouter({
    &quot;websocket&quot;:URLRouter(
        websocket_url
    )
})</code></pre><p>VUE 新建页面 ，并配置路由</p>
<p>在新页面中写入</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;user&quot;&gt;

        &lt;p&gt;&lt;input type=&quot;button&quot; @click=&quot;send&quot; value=&quot;发送&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type=&quot;button&quot; @click=&quot;close_socket&quot; value=&quot;关闭&quot;&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
export default {
    name:&#39;index&#39;,
    data() {
        return {
            message:&#39;&#39;,
            testsocket:&#39;&#39;,
            user:&#39;&#39;
        }
    },
    methods:{
        send(){

        //    send  发送信息
        //    close 关闭连接
            var data1 = {&quot;message&quot;:this.message,&quot;to_user&quot;:this.user}

            this.testsocket.send(JSON.stringify(data1))
            this.testsocket.onmessage = (res) =&gt; {
                console.log(&quot;WS的返回结果&quot;,res.data);         
            }

        },
        close_socket(){
            this.testsocket.close()
        },
        generate_uuid: function() {
            var d = new Date().getTime();
            if (window.performance &amp;&amp; typeof window.performance.now === &quot;function&quot;) {
                d += performance.now(); //use high-precision timer if available
            }
            var uuid = &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(
                /[xy]/g,
                function(c) {
                var r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c == &quot;x&quot; ? r : (r &amp; 0x3) | 0x8).toString(16);
                }
            );
            return uuid;
        },

    },
    mounted(){
        var username = this.generate_uuid();
        console.log(username)
        this.testsocket = new WebSocket(&quot;ws://127.0.0.1:8000/ws/&quot;+ username +&quot;/&quot;) 
        console.log(this.testsocket)

          this.testsocket.onmessage = (res) =&gt; {
                console.log(&quot;WS的返回结果&quot;,res.data);         
            }

        // onopen     定义打开时的函数
        // onclose    定义关闭时的函数
        // onmessage  定义接收数据时候的函数
        // this.testsocket.onopen = function(){
        //     console.log(&quot;开始连接socket&quot;)
        // },
        // this.testsocket.onclose = function(){
        //     console.log(&quot;socket连接已经关闭&quot;)
        // }
    }
}
&lt;/script&gt;</code></pre>]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>支付宝沙箱----支付</title>
    <url>/blog/2020/04/28/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/</url>
    <content><![CDATA[<h5 id="三方支付需要去支付宝开放平台"><a href="#三方支付需要去支付宝开放平台" class="headerlink" title="三方支付需要去支付宝开放平台"></a>三方支付需要去支付宝开放平台</h5><p>1 进入  控制台   创建沙箱应用</p>
<p><img src="/img/ali.jpg" srcset="/img/loading.gif" alt="hexo_themes"></p>
<p>然后 把公钥和秘钥都配置好</p>
<p>把下面代码复制到项目里，</p>
<p>配置路由，访问就好啊！</p>
<pre><code>
from rest_framework.response import Response
from rest_framework.views import APIView
from alipay import AliPay,DCAliPay,ISVAliPay
# from django_test.settings import PUBLIC_KEY,PRIVATE_KEY
import os
from django.conf import settings
app_private_key = open(os.path.join(settings.BASE_DIR,&quot;yaoshi&quot;,&quot;app_shiyao.txt&quot;)).read()
alipay_public_key = open(os.path.join(settings.BASE_DIR,&quot;yaoshi&quot;,&quot;ali_gongyao.txt&quot;)).read()



# print(app_private_key)
alipay = AliPay(
    appid=&quot;2016101600696307&quot;,
    app_notify_url=&#39;http://127.0.0.1:8000/&#39;,  # 默认回调url
    app_private_key_string=app_private_key,
    # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
    alipay_public_key_string=alipay_public_key,
    sign_type=&quot;RSA2&quot; ,# RSA 或者 RSA2
    debug=False , # 默认False
)

class PaymentView(APIView):
    # 如果你是Python 2用户（考虑考虑升级到Python 3吧），请确保非ascii的字符串为utf8编码：
    # subject = u&quot;测试订单&quot;.encode(&quot;utf8&quot;)
    # 如果你是 Python 3的用户，使用默认的字符串即可
    def post(self,requst):
        subject = &quot;测试订单&quot;

        # 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_string
        order_string = alipay.api_alipay_trade_page_pay(
            out_trade_no=&quot;20161112222&quot;,
            total_amount=0.01,
            subject=subject,
            return_url=&quot;http://127.0.0.1:8000/&quot;,
            notify_url=&quot;http://127.0.0.1:8000/&quot;  # 可选, 不填则使用默认notify url
        )
        url = &#39;https://openapi.alipaydev.com/gateway.do?&#39;+order_string
        # print(url)
        return Response(url)</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/blog/2020/04/28/docker%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p>Docker</p>
<p>仓库</p>
<p>仓库分为公用仓库和私有仓库</p>
<p>仓库用来存储镜像</p>
<p>镜像</p>
<p>镜像是从仓库里拉取的，</p>
<p>镜像是一个静态的文件，</p>
<p>容器</p>
<p>镜像运行起来就是一个容器，一个容器打包起来就是一个自定义镜像4</p>
<h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><ul>
<li>docker version</li>
<li>docker info</li>
<li>docker help</li>
</ul>
<h2 id="二、镜像命令"><a href="#二、镜像命令" class="headerlink" title="二、镜像命令"></a>二、镜像命令</h2><h4 id="1-docker-images"><a href="#1-docker-images" class="headerlink" title="1. docker images"></a>1. docker images</h4><ul>
<li>功能： 列出本地主机上的镜像</li>
<li>各个选项说明:</li>
</ul>
<pre><code>REPOSITORY：表示镜像的仓库源
TAG：镜像的标签
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小</code></pre><ul>
<li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li>
<li>OPTIONS说明：<ul>
<li>-a :列出本地所有的镜像（含中间映像层）</li>
<li>-q :只显示镜像ID。</li>
<li>–digests :显示镜像的摘要信息</li>
<li>–no-trunc :显示完整的镜像信息</li>
</ul>
</li>
</ul>
<h4 id="2-docker-search-某个XXX镜像名字"><a href="#2-docker-search-某个XXX镜像名字" class="headerlink" title="2. docker search 某个XXX镜像名字"></a>2. docker search 某个XXX镜像名字</h4><ul>
<li>镜像仓库：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li>
<li>命令：<ul>
<li>docker search [OPTIONS] 镜像名字</li>
<li>OPTIONS说明：<ul>
<li>–no-trunc : 显示完整的镜像描述</li>
<li>-s : 列出收藏数不小于指定值的镜像。</li>
<li>–automated : 只列出 automated build类型的镜像；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-docker-pull-某个XXX镜像名字"><a href="#3-docker-pull-某个XXX镜像名字" class="headerlink" title="3. docker pull 某个XXX镜像名字"></a>3. docker pull 某个XXX镜像名字</h4><ul>
<li>功能: 下载镜像</li>
<li>docker pull 镜像名字[:TAG]</li>
</ul>
<h4 id="4-docker-rmi-某个XXX镜像名字ID"><a href="#4-docker-rmi-某个XXX镜像名字ID" class="headerlink" title="4.docker rmi 某个XXX镜像名字ID"></a>4.docker rmi 某个XXX镜像名字ID</h4><ul>
<li>功能：删除镜像</li>
<li>删除单个： docker rmi -f 镜像ID</li>
<li>删除多个： docker rmi -f 镜像名1:TAG 镜像名2:TAG</li>
<li>删除全部： docker rmi -f $(docker images -qa)</li>
<li>作业：结合我们Git的学习心得，大家猜猜是否会有 docker commit /docker push？？</li>
</ul>
<h2 id="三、容器命令"><a href="#三、容器命令" class="headerlink" title="三、容器命令"></a>三、容器命令</h2><ul>
<li>有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)<code>docker pull centos</code></li>
</ul>
<h4 id="1-新建并启动容器-docker-run-OPTIONS-IMAGE-COMMAND-ARG…"><a href="#1-新建并启动容器-docker-run-OPTIONS-IMAGE-COMMAND-ARG…" class="headerlink" title="1. 新建并启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG…]"></a>1. 新建并启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</h4><ul>
<li>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</li>
</ul>
<pre><code>--name=&quot;容器新名字&quot;: 为容器指定一个名称；
-d: 后台运行容器，并返回容器ID，也即启动守护式容器；
-i：以交互模式运行容器，通常与 -t 同时使用；
-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；
-P: 随机端口映射；
-p: 指定端口映射，有以下四种格式
      ip:hostPort:containerPort
      ip::containerPort
      hostPort:containerPort
      containerPort</code></pre><ul>
<li>启动交互式容器</li>
</ul>
<pre><code>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。
docker run -it centos /bin/bash </code></pre><h4 id="2-列出当前所有正在运行的容器-docker-ps-OPTIONS"><a href="#2-列出当前所有正在运行的容器-docker-ps-OPTIONS" class="headerlink" title="2. 列出当前所有正在运行的容器 docker ps [OPTIONS]"></a>2. 列出当前所有正在运行的容器 docker ps [OPTIONS]</h4><ul>
<li>OPTIONS说明（常用）：</li>
</ul>
<pre><code>-a :列出当前所有正在运行的容器+历史上运行过的
-l :显示最近创建的容器。
-n：显示最近n个创建的容器。
-q :静默模式，只显示容器编号。
--no-trunc :不截断输出。</code></pre><h4 id="3-退出容器-两种退出方式"><a href="#3-退出容器-两种退出方式" class="headerlink" title="3. 退出容器(两种退出方式)"></a>3. 退出容器(两种退出方式)</h4><ul>
<li>容器停止退出 exit</li>
<li>容器不停止退出 ctrl+P+Q</li>
</ul>
<h4 id="4-启动容器"><a href="#4-启动容器" class="headerlink" title="4. 启动容器"></a>4. 启动容器</h4><ul>
<li>docker start 容器ID或者容器名</li>
</ul>
<h4 id="5-重启容器"><a href="#5-重启容器" class="headerlink" title="5. 重启容器"></a>5. 重启容器</h4><ul>
<li>docker restart 容器ID或者容器名</li>
</ul>
<h4 id="6-停止容器"><a href="#6-停止容器" class="headerlink" title="6. 停止容器"></a>6. 停止容器</h4><ul>
<li>docker stop 容器ID或者容器名</li>
</ul>
<h4 id="7-强制停止容器"><a href="#7-强制停止容器" class="headerlink" title="7. 强制停止容器"></a>7. 强制停止容器</h4><ul>
<li>docker kill 容器ID或者容器名</li>
</ul>
<h4 id="8-删除已停止的容器"><a href="#8-删除已停止的容器" class="headerlink" title="8. 删除已停止的容器"></a>8. 删除已停止的容器</h4><ul>
<li>docker rm 容器ID</li>
<li>一次性删除多个容器<ul>
<li>docker rm -f $(docker ps -a -q)</li>
<li>docker ps -a -q | xargs docker rm</li>
</ul>
</li>
</ul>
<h4 id="9-重点"><a href="#9-重点" class="headerlink" title="9. 重点"></a>9. 重点</h4><ul>
<li><p>启动守护式容器</p>
<ul>
<li>docker run -d 容器名</li>
<li></li>
</ul>
<pre><code>#使用镜像centos:latest以后台模式启动一个容器
docker run -d centos

问题：然后docker ps -a 进行查看, 会发现容器已经退出
很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.
容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。

这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如
service nginx start
但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,
这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.
所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</code></pre></li>
<li><p>查看容器日志</p>
<ul>
<li>docker logs -f -t –tail 容器ID</li>
<li>docker run -d centos /bin/sh -c “while true;do echo hello ljj;sleep 2;done”<ul>
<li>-t 是加入时间戳</li>
<li>-f 跟随最新的日志打印</li>
<li>–tail 数字 显示最后多少条 –tail 数字 显示最后多少条</li>
</ul>
</li>
</ul>
</li>
<li><p>查看容器内运行的进程</p>
<ul>
<li>docker top 容器ID</li>
</ul>
</li>
<li><p>查看容器内部细节</p>
<ul>
<li>docker inspect 容器ID</li>
</ul>
</li>
<li><p>进入正在运行的容器并以命令行交互</p>
<ul>
<li>docker exec -it 容器ID bashShell</li>
<li></li>
</ul>
<pre><code> `docker exec -it 81bb90b25582 /bin/bash`</code></pre><ul>
<li>重新进入: docker attach 容器ID</li>
<li>上述两个区别:<ul>
<li>attach: 直接进入容器启动命令的终端，不会启动新的进程</li>
<li>exec: 是在容器中打开新的终端，并且可以启动新的进程</li>
<li>再次查看容器的进程：docker top 81bb90b25582</li>
</ul>
</li>
</ul>
</li>
<li><p>从容器内拷贝文件到主机上</p>
<ul>
<li>docker cp 容器ID:容器内路径 目的主机路径<ul>
<li>docker cp 81bb90b25582:/tmp/a.txt /tmp/aa.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>用Hugo快速搭建个人静态博客</title>
    <url>/blog/2020/04/25/hugo1/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="Step-1-Install-Hugo-下载、安装Hugo"><a href="#Step-1-Install-Hugo-下载、安装Hugo" class="headerlink" title="Step 1. Install Hugo 下载、安装Hugo"></a>Step 1. Install Hugo 下载、安装Hugo</h2><p>下载地址：<a href="https://github.com/spf13/hugo/releases。" target="_blank" rel="noopener">https://github.com/spf13/hugo/releases。</a><br>根据自己的操作系统，下载对应的安装包。我的操作系统是Win7 64bit， 选择了hugo_0.19_Windows-64bit.zip。                      </p>
<p>下载完成之后，解压的文件夹包含以下3个文件：                      </p>
<pre><code>hugo_0.19_windows_amd64.exe
LICENSE.md
README.md</code></pre><p>将 hugo_0.19_windows_amd64.exe 重命名为hugo.exe。在你的软件安装盘新增名为hugo的文件目录，在里面在新建一个bin子目录。然后将hugo.exe放到hugo\bin目录下。再将这个bin目录的路径添加到系统环境变量中。</p>
<p>完成以上步骤后，打开命令行输入                      </p>
<pre><code>hugo help</code></pre><p>如果得到如下信息，说明安装成功                      </p>
<pre><code>hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.</code></pre><h2 id="Step-2-创建一个名为blog的Hugo站点"><a href="#Step-2-创建一个名为blog的Hugo站点" class="headerlink" title="Step 2. 创建一个名为blog的Hugo站点"></a>Step 2. 创建一个名为blog的Hugo站点</h2><p>我希望在E盘下创建站点，所以我先切换目录</p>
<pre><code>cd e:
e:</code></pre><p>然后输入命令：</p>
<pre><code>hugo new site blog </code></pre><p>得到如下提示创建成功的信息：</p>
<pre><code>Congratulations! Your new Hugo site is created in E:\blog.

Just a few more steps and you&#39;re ready to go:

1. Download a theme into the same-named folder.
Choose a theme from https://themes.gohugo.io/, or
create your own with the &quot;hugo new theme &lt;THEMENAME&gt;&quot; command.
2. Perhaps you want to add some content. You can add single files
with &quot;hugo new &lt;SECTIONNAME&gt;\&lt;FILENAME&gt;.&lt;FORMAT&gt;&quot;.
3. Start the built-in live server via &quot;hugo server&quot;.

Visit https://gohugo.io/ for quickstart guide and full documentation.</code></pre><p>进入该目录，可以看到自动生成了5个目录和一个配置文件config.toml</p>
<pre><code>|-- archetypes
|-- content   #存放内容的目录
|-- data      
|-- layouts   
|-- static    #存放静态资源（图片,css,js）
|-- themes    #存放主题
|-- config.toml  #配置文件 </code></pre><h2 id="Step-3-添加内容"><a href="#Step-3-添加内容" class="headerlink" title="Step 3. 添加内容"></a>Step 3. 添加内容</h2><p>切换到该目录下，然后输入如下命令，会在content的目录下创建post目录，在post目录下创建名为test.md的文件。</p>
<pre><code>cd blog
hugo new post/test.md</code></pre><p>提示文件创建成功：</p>
<pre><code>E:\blog\content\post\test.md created</code></pre><p>用文本编辑器打开文件test.md文件<br>可以看到如下内容：</p>
<pre><code>+++
date = &quot;2017-01-02T17:45:06+08:00&quot;  #创建文件的时间
title = &quot;test&quot;                      #文件的标题
draft = true                        # 是否为草稿

+++</code></pre><p>上述内容为自动创建的与文章有关的内容。自己也可以在两个+++之间添加如下内容：</p>
<pre><code>image = &quot;hugo.png&quot;            #指定图片。
category = &quot;test&quot;             #文章的类别
tags = [&quot;Hugo&quot;, &quot;intro&quot;]      #文章的标签分类。
url = &quot;new_start&quot;             #该文章访问时的相对的url地址，默认为文件名。</code></pre><p>更多的设置，可以参考官方文档。</p>
<p>以后写博客文章就是这样创建markdown文件, 之后通过Hugo编译成静态的html文件。</p>
<h2 id="Step-4-添加主题"><a href="#Step-4-添加主题" class="headerlink" title="Step 4. 添加主题"></a>Step 4. 添加主题</h2><p>官方提供了多种主题可供选择，具体在 <a href="https://themes.gohugo.io/" target="_blank" rel="noopener">https://themes.gohugo.io/</a> 可以找到。</p>
<p>找到想要的主题后，切换到themes目录（该目录可以存放多个不同的主题）。</p>
<pre><code>cd themes</code></pre><p>由于需要使用到Git下载主题，以及版本管理和代码推送。需要事先下载安装好Git。</p>
<p>把选定的主题下载到themes目录下。</p>
<pre><code>git clone https://github.com/dim0627/hugo_theme_robust.git</code></pre><h2 id="Step-5-启动服务，本地预览"><a href="#Step-5-启动服务，本地预览" class="headerlink" title="Step 5. 启动服务，本地预览"></a>Step 5. 启动服务，本地预览</h2><p>先从themes目录下退回到blog目录, 然后启动服务。</p>
<pre><code>cd ..
hugo server --theme=hugo_theme_robust --buildDrafts</code></pre><p>在浏览器中打开 <a href="https://themes.gohugo.io/" target="_blank" rel="noopener">http://localhost:1313/</a></p>
<h2 id="Step-6-修改配置文件config-toml"><a href="#Step-6-修改配置文件config-toml" class="headerlink" title="Step 6. 修改配置文件config.toml"></a>Step 6. 修改配置文件config.toml</h2><pre><code>languageCode = &quot;zh-cn&quot;
title = &quot;Frank Wang&#39;s Coding World&quot;
baseurl = &quot;http://www.wangxingfeng.com/&quot;  

[Params]
    Author =&quot;Frank Wang&quot;</code></pre><h2 id="Step-7-生成网站"><a href="#Step-7-生成网站" class="headerlink" title="Step 7. 生成网站"></a>Step 7. 生成网站</h2><h3 id="1-改变文章draft（草稿）状态："><a href="#1-改变文章draft（草稿）状态：" class="headerlink" title="1.改变文章draft（草稿）状态："></a>1.改变文章draft（草稿）状态：</h3><pre><code>hugo undraft content/post/*.md</code></pre><h3 id="2-启动hugo-生成发布文件到public目录下。"><a href="#2-启动hugo-生成发布文件到public目录下。" class="headerlink" title="2. 启动hugo, 生成发布文件到public目录下。"></a>2. 启动hugo, 生成发布文件到public目录下。</h3><pre><code>hugo --theme=hugo-icarus-theme</code></pre><h2 id="Step-8-托管到GitHub-Pages"><a href="#Step-8-托管到GitHub-Pages" class="headerlink" title="Step 8. 托管到GitHub Pages"></a>Step 8. 托管到GitHub Pages</h2><h3 id="1-使用Git来进行版本管理"><a href="#1-使用Git来进行版本管理" class="headerlink" title="1. 使用Git来进行版本管理"></a>1. 使用Git来进行版本管理</h3><pre><code>git init
echo &quot;/public/&quot; &gt;&gt; .gitignore
echo &quot;/themes/&quot; &gt;&gt; .gitignore
git add --all
git commit -m &quot;Initial commit&quot;</code></pre><h3 id="2-创建Git-远程仓库"><a href="#2-创建Git-远程仓库" class="headerlink" title="2. 创建Git 远程仓库"></a>2. 创建Git 远程仓库</h3><p>登录你的GitHub. 创建一个新的仓库，仓库名为Github用户.github.io<br>比如我的是frankwang0909.github.io.</p>
<h3 id="3-添加Git-远程仓库，并提交代码。"><a href="#3-添加Git-远程仓库，并提交代码。" class="headerlink" title="3. 添加Git 远程仓库，并提交代码。"></a>3. 添加Git 远程仓库，并提交代码。</h3><pre><code>cd public
git init
git remote add origin git@github.com:frankwang0909/frankwang0909.github.io.git

git add --all
git commit -m &quot;blog added&quot;
git push -u origin master</code></pre><h3 id="4-以后有内容改动，提交代码"><a href="#4-以后有内容改动，提交代码" class="headerlink" title="4.以后有内容改动，提交代码."></a>4.以后有内容改动，提交代码.</h3><pre><code>(cd ..; hugo --theme=hugo_theme_robust)
git add --all
git commit -m &quot;&lt;some change message&gt;&quot;
git push -u origin master</code></pre>]]></content>
      <categories>
        <category>hugo</category>
      </categories>
      <tags>
        <tag>hugo</tag>
      </tags>
  </entry>
  <entry>
    <title>Django单表增删改查操作</title>
    <url>/blog/2020/04/24/django2/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h2><ul>
<li><p>MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</p>
</li>
<li><p>ORM是“对象-关系-映射”的简称。（Object Relational Mapping，简称ORM）(将来会学一个sqlalchemy，是和他很像的，但是django的orm没有独立出来让别人去使用，虽然功能比sqlalchemy更强大，但是别人用不了)</p>
</li>
<li><p>类对象—&gt;sql—&gt;pymysql—&gt;mysql服务端—&gt;磁盘，orm其实就是将类对象的语法翻译成sql语句的一个引擎，明白orm是什么了，剩下的就是怎么使用orm，怎么来写类对象关系语句。</p>
</li>
</ul>
<h2 id="表的增加数据操作"><a href="#表的增加数据操作" class="headerlink" title="表的增加数据操作"></a>表的增加数据操作</h2><pre><code>在views.py文件中，传入一条数据：
from app01 import models
date=datetime.date.today()
book_obj=models.Book(name=&#39;三国3&#39;,price=100,date=date)
book_obj.save()
(date数据传入时还可直接写入字符串：&quot;2019-5-23&quot;)
第二种方法创建数据：
    book_obj1=models.Book.objects.create(
        name=&#39;水浒4&#39;,price=100,date=&#39;2018-12-12&#39;
    )
（生成的返回值，book_obj1为一个model对象，可以调取对象属性值）
查看orm翻译成sql语句式子：
    # from django.db import connection
    # print(connection.queries)

批量插入数据：
    obj_list=[]
    for i in range(1,10):
        obj=models.Book(
            name=&#39;黄与红%s&#39;%i,
            price=10+i,
            date=&#39;2019-5-%s&#39;%i
        )
        obj_list.append(obj)
    models.Book.objects.bulk_create(obj_list) #批量插入，速度快

有就更新，没有就删除（update_or_create）：
    obj1,create_status=models.Book.objects.update_or_create(
        price=11, #查询参数
        defaults={    #需要更新的值
            &quot;name&quot;:&#39;xxx&#39;,
            &#39;date&#39;:&#39;2012-2-2&#39;
        }
    )
    # update_or_create内置的是Get方法,没有就创建数据，一旦匹配到多条数据就会报错 此时打印的create_status为检测判断为匹配到的还是为匹配到的，匹配的到数据，进行更改，值为False，匹配不到数据，进行创建，值为True</code></pre><h2 id="表的查询数据操作"><a href="#表的查询数据操作" class="headerlink" title="表的查询数据操作"></a>表的查询数据操作</h2><pre><code>查询所有结果，结果是queryset类型：
    all_obj=models.Book.objects.all()
    print(all_obj)
返回的结果是一个类似列表： [&lt;Book: Book object&gt;,&lt;Book: Book object&gt;]
可以设置models里设置函数，可以将打印的返回结果打印出相关的属性：
    def __str__(self):
        return (self.name)
返回结果： [&lt;Book: 三国1&gt;, &lt;Book: 水浒2&gt;]

根据条件查询数据，结果也是queryset类型，可以捕获多条数据：
    book_obj=models.Book.objects.filter(
        id=1
    )
    print(book_obj)

get方法匹配， 返回与所给筛选条件相匹配的对象，不是queryset类型，是行记录对象，返回结果有且只有一个，多一个或少一个就会报错
    book_obj=models.Book.objects.get(id=4)
    print(book_obj)

查询方法：
 exclude(**kwargs):      排除的意思，它包含了与所给筛选条件不匹配的对象，没有不等于的操作昂，用这个exclude，返回值是queryset类型
 models.Book.objects.exclude(id=6),返回id不等于6的所有的对象

 order_by(*field):       queryset类型的数据来调用，对查询结果排序,默认是按照id来升序排列的，返回值还是queryset类型
 models.Book.objects.all().order_by(&#39;price&#39;,&#39;id&#39;) #price升序排列,按照字段降序排列，就写个负号就行,按照price进行升序，price相同的数据，按照id进行升序

 reverse():              queryset类型的数据来调用，对查询结果反向排序，返回值还是queryset类型


 count():                queryset类型的数据来调用，返回数据库中匹配查询(QuerySet)的对象数量。

 first():                queryset类型的数据来调用，返回第一条记录

 last():                queryset类型的数据来调用，返回最后一条记录

 exists():              queryset类型的数据来调用，如果QuerySet包含数据，就返回True，否则返回False

 values(*field):        用的比较多，queryset类型的数据来调用，返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列,只要是返回的queryset类型，
　　　　　　　　　　　　　　就可以继续链式调用queryset类型的其他的查找方法，其他方法也是一样的。

 values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</code></pre><h2 id="表的更改数据操作"><a href="#表的更改数据操作" class="headerlink" title="表的更改数据操作"></a>表的更改数据操作</h2><pre><code>update只能是querset类型才能调用，model对象不能直接调用更新方法，所以使用get方法获取对象的时候是不能update的。
models.Book.objects.filter(id=4).update(price=120）
</code></pre><h2 id="表的删除数据操作"><a href="#表的删除数据操作" class="headerlink" title="表的删除数据操作"></a>表的删除数据操作</h2><pre><code>delete()方法的调用者可以是一个model对象，也可以是一个queryset集合。
删除方法就是 delete()。它运行时立即删除对象而不返回任何值。
    book_obj=models.Book.objects.get(id=4)
    print(book_obj)
    book_obj.delete()
批量删除：
models.Book.objects.filter(price=100).delete()</code></pre>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django数据库使用</title>
    <url>/blog/2020/04/23/django1/</url>
    <content><![CDATA[<a id="more"></a>  
<h2 id="一、配置使用MySQL数据库"><a href="#一、配置使用MySQL数据库" class="headerlink" title="一、配置使用MySQL数据库"></a>一、配置使用MySQL数据库</h2><p>1、手动创建mysql数据库，例如md<br><code>create database md charset=utf8;</code><br>或使用Navicat创建数据库</p>
<p>2、在与项目同名的setting.py文件中，配置mysql</p>
<pre><code>DATABASES = {
   &#39;default&#39;: {
          &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, #数据库引擎
          &#39;NAME&#39;: &#39;md&#39;,                       #数据库名
          &#39;USER&#39;: &#39;root&#39;,                       #用户名
          &#39;PASSWORD&#39;: &#39;123456&#39;,                   #密码
          &#39;HOST&#39;: &#39;&#39;,                           #数据库主机，默认为localhost
          &#39;PORT&#39;: 3306,                           #数据库端口，MySQL默认为3306
          &#39;OPTIONS&#39;: {
             &#39;autocommit&#39;: True,
         }
    }
}</code></pre><h2 id="二、在models-py里创建数据库"><a href="#二、在models-py里创建数据库" class="headerlink" title="二、在models.py里创建数据库"></a>二、在models.py里创建数据库</h2><pre><code># 用户表
class User(models.Model):
    username = models.CharField(max_length=200)
    password = models.CharField(max_length=200)
    img = models.CharField(max_length=200)
    #类别 0普通用户 1超级管理员
    type = models.IntegerField(default=0,null=True)
    #手机号
    phone = models.IntegerField()
    #个人主页
    num = models.IntegerField(default=0,null=True)

    class Meta:
        db_table = &#39;user&#39;</code></pre><h2 id="三、迁移命令生成表"><a href="#三、迁移命令生成表" class="headerlink" title="三、迁移命令生成表"></a>三、迁移命令生成表</h2><p>在配置完mysql的配置项后，需要进入到项目的根目录，在终端上执行两个命令，生成数据库表<br>1、生成迁移文件<br><code>python manage.py makemigrations</code>           </p>
<p>2、生成数据库表<br><code>python manage.py migrate</code>           </p>
<p>3、进入Navicat查看数据库表<br><img src="/my_technology_blog/navicat.png" srcset="/my_blog/img/loading.gif" alt="数据库"></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础语法</title>
    <url>/blog/2020/04/22/vue1/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model是用于表单输入的数据双向绑定。所谓双向绑定就是视图层的数据变化会引起数据层数据的改变，相反的，数据层的变化也会导致视图层展示数据的变化。</p>
<h2 id="class绑定："><a href="#class绑定：" class="headerlink" title="class绑定："></a>class绑定：</h2><pre><code>&lt;div :class=&quot;{ active:isActive }&quot;&gt;动态添加class&lt;/div&gt;
&lt;div :class=&quot;classObj&quot;&gt;class绑定对象&lt;/div&gt;
&lt;div :class=&quot;classArray&quot;&gt;class绑定数组&lt;/div&gt;
&lt;div :class=&quot;active:isActive&quot;&gt;class绑定计算，isActive是一个计算&lt;/div&gt;</code></pre><h2 id="条件渲染："><a href="#条件渲染：" class="headerlink" title="条件渲染："></a>条件渲染：</h2><p>v-if; v-else if; v-else;<br><img src="/my_technology_blog/if.png" srcset="/my_blog/img/loading.gif" alt=""></p>
<h2 id="v-show可以做频繁重复性的显示-隐藏交替设置"><a href="#v-show可以做频繁重复性的显示-隐藏交替设置" class="headerlink" title="v-show可以做频繁重复性的显示/隐藏交替设置"></a>v-show可以做频繁重复性的显示/隐藏交替设置</h2><p><code>&lt;h1 v-show=&quot;ok&quot;&gt;v-show指令也可以控制显示隐藏元素&lt;/h1&gt;</code></p>
<p>v-show和v-if的区别：</p>
<p>v-show会渲染dom树，其元素的display属性受条件的控制显示隐藏元素；</p>
<p>v-show不支持template元素</p>
<p>v-if根据条件判断是否渲染dom数</p>
<h2 id="列表渲染：v-for"><a href="#列表渲染：v-for" class="headerlink" title="列表渲染：v-for"></a>列表渲染：v-for</h2><p>循环数据类型：常量，数组，对象，计算属性；</p>
<pre><code>&lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in tlist&quot; :class=&quot;{on:index%2==0,off:index%2!=0}&quot;&gt;
        {{item.text}} {{item.price}}
      &lt;/li&gt;
&lt;/ul&gt;</code></pre><blockquote>
<p>evenNumber为函数，返回数组；常用语数组的部分渲染；<br>注意：可以使用of替代in<br>for循环不改变dom元素，而是替换元素，要想改变dom结构，必须使用key标明；<br>对象具有迭代属性时，循环会进行升序排列输出；<br>v-for的优先级大于v-if，不建议同事使用；            </p>
</blockquote>
<h2 id="事件处理：v-on-缩写为"><a href="#事件处理：v-on-缩写为" class="headerlink" title="事件处理：v-on;缩写为@"></a>事件处理：v-on;缩写为@</h2><p>v-on 用于监听DOM事件，如按钮的点击事件、双击事件等。v-on 的简写为 @,如下面的 @click 就等价为 v-on:click。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;

        &lt;button @click=&quot;counter++&quot;&gt;点我++&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
watch:{
       counter:function(n,o){
         console.log(&#39;计数器的变化:&#39; + &#39;从&#39; + o + &#39;变成了&#39; + n)
       }
    },</code></pre><h2 id="反转属性"><a href="#反转属性" class="headerlink" title="反转属性"></a>反转属性</h2><pre><code>&lt;template&gt;
    &lt;div&gt;

        {{ reverse_msg }}

    &lt;/div&gt;
&lt;/template&gt;
computed: {
      reverse_msg:function() {
        return &#39;$&#39; + this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;)
      }
    },</code></pre>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hugo遇到的问题及解决方法</title>
    <url>/blog/2020/04/21/hugo2/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="环境变量问题解决方法"><a href="#环境变量问题解决方法" class="headerlink" title="环境变量问题解决方法"></a>环境变量问题解决方法</h2><p>找到“我的电脑“-”高级系统设置“-”环境变量“-”系统变量“中的path，向其中添加hugo可执行软件(.exe)的路径即可。</p>
<p>之后可以在命令窗口中输入hugo version命令，试试有没有版本信息。</p>
<h2 id="主题问题"><a href="#主题问题" class="headerlink" title="主题问题"></a>主题问题</h2><p>下载主题可以到<a href="https://themes.gohugo.io/" target="_blank" rel="noopener">雨果主题</a>上下载，但是里面有些主题因为很长时间没有维护所以用不了 需要去选择测试</p>
<h2 id="Hugo中插入图片路径问题"><a href="#Hugo中插入图片路径问题" class="headerlink" title="Hugo中插入图片路径问题"></a>Hugo中插入图片路径问题</h2><p>解决这个问题主要是看路径是否写对 ， 图片是否存在static当中 ，图片名是否正确<br><img src="/my_technology_blog/1.png" srcset="/my_blog/img/loading.gif" alt="王海鑫的技术博客"></p>
<h2 id="命令行报错"><a href="#命令行报错" class="headerlink" title="命令行报错"></a>命令行报错</h2><p>hugo的报错还是很人性化的。只要认真看报错信息，基本上都能定位到错误位置。</p>
<h2 id="使用码云直接上传代码生成网站"><a href="#使用码云直接上传代码生成网站" class="headerlink" title="使用码云直接上传代码生成网站"></a>使用码云直接上传代码生成网站</h2><p>使用码云要简单一些. 主要把你的站点生成纯静态页面，然后打包到public文件夹时</p>
<pre><code>hugo --baseUrl=&quot;/my_technology_blog/&quot;</code></pre><p>域名要对应 不然部署上去是没有样式的</p>
<p>进入【public】文件夹，cmd打开命令窗口依次执行如下命令：<br>【git init】  // 初始化git<br>【git remote add origin  <a href="https://github.com/xxx/xxx.github.io.git】" target="_blank" rel="noopener">https://github.com/xxx/xxx.github.io.git】</a> // 后面是上面新建的空白仓库地址<br>【git add .】  // 注意最后有个点，代表把当前目录内的所有文件加入到跟踪<br>【git commit -m “Initial”】  // 执行git commit 指令<br>【git push -u origin master】 // 推送到仓库，稍后提示成功                 </p>
]]></content>
      <categories>
        <category>hugo</category>
      </categories>
      <tags>
        <tag>hugo</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是VUE？为什么用VUE？</title>
    <url>/blog/2020/04/20/vue2/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="1-Vue-js是什么？"><a href="#1-Vue-js是什么？" class="headerlink" title="1.Vue.js是什么？"></a>1.Vue.js是什么？</h2><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。</p>
<p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。</p>
<p>这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？</p>
<p>不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。</p>
<h2 id="2-Vue-js到底是什么？"><a href="#2-Vue-js到底是什么？" class="headerlink" title="2.Vue.js到底是什么？"></a>2.Vue.js到底是什么？</h2><p>想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读把。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。</p>
<h2 id="3-单页应用程序（SPA）"><a href="#3-单页应用程序（SPA）" class="headerlink" title="3.单页应用程序（SPA）"></a>3.单页应用程序（SPA）</h2><p>顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。</p>
<h2 id="4-你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue-js呢？"><a href="#4-你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue-js呢？" class="headerlink" title="4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？"></a>4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？</h2><p>讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。</p>
<p>现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。</p>
<p>我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。</p>
<p>Vue 的核心库只关注视图层<br>我们为什么要把视图层抽取出来并且单独去关注它呢？</p>
<p>因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？</p>
<p>你是否还记得你当初写JQuery的时候，有写过$(‘#xxx’).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$(‘#xxx’).parent().parent().parent()可能就会变成$(‘#xxx’).parent().parent().parent().parent().parent()了。</p>
<p>这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。</p>
<p>当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。</p>
<p>这个时候如果你学过Vue.js，那么这些抱怨将不复存在。</p>
<h2 id="5-Vue-js为什么能让基于网页的前端应用程序开发起来这么方便？"><a href="#5-Vue-js为什么能让基于网页的前端应用程序开发起来这么方便？" class="headerlink" title="5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？"></a>5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？</h2><p>因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。</p>
<p>可是这些名词都是啥？</p>
<h2 id="6-响应式的数据绑定"><a href="#6-响应式的数据绑定" class="headerlink" title="6.响应式的数据绑定"></a>6.响应式的数据绑定</h2><p>这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。</p>
<pre><code>hugo_0.19_windows_amd64.exe
LICENSE.md
README.md</code></pre><p>是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？</p>
<p>换句话说，p标签里面通过这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。</p>
<p>结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。</p>
<h2 id="7-组件化开发"><a href="#7-组件化开发" class="headerlink" title="7.组件化开发"></a>7.组件化开发</h2><p>还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。</p>
<p>但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。</p>
<p>在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。</p>
<p>在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。</p>
<p>Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<h2 id="8-Virtual-DOM"><a href="#8-Virtual-DOM" class="headerlink" title="8.Virtual DOM"></a>8.Virtual DOM</h2><p>现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。</p>
<p>而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p>
<p>对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。</p>
<h2 id="9-我到底该怎么用Vue-js做单页应用开发？"><a href="#9-我到底该怎么用Vue-js做单页应用开发？" class="headerlink" title="9.我到底该怎么用Vue.js做单页应用开发？"></a>9.我到底该怎么用Vue.js做单页应用开发？</h2><p>说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？</p>
<p>前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？</p>
<p>我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。</p>
<p>然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。</p>
<p>最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。</p>
<h2 id="10-在前面你提到过好几次ECMAScript，这是啥？"><a href="#10-在前面你提到过好几次ECMAScript，这是啥？" class="headerlink" title="10.在前面你提到过好几次ECMAScript，这是啥？"></a>10.在前面你提到过好几次ECMAScript，这是啥？</h2><p>ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？</p>
<p>没错你猜对了，他们之间还真有着很深的联系。</p>
<p>引用阮一峰老师的话：（ECMAScript 6入门）</p>
<p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<p>而ECMAScript6就是新一代的JavaScript语言。</p>
<p>这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门</p>
<h2 id="11-我在学习Vue-js的时候老是听到Webpack，这是啥？"><a href="#11-我在学习Vue-js的时候老是听到Webpack，这是啥？" class="headerlink" title="11.我在学习Vue.js的时候老是听到Webpack，这是啥？"></a>11.我在学习Vue.js的时候老是听到Webpack，这是啥？</h2><p>Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。</p>
<h2 id="12-为什么要用Webpack"><a href="#12-为什么要用Webpack" class="headerlink" title="12.为什么要用Webpack"></a>12.为什么要用Webpack</h2><p>前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？</p>
<p>还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。</p>
<p>前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。</p>
<p>开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中</p>
<p>当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。</p>
<h2 id="13-NPM和Node-js又是什么？它们是什么关系？"><a href="#13-NPM和Node-js又是什么？它们是什么关系？" class="headerlink" title="13.NPM和Node.js又是什么？它们是什么关系？"></a>13.NPM和Node.js又是什么？它们是什么关系？</h2><p>首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。</p>
<p>NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过</p>
<p>npm install xxx包名称<br>的方式引入它，比如说</p>
<p>npm install vue<br>就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。</p>
<p>至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。</p>
<p>前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。</p>
<p>如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。</p>
<h2 id="14-Vue-CLi又是啥？"><a href="#14-Vue-CLi又是啥？" class="headerlink" title="14.Vue-CLi又是啥？"></a>14.Vue-CLi又是啥？</h2><p>它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过</p>
<p>npm install vue-cli -g<br>的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。</p>
<h2 id="15-我该不该学Vue-js？"><a href="#15-我该不该学Vue-js？" class="headerlink" title="15.我该不该学Vue.js？"></a>15.我该不该学Vue.js？</h2><p>现在Vue.js无论是发展势头还是作者支持还是很好的，而且它本身中文资料就比较多，教程也很多，现在随随便便打开几个和前端开发有关的知乎专栏，基本上都能见到相关文章，社区也很活跃。</p>
<p>至于你该不该学，取决于你自己，如果你当前只是做做以内容展示为主的项目，或者就是成天用各种CMS建站仿站，并且以后都不打算更换更好的工作，那么可以暂时不用学。如果你开发的项目交互非常多，而且前后端开发都对前后端分离有很清楚的认识，那么可以大胆的学习，并且在实际项目中运用。</p>
<h2 id="16-Vue-js怎么火起来的？"><a href="#16-Vue-js怎么火起来的？" class="headerlink" title="16.Vue.js怎么火起来的？"></a>16.Vue.js怎么火起来的？</h2><p>关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。</p>
<p>对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。</p>
<p>而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。</p>
<p>当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。</p>
<h2 id="17-我在很多地方还看到Vuex和Vue-route，它们又是什么？"><a href="#17-我在很多地方还看到Vuex和Vue-route，它们又是什么？" class="headerlink" title="17.我在很多地方还看到Vuex和Vue-route，它们又是什么？"></a>17.我在很多地方还看到Vuex和Vue-route，它们又是什么？</h2><p>Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。</p>
<p>Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。</p>
<p>要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。</p>
<h2 id="18-我还在一些地方看到过Vue-resource和Axios，它们又是什么？"><a href="#18-我还在一些地方看到过Vue-resource和Axios，它们又是什么？" class="headerlink" title="18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？"></a>18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？</h2><p>我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。</p>
<p>在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。</p>
<p>vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。</p>
<h2 id="19-我该学Vue-js2-0还是1-0呢？"><a href="#19-我该学Vue-js2-0还是1-0呢？" class="headerlink" title="19.我该学Vue.js2.0还是1.0呢？"></a>19.我该学Vue.js2.0还是1.0呢？</h2><p>现在很多框架和语言都是学新不学旧（Python慢慢也变得如此），因此如果不是为了维护老旧项目，肯定推荐学Vue.js2.0。而且学会了Vue.js2.0，再去学习Vue.js1.0也不是什么难事。</p>
<h2 id="20-写Vue-js用什么开发工具和电脑呢？"><a href="#20-写Vue-js用什么开发工具和电脑呢？" class="headerlink" title="20.写Vue.js用什么开发工具和电脑呢？"></a>20.写Vue.js用什么开发工具和电脑呢？</h2><p>前端开发基本上不需要太高端的电脑都能胜任，现在这个时代是台电脑，装个编辑器都可以做前端开发的。</p>
<p>Vue.js的组件文件本质上还是普通的代码文件，所以各种编辑器配合一些语法检查插件就足够了。我自己用的是sublime text 3，安装一些插件之后可以实现.vue单文件组件高亮代码以及各种自动完成。Webstorm中也有类似插件，大家可以在网上各种教学文章的指导下配置好环境。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git提交项目到码云</title>
    <url>/blog/2020/04/19/git/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="一、git安装"><a href="#一、git安装" class="headerlink" title="一、git安装"></a>一、git安装</h2><h3 id="1、首先在官方网站下载git工具，或者根据以下链接进行下载：http-download-csdn-net-detail-qq-27501889-9788879"><a href="#1、首先在官方网站下载git工具，或者根据以下链接进行下载：http-download-csdn-net-detail-qq-27501889-9788879" class="headerlink" title="1、首先在官方网站下载git工具，或者根据以下链接进行下载：http://download.csdn.net/detail/qq_27501889/9788879"></a>1、首先在官方网站下载git工具，或者根据以下链接进行下载：<a href="http://download.csdn.net/detail/qq_27501889/9788879" target="_blank" rel="noopener">http://download.csdn.net/detail/qq_27501889/9788879</a></h3><h3 id="2、找到Git-2-11-exe文件，双击安装"><a href="#2、找到Git-2-11-exe文件，双击安装" class="headerlink" title="2、找到Git-2.11.exe文件，双击安装"></a>2、找到Git-2.11.exe文件，双击安装</h3><h3 id="3、点击next继续下一步"><a href="#3、点击next继续下一步" class="headerlink" title="3、点击next继续下一步"></a>3、点击next继续下一步</h3><h3 id="4、更改安装路径，点击next下一步"><a href="#4、更改安装路径，点击next下一步" class="headerlink" title="4、更改安装路径，点击next下一步"></a>4、更改安装路径，点击next下一步</h3><h3 id="5、勾选Additonai-icons，创建桌面图标，不想创建桌面图标可不勾选此项，点击next下一步"><a href="#5、勾选Additonai-icons，创建桌面图标，不想创建桌面图标可不勾选此项，点击next下一步" class="headerlink" title="5、勾选Additonai icons，创建桌面图标，不想创建桌面图标可不勾选此项，点击next下一步"></a>5、勾选Additonai icons，创建桌面图标，不想创建桌面图标可不勾选此项，点击next下一步</h3><h3 id="6、在Adjusting-your-PATH-environment中，选择默认选中的那一个，点击next下一步"><a href="#6、在Adjusting-your-PATH-environment中，选择默认选中的那一个，点击next下一步" class="headerlink" title="6、在Adjusting your PATH environment中，选择默认选中的那一个，点击next下一步"></a>6、在Adjusting your PATH environment中，选择默认选中的那一个，点击next下一步</h3><h3 id="7、在Configuring-the-line-ending-conversions中，同样选择默认的选项，点击next下一步"><a href="#7、在Configuring-the-line-ending-conversions中，同样选择默认的选项，点击next下一步" class="headerlink" title="7、在Configuring the line ending conversions中，同样选择默认的选项，点击next下一步"></a>7、在Configuring the line ending conversions中，同样选择默认的选项，点击next下一步</h3><h3 id="8、不用多说，还是默认状态，然后下一步"><a href="#8、不用多说，还是默认状态，然后下一步" class="headerlink" title="8、不用多说，还是默认状态，然后下一步"></a>8、不用多说，还是默认状态，然后下一步</h3><h3 id="9、这里勾选上前面两个选项，然后next下一步"><a href="#9、这里勾选上前面两个选项，然后next下一步" class="headerlink" title="9、这里勾选上前面两个选项，然后next下一步"></a>9、这里勾选上前面两个选项，然后next下一步</h3><h3 id="10、默认状态，直接下一步，进行安装，安装完成后，finish完成安装"><a href="#10、默认状态，直接下一步，进行安装，安装完成后，finish完成安装" class="headerlink" title="10、默认状态，直接下一步，进行安装，安装完成后，finish完成安装"></a>10、默认状态，直接下一步，进行安装，安装完成后，finish完成安装</h3><h2 id="二、初次使用Git时，需要Git进行配置"><a href="#二、初次使用Git时，需要Git进行配置" class="headerlink" title="二、初次使用Git时，需要Git进行配置"></a>二、初次使用Git时，需要Git进行配置</h2><h3 id="1、点击桌面上的这个图标，打开Git-Bash"><a href="#1、点击桌面上的这个图标，打开Git-Bash" class="headerlink" title="1、点击桌面上的这个图标，打开Git Bash"></a>1、点击桌面上的这个图标，打开Git Bash</h3><h3 id="2、配置自己的用户名和邮箱"><a href="#2、配置自己的用户名和邮箱" class="headerlink" title="2、配置自己的用户名和邮箱"></a>2、配置自己的用户名和邮箱</h3><p>git config –global user.name “你的名字或昵称”</p>
<p>git config –global user.email “你的邮箱”</p>
<h2 id="三、准备工作已经就绪，准备上传自己的第一个项目"><a href="#三、准备工作已经就绪，准备上传自己的第一个项目" class="headerlink" title="三、准备工作已经就绪，准备上传自己的第一个项目"></a>三、准备工作已经就绪，准备上传自己的第一个项目</h2><h3 id="1、在码云的个人主页，点击来新建项目"><a href="#1、在码云的个人主页，点击来新建项目" class="headerlink" title="1、在码云的个人主页，点击来新建项目"></a>1、在码云的个人主页，点击来新建项目</h3><h3 id="2、完成自己对项目的描述，可以选择是否公开这个项目，点击创建就创建好了自己的远程代码仓库，然后可以编辑README-md文件，来对项目进行描述。"><a href="#2、完成自己对项目的描述，可以选择是否公开这个项目，点击创建就创建好了自己的远程代码仓库，然后可以编辑README-md文件，来对项目进行描述。" class="headerlink" title="2、完成自己对项目的描述，可以选择是否公开这个项目，点击创建就创建好了自己的远程代码仓库，然后可以编辑README.md文件，来对项目进行描述。"></a>2、完成自己对项目的描述，可以选择是否公开这个项目，点击创建就创建好了自己的远程代码仓库，然后可以编辑README.md文件，来对项目进行描述。</h3><h3 id="3、在要提交的项目文件夹上右键，选择Git-Bash-Here"><a href="#3、在要提交的项目文件夹上右键，选择Git-Bash-Here" class="headerlink" title="3、在要提交的项目文件夹上右键，选择Git Bash Here"></a>3、在要提交的项目文件夹上右键，选择Git Bash Here</h3><h3 id="4、在出现的命令框中"><a href="#4、在出现的命令框中" class="headerlink" title="4、在出现的命令框中"></a>4、在出现的命令框中</h3><p>git init   ———-初始化git仓库</p>
<p>git remote add origin 你的项目地址 //注:项目地址形式为:<a href="http://git.oschina.net/xxx/xxx.git或者" target="_blank" rel="noopener">http://git.oschina.net/xxx/xxx.git或者</a> git@git.oschina.net:xxx/xxx.git     用来连接远程码云</p>
<h3 id="5、开始第一次上传你的项目"><a href="#5、开始第一次上传你的项目" class="headerlink" title="5、开始第一次上传你的项目"></a>5、开始第一次上传你的项目</h3><p>git add .      –将项目中的所有文件上传</p>
<p>git commit -m ‘对上传文件的注释’</p>
<p>git push origin master    –正式上传至码云中，若上传有问题，可以试试   git push origin master -f 表示舍弃线上的文件，强制推送</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>spider 使用 Xpath</title>
    <url>/blog/2020/04/17/spider%20%E4%BD%BF%E7%94%A8%20Xpath/</url>
    <content><![CDATA[<p>xpath</p>
<pre><code class="python">#编码流程
1.导包
from lxml import etree
2.实例化etree对象
tree = etree。HTML(res.text)
3.xpath定位节点，获取节点的属性或正文文本
tag_attribute_text = tree.xpath(&#39;表达式&#39;)</code></pre>
<a id="more"></a>
<pre><code class="python">#xpath的基础和语法
nodeName：根据节点进行定位
.  ：当前
./ ：从当前的根节点选取子节点
.//：从当前节点的任意位置选取子节点
nodeName[@attribute=&quot;value&quot;]:根据节点属性定位节点
text():获取节点的文本
@attributename:获取节点的属性

#单属性多值匹配：contains
xpath(&#39;//div[contains(@class,&#39;divtag&#39;)]&#39;)
&lt;div class=&quot;divtag item&quot;&gt;我是div标签&lt;div&gt;
&lt;div class=&quot;item&quot; name=&quot;hello&quot;&gt;我是div标签&lt;div&gt;

#多属性匹配：and

//div[@class=&quot;item&quot; and @name=&quot;hello&quot;]

#按序选择

1.根据索引定位：索引从1开始
2.last(函数)：最后一个，倒数第二个：last()-1
3.position()函数:前三个--&gt;position()&lt;4</code></pre>
<p>BeautifulSoup库使用</p>
<p>BeautifulSoup也是一个解析库</p>
<p>BS</p>
<pre><code class="python">#</code></pre>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是爬虫？</title>
    <url>/blog/2020/04/17/reptile/</url>
    <content><![CDATA[<p>网络爬虫也叫做网络机器人，可以代替人们自动地在互联网中进行数据信息的采集与整理。在大数据时代，信息的采集是一项重要的工作，如果单纯靠人力进行信息采集，不仅低效繁琐，搜集的成本也会提高。</p>
<p>此时，我们可以使用网络爬虫对数据信息进行自动采集，比如应用于搜索引擎中对站点进行爬取收录，应用于数据分析与挖掘中对数据进行采集，应用于金融分析中对金融数据进行采集，除此之外，还可以将网络爬虫应用于舆情监测与分析、目标客户数据的收集等各个领域。</p>
<p>当然，要学习网络爬虫开发，首先需要认识网络爬虫，本文将带领大家一起认识几种典型的网络爬虫，并了解网络爬虫的各项常见功能。</p>
<h2 id="一、什么是网络爬虫"><a href="#一、什么是网络爬虫" class="headerlink" title="一、什么是网络爬虫"></a>一、什么是网络爬虫</h2><p>随着大数据时代的来临，网络爬虫在互联网中的地位将越来越重要。互联网中的数据是海量的，如何自动高效地获取互联网中我们感兴趣的信息并为我们所用是一个重要的问题，而爬虫技术就是为了解决这些问题而生的。</p>
<p>我们感兴趣的信息分为不同的类型：如果只是做搜索引擎，那么感兴趣的信息就是互联网中尽可能多的高质量网页；如果要获取某一垂直领域的数据或者有明确的检索需求，那么感兴趣的信息就是根据我们的检索和需求所定位的这些信息，此时，需要过滤掉一些无用信息。前者我们称为通用网络爬虫，后者我们称为聚焦网络爬虫。</p>
<h3 id="1-初识网络爬虫"><a href="#1-初识网络爬虫" class="headerlink" title="1. 初识网络爬虫"></a>1. 初识网络爬虫</h3><p>网络爬虫又称网络蜘蛛、网络蚂蚁、网络机器人等，可以自动化浏览网络中的信息，当然浏览信息的时候需要按照我们制定的规则进行，这些规则我们称之为网络爬虫算法。使用Python可以很方便地编写出爬虫程序，进行互联网信息的自动化检索。</p>
<p>搜索引擎离不开爬虫，比如百度搜索引擎的爬虫叫作百度蜘蛛（Baiduspider）。百度蜘蛛每天会在海量的互联网信息中进行爬取，爬取优质信息并收录，当用户在百度搜索引擎上检索对应关键词时，百度将对关键词进行分析处理，从收录的网页中找出相关网页，按照一定的排名规则进行排序并将结果展现给用户。</p>
<p>在这个过程中，百度蜘蛛起到了至关重要的作用。那么，如何覆盖互联网中更多的优质网页？又如何筛选这些重复的页面？这些都是由百度蜘蛛爬虫的算法决定的。采用不同的算法，爬虫的运行效率会不同，爬取结果也会有所差异。</p>
<p>所以，我们在研究爬虫的时候，不仅要了解爬虫如何实现，还需要知道一些常见爬虫的算法，如果有必要，我们还需要自己去制定相应的算法，在此，我们仅需要对爬虫的概念有一个基本的了解。</p>
<p>除了百度搜索引擎离不开爬虫以外，其他搜索引擎也离不开爬虫，它们也拥有自己的爬虫。比如360的爬虫叫360Spider，搜狗的爬虫叫Sogouspider，必应的爬虫叫Bingbot。</p>
<p>如果想自己实现一款小型的搜索引擎，我们也可以编写出自己的爬虫去实现，当然，虽然可能在性能或者算法上比不上主流的搜索引擎，但是个性化的程度会非常高，并且也有利于我们更深层次地理解搜索引擎内部的工作原理。</p>
<p>大数据时代也离不开爬虫，比如在进行大数据分析或数据挖掘时，我们可以去一些比较大型的官方站点下载数据源。但这些数据源比较有限，那么如何才能获取更多更高质量的数据源呢？此时，我们可以编写自己的爬虫程序，从互联网中进行数据信息的获取。所以在未来，爬虫的地位会越来越重要。</p>
<h3 id="2-为什么要学网络爬虫"><a href="#2-为什么要学网络爬虫" class="headerlink" title="2. 为什么要学网络爬虫"></a>2. 为什么要学网络爬虫</h3><p>我们初步认识了网络爬虫，但是为什么要学习网络爬虫呢？要知道，只有清晰地知道我们的学习目的，才能够更好地学习这一项知识，我们将会为大家分析一下学习网络爬虫的原因。</p>
<p>当然，不同的人学习爬虫，可能目的有所不同，在此，我们总结了4种常见的学习爬虫的原因。</p>
<p>1）学习爬虫，可以私人订制一个搜索引擎，并且可以对搜索引擎的数据采集工作原理进行更深层次地理解。</p>
<p>有的朋友希望能够深层次地了解搜索引擎的爬虫工作原理，或者希望自己能够开发出一款私人搜索引擎，那么此时，学习爬虫是非常有必要的。</p>
<p>简单来说，我们学会了爬虫编写之后，就可以利用爬虫自动地采集互联网中的信息，采集回来后进行相应的存储或处理，在需要检索某些信息的时候，只需在采集回来的信息中进行检索，即实现了私人的搜索引擎。</p>
<p>当然，信息怎么爬取、怎么存储、怎么进行分词、怎么进行相关性计算等，都是需要我们进行设计的，爬虫技术主要解决信息爬取的问题。</p>
<p>2）大数据时代，要进行数据分析，首先要有数据源，而学习爬虫，可以让我们获取更多的数据源，并且这些数据源可以按我们的目的进行采集，去掉很多无关数据。</p>
<p>在进行大数据分析或者进行数据挖掘的时候，数据源可以从某些提供数据统计的网站获得， 也可以从某些文献或内部资料中获得，但是这些获得数据的方式，有时很难满足我们对数据的需求，而手动从互联网中去寻找这些数据，则耗费的精力过大。</p>
<p>此时就可以利用爬虫技术，自动地从互联网中获取我们感兴趣的数据内容，并将这些数据内容爬取回来，作为我们的数据源，从而进行更深层次的数据分析，并获得更多有价值的信息。</p>
<p>3）对于很多SEO从业者来说，学习爬虫，可以更深层次地理解搜索引擎爬虫的工作原理，从而可以更好地进行搜索引擎优化。</p>
<p>既然是搜索引擎优化，那么就必须要对搜索引擎的工作原理非常清楚，同时也需要掌握搜索引擎爬虫的工作原理，这样在进行搜索引擎优化时，才能知己知彼，百战不殆。</p>
<p>4）从就业的角度来说，爬虫工程师目前来说属于紧缺人才，并且薪资待遇普遍较高，所以，深层次地掌握这门技术，对于就业来说，是非常有利的。</p>
<p>有些朋友学习爬虫可能为了就业或者跳槽。从这个角度来说，爬虫工程师方向是不错的选择之一，因为目前爬虫工程师的需求越来越大，而能够胜任这方面岗位的人员较少，所以属于一个比较紧缺的职业方向，并且随着大数据时代的来临，爬虫技术的应用将越来越广泛，在未来会拥有很好的发展空间。</p>
<p>除了以上为大家总结的4种常见的学习爬虫的原因外，可能你还有一些其他学习爬虫的原因，总之，不管是什么原因，理清自己学习的目的，就可以更好地去研究一门知识技术，并坚持下来。</p>
<h3 id="3-网络爬虫的组成"><a href="#3-网络爬虫的组成" class="headerlink" title="3. 网络爬虫的组成"></a>3. 网络爬虫的组成</h3><p>接下来，我们将介绍网络爬虫的组成。网络爬虫由控制节点、爬虫节点、资源库构成。<br>可以看到，网络爬虫中可以有多个控制节点，每个控制节点下可以有多个爬虫节点，控制节点之间可以互相通信，同时，控制节点和其下的各爬虫节点之间也可以进行互相通信，属于同一个控制节点下的各爬虫节点间，亦可以互相通信。</p>
<p>控制节点，也叫作爬虫的中央控制器，主要负责根据URL地址分配线程，并调用爬虫节点进行具体的爬行。</p>
<p>爬虫节点会按照相关的算法，对网页进行具体的爬行，主要包括下载网页以及对网页的文本进行处理，爬行后，会将对应的爬行结果存储到对应的资源库中。</p>
<h3 id="4-网络爬虫的类型"><a href="#4-网络爬虫的类型" class="headerlink" title="4. 网络爬虫的类型"></a>4. 网络爬虫的类型</h3><p>现在我们已经基本了解了网络爬虫的组成，那么网络爬虫具体有哪些类型呢？</p>
<p>网络爬虫按照实现的技术和结构可以分为通用网络爬虫、聚焦网络爬虫、增量式网络爬虫、深层网络爬虫等类型。在实际的网络爬虫中，通常是这几类爬虫的组合体。</p>
<h4 id="4-1-通用网络爬虫"><a href="#4-1-通用网络爬虫" class="headerlink" title="4.1 通用网络爬虫"></a>4.1 通用网络爬虫</h4><p>首先我们为大家介绍通用网络爬虫（General Purpose Web Crawler）。通用网络爬虫又叫作全网爬虫，顾名思义，通用网络爬虫爬取的目标资源在全互联网中。</p>
<p>通用网络爬虫所爬取的目标数据是巨大的，并且爬行的范围也是非常大的，正是由于其爬取的数据是海量数据，故而对于这类爬虫来说，其爬取的性能要求是非常高的。这种网络爬虫主要应用于大型搜索引擎中，有非常高的应用价值。</p>
<p>通用网络爬虫主要由初始URL集合、URL队列、页面爬行模块、页面分析模块、页面数据库、链接过滤模块等构成。通用网络爬虫在爬行的时候会采取一定的爬行策略，主要有深度优先爬行策略和广度优先爬行策略。</p>
<h4 id="4-2-聚焦网络爬虫"><a href="#4-2-聚焦网络爬虫" class="headerlink" title="4.2 聚焦网络爬虫"></a>4.2 聚焦网络爬虫</h4><p>聚焦网络爬虫（Focused Crawler）也叫主题网络爬虫，顾名思义，聚焦网络爬虫是按照预先定义好的主题有选择地进行网页爬取的一种爬虫，聚焦网络爬虫不像通用网络爬虫一样将目标资源定位在全互联网中，而是将爬取的目标网页定位在与主题相关的页面中，此时，可以大大节省爬虫爬取时所需的带宽资源和服务器资源。</p>
<p>聚焦网络爬虫主要应用在对特定信息的爬取中，主要为某一类特定的人群提供服务。</p>
<p>聚焦网络爬虫主要由初始URL集合、URL队列、页面爬行模块、页面分析模块、页面数据库、链接过滤模块、内容评价模块、链接评价模块等构成。内容评价模块可以评价内容的重要性，同理，链接评价模块也可以评价出链接的重要性，然后根据链接和内容的重要性，可以确定哪些页面优先访问。</p>
<p>聚焦网络爬虫的爬行策略主要有4种，即基于内容评价的爬行策略、基于链接评价的爬行策略、基于增强学习的爬行策略和基于语境图的爬行策略。关于聚焦网络爬虫具体的爬行策略，我们将在下文中进行详细分析。</p>
<h4 id="4-3-增量式网络爬虫"><a href="#4-3-增量式网络爬虫" class="headerlink" title="4.3 增量式网络爬虫"></a>4.3 增量式网络爬虫</h4><p>增量式网络爬虫（Incremental Web Crawler），所谓增量式，对应着增量式更新。</p>
<p>增量式更新指的是在更新的时候只更新改变的地方，而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只爬取内容发生变化的网页或者新产生的网页，对于未发生内容变化的网页，则不会爬取。</p>
<p>增量式网络爬虫在一定程度上能够保证所爬取的页面，尽可能是新页面。</p>
<h4 id="4-4-深层网络爬虫"><a href="#4-4-深层网络爬虫" class="headerlink" title="4.4 深层网络爬虫"></a>4.4 深层网络爬虫</h4><p>深层网络爬虫（Deep Web Crawler），可以爬取互联网中的深层页面，在此我们首先需要了解深层页面的概念。</p>
<p>在互联网中，网页按存在方式分类，可以分为表层页面和深层页面。所谓的表层页面，指的是不需要提交表单，使用静态的链接就能够到达的静态页面；而深层页面则隐藏在表单后面，不能通过静态链接直接获取，是需要提交一定的关键词之后才能够获取得到的页面。</p>
<p>在互联网中，深层页面的数量往往比表层页面的数量要多很多，故而，我们需要想办法爬取深层页面。</p>
<p>爬取深层页面，需要想办法自动填写好对应表单，所以，深层网络爬虫最重要的部分即为表单填写部分。</p>
<p>深层网络爬虫主要由URL列表、LVS列表（LVS指的是标签/数值集合，即填充表单的数据源）、爬行控制器、解析器、LVS控制器、表单分析器、表单处理器、响应分析器等部分构成。</p>
<p>深层网络爬虫表单的填写有两种类型：</p>
<p>第一种是基于领域知识的表单填写，简单来说就是建立一个填写表单的关键词库，在需要填写的时候，根据语义分析选择对应的关键词进行填写；</p>
<p>第二种是基于网页结构分析的表单填写，简单来说，这种填写方式一般是领域知识有限的情况下使用，这种方式会根据网页结构进行分析，并自动地进行表单填写。</p>
<p>以上，为大家介绍了网络爬虫中常见的几种类型，希望读者能够对网络爬虫的分类有一个基本的了解。</p>
<h3 id="5-爬虫扩展——聚焦爬虫"><a href="#5-爬虫扩展——聚焦爬虫" class="headerlink" title="5. 爬虫扩展——聚焦爬虫"></a>5. 爬虫扩展——聚焦爬虫</h3><p>由于聚焦爬虫可以按对应的主题有目的地进行爬取，并且可以节省大量的服务器资源和带宽资源，具有很强的实用性，所以在此，我们将对聚焦爬虫进行详细讲解.</p>
<p>首先，聚焦爬虫拥有一个控制中心，该控制中心负责对整个爬虫系统进行管理和监控，主要包括控制用户交互、初始化爬行器、确定主题、协调各模块之间的工作、控制爬行过程等方面。</p>
<p>然后，将初始的URL集合传递给URL队列，页面爬行模块会从URL队列中读取第一批URL列表，然后根据这些URL地址从互联网中进行相应的页面爬取。</p>
<p>爬取后，将爬取到的内容传到页面数据库中存储，同时，在爬行过程中，会爬取到一些新的URL，此时，需要根据我们所定的主题使用链接过滤模块过滤掉无关链接，再将剩下来的URL链接根据主题使用链接评价模块或内容评价模块进行优先级的排序。完成后，将新的URL地址传递到URL队列中，供页面爬行模块使用。</p>
<p>另一方面，将页面爬取并存放到页面数据库后，需要根据主题使用页面分析模块对爬取到的页面进行页面分析处理，并根据处理结果建立索引数据库，用户检索对应信息时，可以从索引数据库中进行相应的检索，并得到对应的结果。</p>
<p>这就是聚焦爬虫的主要工作流程，了解聚焦爬虫的主要工作流程有助于我们编写聚焦爬虫，使编写的思路更加清晰。</p>
<h2 id="二、网络爬虫技能总览"><a href="#二、网络爬虫技能总览" class="headerlink" title="二、网络爬虫技能总览"></a>二、网络爬虫技能总览</h2><h3 id="1-网络爬虫技能总览图"><a href="#1-网络爬虫技能总览图" class="headerlink" title="1. 网络爬虫技能总览图"></a>1. 网络爬虫技能总览图</h3><p>网络爬虫可以代替手工做很多事情，比如可以用于做搜索引擎，也可以爬取网站上面的图片，比如有些朋友将某些网站上的图片全部爬取下来，集中进行浏览，同时，网络爬虫也可以用于金融投资领域，比如可以自动爬取一些金融信息，并进行投资分析等。</p>
<p>有时，我们比较喜欢的新闻网站可能有几个，每次都要分别打开这些新闻网站进行浏览，比较麻烦。此时可以利用网络爬虫，将这多个新闻网站中的新闻信息爬取下来，集中进行阅读。</p>
<p>有时，我们在浏览网页上的信息的时候，会发现有很多广告。此时同样可以利用爬虫将对应网页上的信息爬取过来，这样就可以自动的过滤掉这些广告，方便对信息的阅读与使用。</p>
<p>有时，我们需要进行营销，那么如何找到目标客户以及目标客户的联系方式是一个关键问题。我们可以手动地在互联网中寻找，但是这样的效率会很低。此时，我们利用爬虫，可以设置对应的规则，自动地从互联网中采集目标用户的联系方式等数据，供我们进行营销使用。</p>
<p>有时，我们想对某个网站的用户信息进行分析，比如分析该网站的用户活跃度、发言数、热门文章等信息，如果我们不是网站管理员，手工统计将是一个非常庞大的工程。此时，可以利用爬虫轻松将这些数据采集到，以便进行进一步分析，而这一切爬取的操作，都是自动进行的，我们只需要编写好对应的爬虫，并设计好对应的规则即可。</p>
<p>除此之外，爬虫还可以实现很多强大的功能。总之，爬虫的出现，可以在一定程度上代替手工访问网页，从而，原先我们需要人工去访问互联网信息的操作，现在都可以用爬虫自动化实现，这样可以更高效率地利用好互联网中的有效信息。</p>
<h3 id="2-搜索引擎核心"><a href="#2-搜索引擎核心" class="headerlink" title="2. 搜索引擎核心"></a>2. 搜索引擎核心</h3><p>爬虫与搜索引擎的关系是密不可分的，既然提到了网络爬虫，就免不了提到搜索引擎，在此，我们将对搜索引擎的核心技术进行一个简单的讲解。</p>
<p>图2-2所示为搜索引擎的核心工作流程。首先，搜索引擎会利用爬虫模块去爬取互联网中的网页，然后将爬取到的网页存储在原始数据库中。爬虫模块主要包括控制器和爬行器，控制器主要进行爬行的控制，爬行器则负责具体的爬行任务。</p>
<p>然后，会对原始数据库中的数据进行索引，并存储到索引数据库中。</p>
<p>当用户检索信息的时候，会通过用户交互接口输入对应的信息，用户交互接口相当于搜索引擎的输入框，输入完成之后，由检索器进行分词等操作，检索器会从索引数据库中获取数据进行相应的检索处理。</p>
<p>用户输入对应信息的同时，会将用户的行为存储到用户日志数据库中，比如用户的IP地址、用户所输入的关键词等等。随后，用户日志数据库中的数据会交由日志分析器进行处理。日志分析器会根据大量的用户数据去调整原始数据库和索引数据库，改变排名结果或进行其他操作。</p>
<p>简单来说，检索是一种行为，而索引是一种属性。比如一家超市，里面有大量的商品，为了能够快速地找到这些商品，我们会将这些商品进行分组，比如有日常用品类商品、饮料类商品、服装类商品等组别，此时，这些商品的组名我们称之为索引，索引由索引器控制。</p>
<p>如果，有一个用户想要找到某一个商品，那么需要在超市的大量商品中寻找，这个过程，我们称之为检索。如果有一个好的索引，则可以提高检索的效率；若没有索引，则检索的效率会很低。</p>
<p>比如，一个超市里面的商品如果没有进行分类，那么用户要在海量的商品中寻找某一种商品，则会比较费力。</p>
<h3 id="3-用户爬虫的那些事儿"><a href="#3-用户爬虫的那些事儿" class="headerlink" title="3. 用户爬虫的那些事儿"></a>3. 用户爬虫的那些事儿</h3><p>用户爬虫是网络爬虫中的一种类型。所谓用户爬虫，指的是专门用来爬取互联网中用户数据的一种爬虫。由于互联网中的用户数据信息，相对来说是比较敏感的数据信息，所以，用户爬虫的利用价值也相对较高。</p>
<p>利用用户爬虫可以做大量的事情，接下来我们一起来看一下利用用户爬虫所做的一些有趣的事情吧。</p>
<p>2015年，有知乎网友对知乎的用户数据进行了爬取，然后进行对应的数据分析，便得到了知乎上大量的潜在数据，比如：</p>
<p>知乎上注册用户的男女比例：男生占例多于60%。</p>
<p>知乎上注册用户的地区：北京的人口占据比重最大，多于30%。</p>
<p>知乎上注册用户从事的行业：从事互联网行业的用户占据比重最大，同样多于30%。</p>
<p>除此之外，只要我们细心发掘，还可以挖掘出更多的潜在数据，而要分析这些数据，则必须要获取到这些用户数据，此时，我们可以使用网络爬虫技术轻松爬取到这些有用的用户信息。</p>
<p>同样，在2015年，有网友爬取了3000万QQ空间的用户信息，并同样从中获得了大量潜在数据，比如：</p>
<p>QQ空间用户发说说的时间规律：晚上22点左右，平均发说说的数量是一天中最多的时候。</p>
<p>QQ空间用户的出生月份分布：1月份和10月份出生的用户较多。</p>
<p>QQ空间用户的年龄阶段分布：出生于1990年到1995年的用户相对来说较多。</p>
<p>QQ空间用户的性别分布：男生占比多于50%，女生占比多于30%，未填性别的占10%左右。</p>
<p>除了以上两个例子之外，用户爬虫还可以做很多事情，比如爬取淘宝的用户信息，可以分析淘宝用户喜欢什么商品，从而更有利于我们对商品的定位等。</p>
<p>由此可见，利用用户爬虫可以获得很多有趣的潜在信息，那么这些爬虫难吗？其实不难，相信你也能写出这样的爬虫。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序 ，个人小例子</title>
    <url>/blog/2020/04/11/C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="运行效果！！"><a href="#运行效果！！" class="headerlink" title="运行效果！！"></a>运行效果！！</h3><p>   <img src="/img/C.png" srcset="/img/loading.gif" alt="hexo_themes"></p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;windows.h&quot;
void s1(char arr[],int len){//项目一 
    for(int a=0;a&lt;len;a++){
        printf(&quot;请输入第%d个元素：&quot;,a+1); //循环输入 
        scanf(&quot;%d&quot;,&amp;arr[a]); 
    }
}
void s2(char arr[],int len){//项目二 
    int w=0;//定义总额 
    for(int a=0;a&lt;len;a++){//循环相加 
        w=w+arr[a];
    }
    printf(&quot;数组平均值：%d&quot;,w/len); //输出平均值 
}
void s3(char arr[],int len){//项目三 
    int x;//定义变量 
    for(int a=0;a&lt;len;a++){//双循环实现交换 
        for(int b=0;b&lt;b-len;b++){
            if(arr[a]&lt;arr[a+1]){
                x=arr[a];
                arr[a]=arr[a+1];
                arr[a+1]=x;
            }
        }
            printf(&quot;%d  &quot;,arr[a]); //循环排序输出 

    }
}
void sss(){//定义菜单列表 

    printf(&quot;\t\t欢迎来闯关\n&quot;); 
    printf(&quot;\t1：输入5个整数\n&quot;); 
    printf(&quot;\t2：求平均值\n&quot;); 
    printf(&quot;\t3：排序--降序\n&quot;); 
    printf(&quot;\t0：安全退出！\n&quot;); 
    while(1){
        int a;
        char arr[5];//死循环输入编号 
        printf(&quot;\n请输入功能编号：&quot;); 
        scanf(&quot;%d&quot;,&amp;a); 
        switch(a){
            case 1:{
                s1(arr,5);//调用项目一 
                break;
            }
            case 2:{
                s2(arr,5);//调用项目二 
                break;
            }
            case 3:{ 
            s3(arr,5);//调用项目三 
                break;
            }
            case 0:{
                exit(0);//退出死循环 
                break;
            }
        }
    }
}
main(){
sss();//调用菜单列表 
}


</code></pre>]]></content>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/blog/2020/04/08/%E5%88%9D%E5%AD%A6python%E7%88%AC%E8%99%AB%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>爬虫概述&amp;协议</p>
<p>1.爬虫概述</p>
<p>​    1.1爬虫概述</p>
<p>​    1.2爬虫语言</p>
<p>​    1.3爬虫分类</p>
<p>​    1.4爬虫课程概览</p>
<p>2.协议</p>
<p>​    2.1HTTP协议与HTTPS协议</p>
<p>​    2.2服务端常见端口</p>
<p>3.开发准备</p>
<p>​    3.1web端</p>
<p>​    3.2抓包工具</p>
<a id="more"></a>
<h2 id="爬虫的概念"><a href="#爬虫的概念" class="headerlink" title="爬虫的概念"></a>爬虫的概念</h2><p>爬虫的语言：PHP，C/C++，Python，Golang</p>
<h2 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h2><p>通用爬虫：爬取页面数为搜索引擎提供检索服务</p>
<p>robots协议：约束通用爬虫和聚焦爬虫</p>
<pre><code class="python">2.聚焦爬虫
#概念 ：
    聚焦爬虫针对某一领域根据特定要求实现的爬虫程序，抓取需要的数据（垂直领域</code></pre>
<p>​    增量式爬虫</p>
<p>​    深度爬虫</p>
<p>网络协议：</p>
<p>​    OSI七层模型/TCP/IP五层模型</p>
<p>​        应用层（表示层，会话层）：HTTP，HTTPS，SSH（远程登录），FIP</p>
<p>​        传输层：TCP/UDP</p>
<p>​        网络层：IP协议</p>
<p>​        数据链路层：ARP协议</p>
<p>​        物理层：以太网协议</p>
<h1 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h1><p>1.爬虫概述</p>
<p>爬虫，又称网页蜘蛛或网络机器人</p>
<p>爬虫是模拟人操作客户端（浏览器。APP） 、向服务器发起网络请求</p>
<p>​    1.模拟：用爬虫程序伪装出人的行为，避免被服务端识别为爬虫程序</p>
<p>​    2.客户端：浏览器，App都可以实现人与服务器之间的交互行为，应用客户端从服务器获取数据</p>
<p>​    3.自动化：数据量较小可以人工获取数据，但往往在公司中爬取的数据在百万条，千万条级别的，所以要程序自动化获取数据，</p>
<h1 id="爬虫语言"><a href="#爬虫语言" class="headerlink" title="爬虫语言"></a>爬虫语言</h1><p>​    爬虫的语言：PHP，C/C++，Python，Golang</p>
<p>PHP：并发能力差，对多线程和多进程支持不好，数据量较大时爬虫效率</p>
<p>C/C++：语言效率高，但学习成本高，对程序员的技术能力要求极高，所以目前还停留在研究层面，市场需求量很小</p>
<p>Java：python爬虫的主要竞争对手，由于Java语言的特点，代码臃肿，代码量大，维护成本重构成本高，开发效率低.</p>
<p>python：语法简单，学习成本较低，对新手比较友好，python语言良好发的生态，大量库和框架的支持是python爬虫目前处于爬虫全的主导地位。   </p>
<h1 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h1><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p>
<ul>
<li>CPython<ul>
<li>c语言开发的 使用最广的解释器</li>
</ul>
</li>
<li>IPython<ul>
<li>基于cpython之上的一个交互式计时器 交互方式增强 功能和cpython一样</li>
</ul>
</li>
<li>PyPy<ul>
<li>目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率</li>
</ul>
</li>
<li>JPython<ul>
<li>运行在Java上的解释器 直接把python代码编译成Java字节码执行</li>
</ul>
</li>
<li>IronPython<ul>
<li>运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码</li>
</ul>
</li>
</ul>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>1.桌面运维</p>
<p>2.机房运维</p>
<p>3.系统运维</p>
<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><p>安装：</p>
<pre><code class="python">pip install virtualenvwrapper-win</code></pre>
<p>常用命令：</p>
<pre><code class="python">mkvirtualenv envname  #创建虚拟环境并自动切换到该环境下
workon envname  #切换到某虚拟环境下
pip list  #查看安装过的包
rmvirtualena envname   #删除虚拟环境
deactivate  #退出虚拟环境
lsvirtualenv  #列出所有常见的虚拟环境
mkvirtualenv  --python==C:\...\python.exe envname  #指定python解释器创建虚拟环境</code></pre>
<p>生成所有包的名称和版本号</p>
<pre><code class="python">pip freeze &gt; requirements.txt</code></pre>
<p>下载文件中所有的包和对应的版本号</p>
<pre><code class="python">pip install -r ./requirements.txt</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue  &amp;&amp;  Dajngo &amp;&amp; 微博三方登录</title>
    <url>/blog/2020/04/08/Vue%20%20&amp;&amp;%20%20Dajngo%20&amp;&amp;%20%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h3 id="微博三方登录"><a href="#微博三方登录" class="headerlink" title="微博三方登录"></a>微博三方登录</h3><ol>
<li><p>在Vue的登录页面添加微博的logo ，并设置点击事件</p>
<pre><code>&lt;img src=&quot;http://localhost:8000/static/sina.png&quot; @click=&quot;sina&quot; /&gt;
</code></pre></li>
<li><p>在  scrapy里自定义方法，拼接url并访问</p>
<a id="more"></a>
<pre><code>&lt;script&gt;
export default {

data () {
​    return {
​    }

},
mounted:function(){
},

methods:{
​    //新浪微博登录
​    sina:function(){
​            //组装url
​            let url = &quot;https://api.weibo.com/oauth2/authorize?client_id=********&amp;redirect_uri=http://127.0.0.1:8000/md_admin/weibo&quot;;
​            //进行跳转
​            window.location.href = url;
​    }
}
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;</code></pre></li>
</ol>
<pre><code>url = &quot;https://api.weibo.com/oauth2/authorize?client_id=********&amp;redirect_uri=http://127.0.0.1:8000/md_admin/weibo&quot;</code></pre><p>这个client_id 是 App Key 在微博开放平台 创建的应用</p>
<p><img src="/img/0200404151....526.jpg" srcset="/img/loading.gif" alt="0200404151....526"></p>
<p>这个 redirect_uri 是回调接口是本地Django的 ，在在微博开放平台  /   高级信息 可以看到</p>
<p><img src="/img/sssss0200404151946.jpg" srcset="/img/loading.gif" alt="sssss0200404151946"></p>
<p>建议两个路由写一样的！！</p>
<h5 id="以上是Vue-，然后我们开始写Django"><a href="#以上是Vue-，然后我们开始写Django" class="headerlink" title="以上是Vue ，然后我们开始写Django"></a>以上是Vue ，然后我们开始写Django</h5><p>在django的视图文件里定义方法</p>
<pre><code>#新浪微博回调
def wb_back(request):
    #获取code
    code = request.GET.get(&#39;code&#39;)
    #定义微博认证地址
    access_token_url = &quot;https://api.weibo.com/oauth2/access_token&quot;
    #参数
    res = requests.post(
    access_token_url,
    data={

        &quot;client_id&quot;:&quot;*******&quot;,    #这里写入App Key， 以上有图
        &quot;client_secret&quot;:&quot;****************&quot;,#这里写入App ， 以上有图
         &quot;grant_type&quot;:&quot;authorization_code&quot;,
        &quot;code&quot;:code,
        &quot;redirect_uri&quot;:&quot;http://127.0.0.1:8000/md_admin/weibo&quot;#这里写入回调路由 ， 以上有图
    })

    #转换类型
    res = json.loads(res.text)

    print(res[&#39;access_token&#39;])

     return HttpResponse(res[&#39;access_token&#39;])</code></pre>]]></content>
      <categories>
        <category>Vue</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础 面试题</title>
    <url>/blog/2020/04/08/Python%20%E5%9F%BA%E7%A1%80%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="解释一下Python中的三元运算"><a href="#解释一下Python中的三元运算" class="headerlink" title="解释一下Python中的三元运算"></a>解释一下Python中的三元运算</h5><blockquote>
<p>[on true] if [expression] else [on false]</p>
</blockquote>
<p>如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句</p>
<pre><code>a,b=2,3
min=a if a&lt;b else b
min</code></pre><h5 id="GIL-全局解释器锁（英语：Global-Interpreter-Lock，缩写GIL），"><a href="#GIL-全局解释器锁（英语：Global-Interpreter-Lock，缩写GIL），" class="headerlink" title="GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），"></a>GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），</h5><p>是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。</p>
<h5 id="解释一下Python中的继承"><a href="#解释一下Python中的继承" class="headerlink" title="解释一下Python中的继承"></a>解释一下Python中的继承</h5><p>当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。</p>
<a id="more"></a>
<p>继承能让我们重新使用代码，也能更容易的创建和维护应用。Python支持如下种类的继承：</p>
<p>单继承：一个类继承自单个基类 多继承：一个类继承自多个基类 多级继承：一个类继承自单个基类，后者则继承自另一个基类 分层继承：多个类继承自单个基类 混合继承：两种或多种类型继承的混合</p>
<h5 id="Python-的生命周期"><a href="#Python-的生命周期" class="headerlink" title="Python 的生命周期"></a>Python 的生命周期</h5><p>1.wsgi，请求封装后交给web框架 （Flask、Django）<br>    2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session<br>    3.路由匹配，根据浏览器发送的不同url去匹配不同的视图函数<br>    4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染<br>    5.中间件，对响应的数据进行处理。<br>    6.wsgi，将响应的内容发送给浏览器。</p>
<h5 id="什么是并发和并行？"><a href="#什么是并发和并行？" class="headerlink" title="什么是并发和并行？"></a>什么是并发和并行？</h5><p>-并发：同一时刻只能处理一个任务，但一个时段内可以对多个任务进行交替处理(一个处理器同时处理多个任务)<br> -并行：同一时刻可以处理多个任务(多个处理器或者是多核的处理器同时处理多个不同的任务)<br> -类比：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p>
<h5 id="什么是wsgi、uwsgi、uWsgi？"><a href="#什么是wsgi、uwsgi、uWsgi？" class="headerlink" title="什么是wsgi、uwsgi、uWsgi？"></a>什么是wsgi、uwsgi、uWsgi？</h5><pre><code>WSGI:web服务器网关接口,是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架，实现wsgi协议的模块：  
1.wsgiref,本质上就是编写一个socket服务端，用于接收用户请求(django) 
2.werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)
3.uwsgi:与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议,用于定义传输信息的类型
4.uWSGI:是一个web服务器,实现了WSGI协议,uWSGI协议,http协议,</code></pre><h5 id="进程同步、线程同步"><a href="#进程同步、线程同步" class="headerlink" title="进程同步、线程同步"></a>进程同步、线程同步</h5><pre><code>进程至少包括一个主线程，还有工作线程
线程同步：多线程编程中，解决共享资源冲突的问题
进程同步：多进程编程中，解决共享资源冲突的问题</code></pre><h5 id="nginx是什么-？"><a href="#nginx是什么-？" class="headerlink" title="nginx是什么 ？"></a>nginx是什么 ？</h5><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件代理服务器，<br>在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力<br>在同类型的网页服务器中表现较好</p>
<p>常用于处理高并发！！</p>
<h5 id="Jwt是什么，常用于？"><a href="#Jwt是什么，常用于？" class="headerlink" title="Jwt是什么，常用于？"></a>Jwt是什么，常用于？</h5><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准<br>.该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录<br>一般用于验证用户身份</p>
<h6 id="Jwt分为三部分："><a href="#Jwt分为三部分：" class="headerlink" title="Jwt分为三部分："></a>Jwt分为三部分：</h6><ol>
<li>第一部分我们称它为头部（header),声明类型，这里是jwt</li>
<li>第二部分我们称其为载荷（payloa),存放主要内容。</li>
<li>第三部分是签证,签名（signature).</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB语法</title>
    <url>/blog/2020/04/08/MongoDB%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<pre><code>#查看所有数据库，无法显示空库
show dbs

#查看当前工作的数据库
db

#查看并切换到该数据库 
use a1904

# 插入数据
db.snack.install({&#39;name&#39;:&#39;卫龙&#39;,&#39;price&#39;:22,&#39;data&#39;:1920})

#查看表
show tables

#查询数据：空字典或不写，都是查询所有数据
db.snack

#非关系型数据库 not only  sql
{key:value}

#关系型数据库sql</code></pre><a id="more"></a>
<pre><code>
#删除表
db.snack.drop()

#删除库
db.dropDatabase()


 #建库
 use goods

 #增
 db.snack.insert({&#39;name&#39;:&#39;卫龙&#39;,&#39;price&#39;:&#39;2.5&#39;})
 db.snack.insert([{&#39;name&#39;:&#39;瓜子&#39;,&#39;price&#39;:5},{&#39;name&#39;:&#39;香肠&#39;,&#39;price&#39;,2}])
 db.snack.insertOne({&#39;name&#39;:&#39;可乐&#39;,&#39;price&#39;:&#39;2.5&#39;})
 db.snack.insertMany([{&#39;name&#39;:&#39;花生&#39;,&#39;price&#39;:&#39;5.2&#39;},{&#39;name&#39;:&#39;酸奶&#39;,&#39;price&#39;:6}])

 #查看数据库
 show dbs

 #查看表
 show tables

 #查看所有数据
 db.snack.find()

 #查询数据
 1. 简单操作
     db.snack.find().limit(2)   #分页
     db.snack.find().sort({&#39;price&#39;:1})  #排序  1升序  -1降序

 2.条件查询
     等值查询
     db.snack.find({&#39;price&#39;:2.5})

     and 和  or
     db.snack.find({$or:[{&#39;price&#39;:5.2},{&#39;nmae&#39;:&#39;花生&#39;}]})
     db.snack.find({&#39;price&#39;:2.5},&#39;name&#39;:&#39;可乐&#39;)  #and

3. 非等值查询：大于$gt,  小于$lt, 大于等于$gte , 小于等于$lte, 不等于$ne, g:great t:then e:equal l:little n:not
    db.snack.find({&#39;price&#39;:{$gt:2.5}})
     db.snack.find({&#39;price&#39;:{$lte:2.5}})
     db.snack.find({&#39;price&#39;:{$ne:5.2}})

#售价大于1元，小于6元的
db.snack.find({&#39;price&#39;:{$lt:6,$gt:1}})

#售价大于4 ， 或者小于2.5的
db.snack.find({$or:[{&#39;price&#39;:{$gt:4}},{&#39;price&#39;:{$lt:2.5}}]})</code></pre>]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPRespoens &amp;&amp; Django</title>
    <url>/blog/2020/04/08/HTTPRespoens%20&amp;&amp;%20Django/</url>
    <content><![CDATA[<p><a href="https://www.intmath.com/cg5/katex-mathjax-comparison.php" target="_blank" rel="noopener">KaTeX and MathJax Comparison Demo, currently processed as KaTex</a></p>
<a id="more"></a>
<p><strong>HttpRespoens(str_)-&gt;返回一个序列化或字符串类型的数据并封装成一个HTTPRespoens</strong></p>
<p><strong>request</strong></p>
<ul>
<li>COOKIES:获取到设置的COOKIES值，request.COOKIES.get(‘is_login’)</li>
<li>FILES:从表单中上传来的值 request,FILES.get(‘filename’)</li>
<li>GET:获取get方式上传来的值 request。GET.get(‘id’) -&gt;1   <a href="http://www.a.com/?id=1" target="_blank" rel="noopener">www.a.com/?id=1</a></li>
<li>request.META :  字典类型 ， 封装了请求属性</li>
<li>POST：类字典格式</li>
<li>res.content : 主要的response内漂</li>
<li>session：服务端</li>
<li>set_cookie(key,value)：cookie存在客户端</li>
<li>delete——cookie(key): 删除key的cookie值<!--more-->
式子</li>
</ul>
<p>2 ** 31  =   2147483648</p>
<p>2 ** 32 = 4294967296</p>
<p>2 ** 16 = 65536</p>
<p>2 ** 8 = 256</p>
<p>2 ** 10 = 1024</p>
<p>2 ** 20 = 1048576</p>
<p>max_digits:   全部位数   </p>
<p>decimal_places:   小数位数   </p>
<p>auto_now  :在数据修改是，自动更新当前字段值为当前事件</p>
<p>auto_now_add :在数据创建时，自动维护成当前时间</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git彻底删除历史提交记录的方法</title>
    <url>/blog/2020/04/08/Git%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h6 id="1、查看Git提交记录"><a href="#1、查看Git提交记录" class="headerlink" title="1、查看Git提交记录"></a>1、查看Git提交记录</h6><pre><code class="shell"># git log</code></pre>
<hr>
<h6 id="2、找到需要回滚到的提交点，复制它的hash值"><a href="#2、找到需要回滚到的提交点，复制它的hash值" class="headerlink" title="2、找到需要回滚到的提交点，复制它的hash值"></a>2、找到需要回滚到的提交点，复制它的hash值</h6><p><img src="/yilia-plus-demo/images/2743275-f79de5b6d7280d81.png" srcset="/img/loading.gif" alt=""></p>
<pre><code class="shell"># git reset --hard 你复制的hash值</code></pre>
<a id="more"></a>
<hr>
<h6 id="3、将当前指向的head推到git"><a href="#3、将当前指向的head推到git" class="headerlink" title="3、将当前指向的head推到git"></a>3、将当前指向的head推到git</h6><pre><code class="shell"># git push --force</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Django &amp;&amp; 数据库关系</title>
    <url>/blog/2020/04/08/Django%20&amp;&amp;%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h1><p><strong>一对一：子表从母表中选出一条数据一一对应，母表中选出来一条就少一条，子表不可以再选择母表中已被选择的那条数据</strong></p>
<ul>
<li>orm映射一对一关系</li>
</ul>
<p>一，基类，只有一些共有属性</p>
<p>二，升级类，具有共有属性，其他自己有的属性</p>
<p>null = True 数据库可以储存为空，blank=True   表单处可以验证为空</p>
<h1 id="正向查询和反向查询"><a href="#正向查询和反向查询" class="headerlink" title="正向查询和反向查询"></a>正向查询和反向查询</h1><p>正向查询：表中有字短，直接. 查询</p>
<p>反向查询：表中没有字段，但是可以利用关联表，表名小写，查询</p>
<p>全文检索：contains</p>
<a id="more"></a>


<h1 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h1><p>​               *<em>谁多谁关联 *</em></p>
<p><strong>一对多：子表从母表中选出一条数据一一对应，但母表的这条数据还可以被其他子表数据选择</strong></p>
<p><strong>共同点是在admin中添加数据的话，都会出现一个select选框，但只能单选，因为不论一对一还是一对多，自己都是“一”</strong></p>
<p>models.SET_NULL  指明了当前外键可以为空</p>
<ul>
<li>数据的反向 == 表的正向</li>
<li>表的反向 == 数据的正向</li>
</ul>
<p><strong>实例</strong></p>
<pre><code>class Person(models.Model);
    name = models.CharField(&#39;作者姓名&#39;, max_length=10)

    def __unicode__(self):
    return self.name

class Book(models.Model):
    person = models.ForeignKey(Person, related_name=&#39;person_book&#39;)
    title = models.CharField(&#39;书籍名称&#39;, max_length=10)
    pubtime = models.DateField(&#39;出版时间&#39;)  

    def __unicode__(self):
    return self.name    </code></pre><h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p><strong>多对多关系</strong></p>
<p>举例：一个出版社发表多个文章，一篇文章也可以对多个出版社发表</p>
<p>ManyToManyFiled():关联两个表的函数，但是函数的设置位置，在模型中任选一个即可，不能在两个模型中都设置此函数。</p>
<pre><code>class Publication(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=30, null=True)  # 出版社名称

    class Meta:
        db_table = &#39;Publication&#39;

    def __unicode__(self):
        return &#39;Publication-Name: %s&#39; % self.title

class Article(models.Model):
    id = models.AutoField(primary_key=True)
    headline = models.CharField(max_length=100, null=True)

    # 让文章关联出版社
    publication = models.ManyToManyField(Publication)

    class Meta:
        db_table = &#39;Article&#39;

    def __unicode__(self):
        return &#39;Article-Name: %s&#39; % self.headline
</code></pre><p><strong>创建完数据库模型之后，就需要创建数据库变更文件，应用数据库变更文件创建表的操作。<br>创建数据库变更文件：python manage.py makemigrations<br>应用数据库变更文件：python manage.py migrate</strong></p>
<h1 id="ctrl-alt-r-可以快速定位到当前文件夹"><a href="#ctrl-alt-r-可以快速定位到当前文件夹" class="headerlink" title="ctrl +alt+ r  可以快速定位到当前文件夹"></a>ctrl +alt+ r  可以快速定位到当前文件夹</h1><h1 id="在文件夹中shift-鼠标右键-可以点击power-Shell-窗口"><a href="#在文件夹中shift-鼠标右键-可以点击power-Shell-窗口" class="headerlink" title="在文件夹中shift + 鼠标右键 可以点击power Shell 窗口"></a>在文件夹中shift + 鼠标右键 可以点击power Shell 窗口</h1><h1 id="这个窗口要比cmd窗口要强一些"><a href="#这个窗口要比cmd窗口要强一些" class="headerlink" title="这个窗口要比cmd窗口要强一些"></a>这个窗口要比cmd窗口要强一些</h1><h1 id="shift-alt-↓-快速复制"><a href="#shift-alt-↓-快速复制" class="headerlink" title="shift+alt+↓   快速复制"></a>shift+alt+↓   快速复制</h1><h1 id="shift-D-批量修改"><a href="#shift-D-批量修改" class="headerlink" title="shift+D 批量修改"></a>shift+D 批量修改</h1><ul>
<li><p>Http：短链接</p>
</li>
<li><p>COOKIE：存在于浏览器</p>
</li>
<li><p>SESSION：存在于服务器</p>
</li>
</ul>
<p>  配置一级分类和二级分类的关联关系：</p>
<pre><code>    在一级分类Creatgory中配置一个set类型的二级分类的集合（因为要接收一组二级分类的数据）

     一级分类hbm.xml的配置是一对多&lt;set name=&quot;在ve中的名称&quot;&gt;&lt;key colum=&quot;数据表中的id&quot;/&gt;

                  &lt;ont-many classs=&quot;二级分类的地址&quot;/&gt;  

     &lt;/set&gt;

      在二级分类CreatgroySecond中配置一级分类的对象，

      hbm.xml中配置多对一

       &lt;many-to-one name=&quot;category&quot; class=&quot;com.graduation.library.category.ve.Category&quot; column=&quot;cid&quot;/&gt;</code></pre><p>2.点击一级分类的链接：</p>
<pre><code>      传递一级分类的id

      执行一个方法直接返回页面。

     显示左侧菜单

    显示关联查询（直接从session中获取一级分类的数据需要配置一级分类中的hbm.xml lazy=“”false“”（））</code></pre><p>3.根据二级id查询商品</p>
<pre><code>   传递二级分类idcsid

    传递page=1</code></pre><p>  和一级分类一样</p>
<h1 id="Django配置Mysql数据库"><a href="#Django配置Mysql数据库" class="headerlink" title="Django配置Mysql数据库"></a>Django配置Mysql数据库</h1><p>settings.py</p>
<pre><code class="DATABASES"> &#39;default&#39;: {
       &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
       &#39;NAME&#39;: &#39;Django&#39;,
       &#39;HOST&#39;:&#39;&#39;,
       &#39;USER&#39;:&#39;root&#39;  数据库用户名
       &#39;PASSWORD&#39;:&#39;123&#39; 数据库密码
    }
}</code></pre>
<p>   然后执行：python manage.py  makemigrations</p>
<p>​                      python manage.py migrate</p>
<p>utf8 创建的库最大字符数是191</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>uni-app！</title>
    <url>/blog/2020/04/08/%E6%95%AC%E8%AF%B7%E6%9C%9F%E5%BE%85%EF%BC%815/</url>
    <content><![CDATA[<h3 id="什么是uni-app"><a href="#什么是uni-app" class="headerlink" title="什么是uni-app"></a>什么是uni-app</h3><p>uni-app是一个使用vue.js开发的跨平台应用的前端框架</p>
<p>vue.js是由中国人开发的前端框架，并且开源免费</p>
<p>uni-app的DCloud公司的一款开发移动端App的框架</p>
<p>如果你用Uni-app开发一款App，它的一套代码真的是可牛逼了，</p>
<p>它可以跨8个平台使用，真的是非常的提高了开发App的效率</p>
<p>“一套代码  ，可以多端使用”</p>
<p>而且uni - app的语法 跟vue的语法相同  ，方便学习</p>
<p>那么这8个平台是Android，IOS  ，  H5    ，微信小程序  ，支付宝小程序  ，百度小程序   ，字节跳动小程序  ，QQ小程序 </p>
<p>其实还有一个钉钉小程序 </p>
<h5 id="uni-app的生命周期"><a href="#uni-app的生命周期" class="headerlink" title="uni-app的生命周期"></a>uni-app的生命周期</h5><p>1 加载时  ， 页面正在加载</p>
<p>2 加载完成，onShow展示页面</p>
<p>3onReady ，监听页面初次渲染完成</p>
<p>4 onHide ，隐藏界面。</p>
<p>5 onUnload，页面卸载，销毁</p>
<p>当然还有其他的，都不经常用，就不写了。</p>
<h3 id="uni-app常用的一些事件"><a href="#uni-app常用的一些事件" class="headerlink" title="uni-app常用的一些事件"></a>uni-app常用的一些事件</h3><p>click：“tap”      //点击事件</p>
<p>touchstart：“touchstart”   // 出名开始，多点触摸 ，后面的手指同样会触发</p>
<p>touchmove：“touchmove”   //接触点改变  ，滑动时</p>
<p>touchcancel ：“touchcancel ”   //触摸被取消</p>
<p>touchend ：“touchend ”  //触摸结束，手指离开屏幕</p>
<p>tap：“tap” //  点击一下</p>
<p>longtap ：“longtap”  //按住350毫秒以上</p>
<p>input ：“input”  //输入</p>
<p>change：“change” //变化</p>
<p>submit  ：“submit”  //提交</p>
<p>scroll :”scroll” //滚动事件</p>
<p>errer  ：“errer”   //错误</p>
<p>reset ：“reset ”  //重置</p>
]]></content>
      <categories>
        <category>uni-app！</category>
      </categories>
      <tags>
        <tag>uni-app！</tag>
      </tags>
  </entry>
  <entry>
    <title>python三程</title>
    <url>/blog/2020/04/08/python%E4%B8%89%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="python的常用方法"><a href="#python的常用方法" class="headerlink" title="python的常用方法"></a>python的常用方法</h5><ol>
<li><p>append 用于在列表尾部追加</p>
<p>a = [1,2,3]</p>
<p>a.append(4)</p>
<p>在javascrapy里在尾部插入用push</p>
</li>
</ol>
<h4 id="python的进程"><a href="#python的进程" class="headerlink" title="python的进程"></a>python的进程</h4><p><strong>进程</strong></p>
<p>进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p>
<p>进程是干嘛的呢？</p>
<p>进程就是一个计算机，电脑分配的最小单位，</p>
<p>举个例子，一个电脑我开启一个腾讯会议，就是一个进程，我开QQ聊天，这又是一个进程，我再开微信聊天，</p>
<p>这又是一个进程，所以说进程就是一个可以被电脑执行的任务，</p>
<p>由进程延伸出一个新的概念，</p>
<p>多进程，什么叫多进程呢，其实就是多个进程同时执行，</p>
<p>执行多进程要导包from  multiprocessing</p>
<p>进程的缺点是一个进程，只能干一件事，你想干两件事，就要开两个进程。</p>
<p>还有就是进程间通信是很麻烦的</p>
<p>需要用到Queue（队列），pipeline （管道）</p>
<p>进程一般用于计算，对数据的处理</p>
<p>进程本身是一个cpu密集型，cpu密集型对应的是i/o密集型，</p>
<p><strong>创建进程</strong></p>
<pre><code class="python">from multiprocessing import Process
def func():
    print(&quot;i am subprocess&quot;)

new_process = Process(tartget=func)
print（&quot;i am Parent Process&quot;）</code></pre>
<p>所以就说到了线称，</p>
<p><strong>线程</strong></p>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中</p>
<p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p>
<p>线程间是可以通讯的，解决了进程不能通讯的问题</p>
<p><strong>创建线程</strong></p>
<pre><code class="python">import threading,time

def say_sorry():
    print(&quot;亲爱的！你错啦&quot;)
    time.sleep(1)

def yas():
    print(&quot;不不不，你错啦&quot;)
    time.sleep(2)
if __name__ == &#39;__main__&#39;:
    # 创建线程
    for i in range(5):
        say_thread = threading.Thread(target=say_sorry)
        say_yas = threading.Thread(target=yas)
        #启动线程
        say_thread.start()
        say_yas.start()</code></pre>
<p><strong>协程</strong></p>
<p>协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p>
<p>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>守护进程就是，一个进程被停掉了，或者崩了，他可以自己满血复活，自己重新启动</p>
<p>比方说我们的Django服务崩了，它如果不能自动重启服务，他就不是守护进程，</p>
<p>它自己启动了，就是。</p>
<p>我们电脑里就有许多例子，我的电脑系统后台的任务，有许多都关不了，你关了它就会自动重新启动。</p>
<p><strong>守护进程</strong></p>
<pre><code class="python">  from multiprocessing import Process
  import time
  import random

  def task(name):
      print(&#39;%s is piaoing&#39; %name)
      time.sleep(random.randrange(1,3))
      print(&#39;%s is piao end&#39; %name)


 if __name__ == &#39;__main__&#39;:
     p=Process(target=task,args=(&#39;egon&#39;,))
     p.daemon=True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行
     p.start()
     print(&#39;主&#39;) #只要终端打印出这一行内容，那么守护进程p也就跟着结束掉了</code></pre>
<h4 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h4><p>作用是在一个进程内，同一时刻只有一个线程执行</p>
<p>目的是不让多个线程同时对一个资源进行访问，实现了保护数据的问题，就有了Gil</p>
<p>如果你开了多个线程同时访问一天数据，那么在同一时间间内就只有一个线程可以放我，其他的进入等待，</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-排行榜</title>
    <url>/blog/2020/04/08/Django-%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
    <content><![CDATA[<h4 id="来，我们来做一个排行榜的功能"><a href="#来，我们来做一个排行榜的功能" class="headerlink" title="来，我们来做一个排行榜的功能"></a>来，我们来做一个排行榜的功能</h4><p>排行榜就是点击量由高到低的排序<br>可以利用redis的功能</p>
<ol>
<li><p>首先进行导包</p>
<pre><code>#导入redis数据库
import redis
#定义ip地址和端口
host = &#39;127.0.0.1&#39;
port = 6379
r = redis.Redis(host=host,port=port)</code></pre></li>
<li><p>创建视图类</p>
<pre><code>#  排行榜
class GoodsClink(APIView):
 def get(self,request):
     id = request.GET.get(&quot;id&quot;)  #获取商品ID
     print(id)
     r.zincrby(&quot;goods_rank&quot;,1,int(id))    #利用redis把访问量加一
     print( r.zrange(&#39;goods_rank&#39;,0,-1,desc=True,withscores=True))   #打印一下查看是否成功！！
     #get_top_n(10)
     return Response({&quot;message&quot;:&quot;访问加一&quot;})</code></pre></li>
<li><p>利用ID查出相对应的商品</p>
<pre><code>def get_top_n(num):
 goods_click = r.zrange(&#39;goods_rank&#39;,0,-1,desc=True,withscores=True)[:num]
 goods = Goods.objects.in_bulk([int(item[0]) for item in goods_click])
 res = []
 for item in goods_click:
     res.append({int(item[1]):goods[int(item[0])]})
 print(res)
 return res</code></pre></li>
</ol>
<ol start="4">
<li>查看所有商品的点击数和商品详情<pre><code>class GoodsRank(APIView):
 def get(self,request):
     get_res = get_top_n(10)
     res = []
     for dic in get_res:
         for k,v in dic.items():
             data = goods_ser(v).data
             data[&#39;clicks&#39;] = k
             res.append(data)
     print(res)
     return Response(res)</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索框 &amp; 智能提示</title>
    <url>/blog/2020/04/08/%E6%90%9C%E7%B4%A2%E6%A1%86%20&amp;%20%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="如果在写一个关于商城或者其他的项目"><a href="#如果在写一个关于商城或者其他的项目" class="headerlink" title="如果在写一个关于商城或者其他的项目"></a>如果在写一个关于商城或者其他的项目</h4><p>为了提高用户体验 ，可以把搜索框加一个智能提示</p>
<ol>
<li>智能提示可以用heyui框架的autocomplete标签</li>
</ol>
<p><img src="/my_blog/img/heyui_kuang.png" srcset="/img/loading.gif" alt="heyui_kuang"></p>
<ol start="2">
<li><p>点击展开代码，吧一下代码复制到你的vue界面的模板层</p>
<p><img src="/my_blog/img/heyui_template.png" srcset="/img/loading.gif" alt="heyui_template"></p>
</li>
</ol>
<p>也可以吧div放在你喜欢的位置</p>
<ol start="3">
<li><p>复制一下代码，放在vue的逻辑层</p>
<blockquote>
<pre><code class="vue">&lt;script&gt;

import jsonp from &#39;fetch-jsonp&#39;;

const loadData = function (filter, callback) {
 // this 为 option 配置
 // this.orgId 使用传递的参数获取数据，例：搜索某公司下的员工
 jsonp(`https://suggest.taobao.com/sug?code=utf-8&amp;q=${filter}`)
   .then(response =&gt; response.json())
   .then((d) =&gt; {
     callback(d.result.map((r) =&gt; {
       return r[0];
     }));
   });
};

export default {
 data() {
   return {
     value: &#39;测试&#39;,
     param: {
       orgId: 1, // 自定义参数传递
       loadData,
       minWord: 1
     }
   };
 },
 methods: {
   onChange(data, trigger) {
     log(data, trigger);
   }
 }
};
&lt;/script&gt;</code></pre>
</blockquote>
</li>
</ol>
<h5 id="建议！！！"><a href="#建议！！！" class="headerlink" title="建议！！！"></a>建议！！！</h5><p>heyui的这个插件默认只能选择，提示的选项，自己输入的就提交不到逻辑层</p>
<p>你需要在AutoComplete 标签里添加 <code>:must-match=&quot;false&quot;</code></p>
<p>目的是让AutoComplete 标签可以使用输入的参数！!!</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;value:{{value}}&lt;/p&gt;
    &lt;div v-width=&quot;300&quot;&gt;&lt;AutoComplete :must-match=&quot;false&quot; :option=&quot;param&quot; v-model=&quot;value&quot; @change=&quot;onChange&quot; type=&quot;title&quot;&gt;&lt;/AutoComplete&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>]]></content>
      <categories>
        <category>Vue</category>
        <category>element</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客，并上传到Gitee，码云</title>
    <url>/blog/2020/04/06/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Gitee/</url>
    <content><![CDATA[<ol>
<li><p>第一步，首先你要检测你是否安装node.js  </p>
<pre><code>node -v     #如果打印出版本号就说明已经安装</code></pre></li>
</ol>
<p>如果没安装node.js  ,就访问 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a>      并下载，安装</p>
<ol start="2">
<li><p>检验node.js的npm命令</p>
<pre><code>npm -v</code></pre></li>
</ol>
<ol start="3">
<li><p>安装Hexo</p>
<pre><code>npm install -g hexo-cli</code></pre><p>等待安装完成</p>
<pre><code>hexo -v  #检验是否安装成功</code></pre><a id="more"></a>
</li>
<li><p>在 本地新建一个文件夹，用来存放个人博客，</p>
<pre><code>mkdir blog
cd blog   #进入到文件夹</code></pre></li>
<li><p>新建Hexo项目</p>
<pre><code>hexo init my_blog  # my_blog=项目名称</code></pre><p>这个过程会比较慢，需要稍微等一会！</p>
<p>建议在看到进度条的时候可以停掉，</p>
<p>因为实在下载主题，时间会比较长</p>
<p><img src="/img/hexo_themes.png" srcset="/img/loading.gif" alt="hexo_themes"></p>
</li>
<li><pre><code>执行  npm istall</code></pre><p>安装一些配置文件 ，要等一等，不要急哦！！</p>
</li>
<li><p>以上执行完以后，就可以运行啦！！！</p>
<pre><code>hexo server    #简写 hexo s</code></pre><p>出现端口号就可以在本地浏览器访问啦！！</p>
</li>
</ol>
<p>   <img src="/img/hexo_port.jpg" srcset="/img/loading.gif" alt="hexo_themes"></p>
<p>​    出现页面就成功啦！！</p>
<p><img src="/img/hexo_helloworld.jpg" srcset="/img/loading.gif" alt="hexo_helloworld"></p>
<ol start="8">
<li><p>接下来上传gitee码云</p>
<p>8.1 登录码云新建仓库，输入仓库名称，点击公开，下拉点击创建。</p>
<p><img src="/img/hexo_gitee_new.png" srcset="/img/loading.gif" alt="hexo_gitee_new"></p>
</li>
<li><p>利用编辑器Visual Studio Code或其他的都可以，打开_config.yml</p>
<p><img src="/img/hexo_gitee_deploy.jpg" srcset="/img/loading.gif" alt="hexo_gitee_deploy"></p>
</li>
</ol>
<p><img src="img/hexo_gitee_url.jpg" srcset="/img/loading.gif" alt="hexo_gitee_url"></p>
<ol start="10">
<li><p>生成打包文件</p>
<p>在跟_config.yml同级的目录下执行命令</p>
<pre><code>hexo g   #把项目打包</code></pre></li>
</ol>
<ol start="11">
<li><p>在生成的public文件目录下</p>
<pre><code>git init    #初始化
git remote add origin  +  自己的仓库地址  #建立关系
</code></pre><p>然后素质三连提交代码</p>
<pre><code>git add -A   #提交当前目录下的所有文件
git commit -m &#39;blog&#39; # 备注
git push origin master</code></pre></li>
</ol>
<ol start="12">
<li><p>提交上以后</p>
<p>点击服务，点击gitee pages</p>
<p><img src="/img/hexo_gitee_pages.png" srcset="/img/loading.gif" alt="hexo_gitee_pages"></p>
</li>
</ol>
<p>下滑，点击启动</p>
<p><img src="/img/hexo_gitee_start.png" srcset="/img/loading.gif" alt="1"></p>
<h4 id="生成路由就可以访问啦！！！"><a href="#生成路由就可以访问啦！！！" class="headerlink" title="生成路由就可以访问啦！！！"></a>生成路由就可以访问啦！！！</h4><h3 id="你的简易的个人博客搭建好啦"><a href="#你的简易的个人博客搭建好啦" class="headerlink" title="你的简易的个人博客搭建好啦"></a>你的简易的个人博客搭建好啦</h3>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue &amp;&amp; 设计模式 &amp;&amp; Django知识</title>
    <url>/blog/2020/04/04/Vue%20&amp;&amp;%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20&amp;&amp;%20Django%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<pre><code></code></pre><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>位于用户的计算机上，用来维护用户计算机中的信息，直到用户删除。比如我们在网页上登录某个软件时输入用户名及密码时如果保存为cookie，则每次我们访问的时候就不需要登录网站了。我们可以在浏览器上保存任何文本，而且我们还可以随时随地的去阻止它或者删除。我们同样也可以禁用或者编辑cookie，但是有一点需要注意不要使用cookie来存储一些隐私数据，以防隐私泄露</p>
<h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站</p>
<a id="more"></a>

<h5 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h5><p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：</p>
<p>v-bind 指令被用来响应地更新 HTML 属性：</p>
<p><code>v-text</code> 等同大胡子效果 但是会转换为字符串</p>
<p><code>v-html</code> 绑定html属性</p>
<p><code>v-if</code>和<code>v-show</code>的区别：<br><code>v-if</code>有更高的切换消耗；<br><code>v-show</code>有更高的初始渲染消耗；<br><code>v-if</code>适合运营条件不大可能改变；<br><code>v-show</code>适合频繁切换</p>
<p><code>v-for</code>: 循环</p>
<p><code>v-once</code> 只会渲染一次 即使数据改变</p>
<p><code>v-bind</code> 用来响应地更新html属性 使用场景：绑定接口请求得到的数据 简写： : ，可以绑定class和内联样式 </p>
<h5 id="vue与jquery的区别"><a href="#vue与jquery的区别" class="headerlink" title="vue与jquery的区别"></a>vue与jquery的区别</h5><p><code>vue</code>：<code>mvvm</code> 数据驱动影响视图 适用于复杂数据<br><code>jquery</code>：<code>mvc</code> 视图塞入数据 适用于复杂视图动效</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p><code>beforeCreate</code>（创建前）<br><code>created</code>（创建后）<br><code>beforeMount</code> (载入前)<br><code>mounted</code>（载入后）<br><code>beforeUpdate</code>（更新前）<br><code>updated</code>（更新后）<br><code>beforeDestroy</code>（销毁前）<br><code>destroyed</code>（销毁后）</p>
<h5 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h5><p>Vue.js用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。<br> 底层实现：Vue 将模板编译成虚拟 DOM 渲染函数。<br> 若果不用模板语法，也可以用渲染（render）函数，使用JSX语法。</p>
<ol>
<li>插值<br> 文本：双大括号{{}}<br> 原始html:  v-html输出真正的html<br> 特性： v-bind<br> js表达式</li>
<li>指令<br> v-xx： 值是一个单个js表达式 （v-for除外）比如v-bind:href=’url’ v-on:click=’fn’<br> 作用是当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<br> 修饰符：用于指出一个指令应该以特殊方式绑定。<br> 3.缩写 v-bind用 ： ，v-on用 @</li>
</ol>
<h5 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h5><p>class和内联样式是属性，都可以通过v-bind来绑定到DOM，高级的是v-bind在绑定class和style时候，结果表达式除了字符串，还可以绑定数组或对象。</p>
<h5 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h5><ul>
<li>下载模板，等待下载结束，才会继续执行别的任务：这种是：同步</li>
<li>下载模板的同时，把下载任务等在后台，继续做别的事情，等下载结束在来做模板：这是异步</li>
</ul>
<h5 id="aJAX-–-gt-data"><a href="#aJAX-–-gt-data" class="headerlink" title="aJAX   –&gt;data"></a>aJAX   –&gt;data</h5><ul>
<li>Application/json</li>
<li>cookie值携带token即可</li>
</ul>
<h5 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h5><ul>
<li>respons.set_cookie(key,value)</li>
</ul>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>from django.shorscuts import redirect</p>
<ul>
<li><p>301 永久重定向，给百度，搜狗这样的爬虫</p>
<p>web：index,com aaa.com</p>
</li>
<li><p>302</p>
</li>
</ul>
<h5 id="html的各种状态码"><a href="#html的各种状态码" class="headerlink" title="html的各种状态码"></a>html的各种状态码</h5><p>200 OK 正常返回信息</p>
<p>202 Accepted 服务器已接受请求，但尚未处理</p>
<p>302 Found 临时性重定向。</p>
<p>301 Moved Permanently 请求的网页已永久移动到新位置。</p>
<p>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>
<p>403 Forbidden 禁止访问。</p>
<p>404 Not Found 找不到如何与 URI 相匹配的资源，找不到页面</p>
<p>500 Internal Server Error 最常见的服务器端错误，代码错误</p>
<h5 id="Django框架全面讲解"><a href="#Django框架全面讲解" class="headerlink" title="Django框架全面讲解"></a>Django框架全面讲解</h5><p>Python的WEB框架有Django、Tornado、Flask 等多种，Django相较与其他WEB框架其优势为：大而全，框架本身集成了ORM、模型绑定、模板引擎、缓存、Session等诸多功能。</p>
<h5 id="mvc和mtv"><a href="#mvc和mtv" class="headerlink" title="mvc和mtv"></a>mvc和mtv</h5><p>MVC是众所周知的模式，即：将应用程序分解成三个组成部分:model(模型),view(视图),和 controller(控制 器)。其中：<br>      M——管理应用程序的状态（通常存储到数据库中），并约束改变状态的行为（或者叫做“业务规则”）。<br>      C——接受外部用户的操作，根据操作访问模型获取数据，并调用“视图”显示这些数据。控制器是将“模型”和“视图”隔离，并成为二者之间的联系纽带。<br>      V——负责把数据格式化后呈现给用户。</p>
<p>Django也是一个MVC框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式：</p>
<p>​    M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
<p>​    T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
<p>​    V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
<h5 id="Django常用一些命令"><a href="#Django常用一些命令" class="headerlink" title="Django常用一些命令"></a>Django常用一些命令</h5><p>　python manage.py runserver ip:port  (启动服务器，默认ip和端口为<a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a>)</p>
<p>　　python manage.py startapp appname  (新建 app)</p>
<p>　　python manage.py syncdb  (同步数据库命令，Django 1.7及以上版本需要用以下的命令）</p>
<p>　　python manage.py makemigrations  (显示并记录所有数据的改动)</p>
<p>　　python manage.py migrate  (将改动更新到数据库)</p>
<p>　　python manage.py createsuperuser  (创建超级管理员)</p>
<p>　　python manage.py dbshell  (数据库命令行)</p>
<p>　　python manage.py  (查看命令列表)</p>
<h5 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h5><p>　　ORM：<strong>Object Relational Mapping(关系对象映射)</strong></p>
<p>　　　　类名对应——》数据库中的表名</p>
<p>　　　　类实例对应———》数据库表里的一行数据</p>
<p>　　　　类属性对应———》数据库里的字段</p>
<p>　　　　obj.id  obj.name…..类实例对象的属性</p>
<h5 id="创建表实例"><a href="#创建表实例" class="headerlink" title="创建表实例"></a>创建表实例</h5><blockquote>
<p>class Department(models.Model):<br>“””<br>部门表<br>“””<br>title = models.CharField(verbose_name=’标题’,max_length=32)<br>class UserInfo(models.Model):<br>“””<br>用户表<br>“””<br>username = models.CharField(verbose_name=’用户名’, max_length=32)<br>depart = models.ForeignKey(verbose_name=’所属部门’,to=”Department”)</p>
</blockquote>
<h5 id="mvc框架"><a href="#mvc框架" class="headerlink" title="mvc框架"></a>mvc框架</h5><p>　MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<p>　　简单的说， MVC 是一种软件开发的方法，它把代码的定义和数据访问的方法（模型）与请求逻辑 （控制器）还有用户接口（视图）分开来。 这种设计模式关键的优势在于各种组件都是 松散结合 的。这样，每个由 Django驱动 的Web应用都有着明确的目的，并且可独立更改而不影响到其它的部分。 比如，开发者 更改一个应用程序中的 URL 而不用影响到这个程序底层的实现。 设计师可以改变 HTML 页面 的样式而不用接触 Python 代码。 数据库管理员可以重新命名数据表并且只需更改一个地方，无需从一大堆文件中进行查找和替换。</p>
<h5 id="MVT"><a href="#MVT" class="headerlink" title="MVT"></a>MVT</h5><p>M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</p>
<p>V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</p>
<p>T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。</p>
<ul>
<li>通过搞一个base.html</li>
<li>这个base.html可以包含两类<ul>
<li>block片断</li>
<li>其他html</li>
</ul>
</li>
<li>然后index.html继承base.html</li>
</ul>
<pre><code></code></pre>]]></content>
      <categories>
        <category>Vue</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2020/04/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git分支的创建、删除、切换</title>
    <url>/blog/2019/07/01/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h5 id="1、本地创建新分支并切换到新分支"><a href="#1、本地创建新分支并切换到新分支" class="headerlink" title="1、本地创建新分支并切换到新分支"></a>1、本地创建新分支并切换到新分支</h5><pre><code class="shell"># git checkout -b 分支名</code></pre>
<h5 id="2、提交分支到远程仓库"><a href="#2、提交分支到远程仓库" class="headerlink" title="2、提交分支到远程仓库"></a>2、提交分支到远程仓库</h5><pre><code class="shell"># git push origin 分支名</code></pre>
<h5 id="3、切换分支"><a href="#3、切换分支" class="headerlink" title="3、切换分支"></a>3、切换分支</h5><pre><code class="shell"># git checkout 分支名</code></pre>
<a id="more"></a>
<h5 id="4、删除远程分支"><a href="#4、删除远程分支" class="headerlink" title="4、删除远程分支"></a>4、删除远程分支</h5><pre><code class="shell"># git push origin --delete 分支名</code></pre>
<h5 id="5、删除本地分支"><a href="#5、删除本地分支" class="headerlink" title="5、删除本地分支"></a>5、删除本地分支</h5><pre><code class="shell"># git branch -D 分支名</code></pre>
<blockquote>
<p>Tips：其他分支命令</p>
</blockquote>
<ul>
<li>查看当前分支 <code>git branch</code></li>
<li>查看所属分支 <code>git branch -a</code></li>
</ul>
]]></content>
      <tags>
        <tag>日记本</tag>
      </tags>
  </entry>
</search>
